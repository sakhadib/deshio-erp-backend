id,category,api_title,api_description,route,Type,Authentication_Type,issue_title,issue_description
1,auth,Register,Create account (optional for employees via admin),api/auth/register,post,nan,Implement Auth Register API Endpoint for User Account Creation,"## Overview

This GitHub issue covers the implementation of the 'Register' API endpoint in the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations. The endpoint enables users to create new accounts, with optional admin-based creation for employees. Deshio features ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. Order domain includes states (pending→confirmed→fulfilled|cancelled), assignment, notes, promos, taxes, fraud flags. Fulfillment involves shipments, inter-store dispatch with tracking and POD. Returns handle RMA, restock, refunds, exchanges. Payments manage intents, captures, voids, refunds, and order synchronization. Accounting uses transaction headers and ledger entries for movements, reversals, reconciliation. Services include service orders with lifecycle and profitability. Integrations cover carriers, waybills, rates, tracking, webhooks, and notifications (email/SMS). Security & identity: user/role/permission with abilities, multi-role support, sessions, email verification, password reset, TOTP MFA, backup codes, API keys. Observability: audit events, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC, branch scope, tenancy, throttles, idempotency, input sanitizer, domain guards, upload guards, webhook signatures, cache headers. Reporting: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging, price history, cycle accuracy, promo impact, activity. State machines ensure legal transitions for orders, dispatches, etc., with RFC7807 problem+json for conflicts. APIs support bulk import/export, search, attachments, reindex, backups, feature flags, maintenance. Data in UTC, soft deletes, EAV for attributes, polymorphic notes/attachments, strict referential links. Design supports deterministic admin assignment, safe reservations, consistent ledger posting.

The registration process should integrate with security features like email verification and prepare for RBAC assignment.

## API Specifications

- **Category:** auth
- **Title:** Register
- **Description:** Create account (optional for employees via admin)
- **Route:** api/auth/register
- **HTTP Method:** post
- **Authentication:** nan

## Acceptance Criteria

- [ ] Implement the POST /api/auth/register endpoint in Laravel
- [ ] Validate incoming request data (e.g., email uniqueness, password strength)
- [ ] Create a new user record with hashed password and initial status (e.g., unverified)
- [ ] Trigger email verification process if applicable
- [ ] Handle optional employee registration via admin context
- [ ] Return appropriate success response with user details (excluding sensitive data)
- [ ] Implement error handling for validation failures, duplicate emails, etc., using RFC7807 problem+json
- [ ] Write unit and integration tests covering happy path, edge cases, and errors
- [ ] Ensure integration with middleware (e.g., input sanitizer, locale/tz, CORS)
- [ ] Add audit logging for registration events
- [ ] Verify soft delete compatibility and UTC timestamping
- [ ] Test for PII masking in logs and responses

## Technical Requirements

- Use Laravel controller (e.g., Auth/RegisterController) and define route in api.php
- Leverage Laravel's built-in validation (Request classes) for inputs like name, email, password, and optional fields (e.g., phone, role hints)
- Hash passwords using Laravel's Hash facade
- Integrate with User model, including relationships to roles/permissions if initial assignment is needed
- Use Eloquent for database interactions, ensuring strict referential integrity
- Implement state machine if registration involves initial user state transitions (e.g., pending verification)
- Add proper error handling with JSON responses, including 4xx/5xx status codes
- Consider caching/etag for any related resources, though minimal for register
- Ensure idempotency support via unique request IDs if retries are possible
- Integrate with queues for asynchronous tasks like sending verification emails
- Follow Deshio's middleware stack: RequestId, JSON limits, versioned content-negotiation, etc.
- Use polymorphic attachments if registration includes optional uploads (e.g., profile media)

## Authentication/Authorization Requirements

- No authentication required (public endpoint, 'nan')
- Post-registration, prepare for JWT/session/API key issuance on verification/login
- Enforce RBAC for optional admin-based employee registration (e.g., require 'create-user' permission)
- Integrate with email verification workflow; block unverified users from certain actions
- Support TOTP MFA setup post-registration if enabled
- Use domain guards to prevent unauthorized access attempts (e.g., fraud detection on suspicious registrations)

## Expected Request/Response Format Considerations

- **Request:** JSON body with fields like {""name"": ""string"", ""email"": ""string"", ""password"": ""string"", ""password_confirmation"": ""string"", optional: ""phone"", ""branch_id"", ""is_employee"": boolean}
- Validation: Email must be unique, password min 8 chars with complexity rules, confirmations match
- **Response (Success - 201 Created):** {""data"": {""id"": integer, ""name"": ""string"", ""email"": ""string"", ""email_verified_at"": null, ""created_at"": ""UTC datetime""}, ""message"": ""Account created successfully. Please verify your email.""}
- **Response (Error - 422 Unprocessable Entity):** RFC7807 format, e.g., {""title"": ""Validation Error"", ""detail"": ""The email has already been taken."", ""source"": {""pointer"": ""/data/attributes/email""}}
- Exclude sensitive fields like password in responses
- Use JSON:API or similar structure if standardized in Deshio
- Support content-negotiation for versioned responses

## Relevant Business Logic

- Account creation is primary for customers; optional for employees via admin to assign initial roles/permissions
- Trigger email verification immediately after creation; use notification templates for email/SMS
- If employee flag, bypass verification or assign to specific branch/store scope
- Integrate with blacklist/tags for customer entities if applicable
- Ensure ledger/audit events for user creation (e.g., audit_event log)
- Handle conflicts with state machines (e.g., invalid transition if email already exists)
- Support feature flags for registration options (e.g., enable/disable MFA prompt)
- Maintain consistency with Deshio's design: deterministic assignment, safe operations, UTC storage, soft deletes for future archival"
2,auth,Login,Authenticate user and get token,api/auth/login,post,nan,Implement Auth Login API Endpoint for Deshio ERP,"## Overview

This GitHub issue is for implementing the Login API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The Login endpoint authenticates users and returns a token, enabling secure access to the system's features like RBAC, sessions, and API keys.

## API Specifications

- **Category:** auth
- **Title:** Login
- **Description:** Authenticate user and get token
- **Route:** api/auth/login
- **HTTP Method:** post
- **Authentication:** nan

## Acceptance Criteria

- [ ] Implement the POST /api/auth/login endpoint in Laravel
- [ ] Validate incoming request data (e.g., email and password)
- [ ] Authenticate user credentials against the user entity
- [ ] Generate and return an authentication token (JWT or session-based)
- [ ] Handle successful login with appropriate user data and token
- [ ] Return proper error responses for invalid credentials (e.g., 401 Unauthorized)
- [ ] Ensure compliance with security middleware (e.g., rate limiting, input sanitization)
- [ ] Write unit and integration tests covering success, failure, and edge cases
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger)
- [ ] Verify integration with email verification and 2FA if applicable

## Technical Requirements

- Use Laravel controller (e.g., AuthController) and define route in api.php
- Implement input validation using Laravel's Form Requests or Validator
- Leverage Laravel's authentication system (e.g., Auth::attempt()) for credential verification
- Generate token using Sanctum, Passport, or custom JWT implementation
- Include proper error handling with RFC7807 problem+json for conflicts or validation errors
- Apply middleware such as ThrottleRequests, SanitizeInput, and CORS
- Log authentication attempts via audit_event for observability and compliance
- Ensure data handling aligns with PII masking and UTC storage
- Support session management or API keys post-login
- Handle soft deletes and active user checks

## Authentication/Authorization Requirements

- This endpoint is public (no prior authentication required, as indicated by 'nan')
- Post-authentication, enforce RBAC via user_role and permission checks in middleware
- Integrate with email verification, TOTP MFA, and backup codes for enhanced security
- Generate API keys or JWT tokens with scopes tied to user roles/permissions
- Include active user validation and branch scope if applicable

## Expected Request/Response Format Considerations

- **Request Body (JSON):** Expect fields like {""email"": ""string"", ""password"": ""string""}; optional fields for remember_token or device info
- **Response (Success - 200 OK):** {""token"": ""string"", ""user"": {""id"": int, ""email"": ""string"", ""name"": ""string"", ""roles"": [array]}, ""expires_at"": ""datetime""}
- **Response (Error - 401 Unauthorized):** RFC7807 format, e.g., {""type"": ""urn:ietf:rfc:7807"", ""title"": ""Authentication Failed"", ""detail"": ""Invalid credentials""}
- **Response (Validation Error - 422 Unprocessable Entity):** {""errors"": {""email"": [""Invalid email""], ""password"": [""Required""]}}
- Use content-negotiation for JSON responses; include cache headers and ETag if applicable

## Relevant Business Logic

- Authenticate against user entity, checking for email verification and active status
- Upon success, issue token with user details (excluding sensitive PII unless necessary)
- Trigger audit_event for login attempts (success/failure) with request-id
- Support password reset flows integration; enforce throttles to prevent brute-force attacks
- Align with state machines for user session lifecycle; ensure idempotency for repeated logins
- Post-login, enable access to core entities like orders, inventory, and payments with RBAC guards
- Handle multi-role assignments via user_role junction for permission-based access"
3,auth,Refresh Token,Refresh auth token,api/auth/refresh,post,Employee,Implement Auth Token Refresh Endpoint (POST /api/auth/refresh),"## Overview

Deshio is a Laravel-based ERP system for retail/omni-channel operations, featuring approximately 290 REST APIs built over a normalized ERD that covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes (fields/features), media (product images), barcodes, pricing (price overrides), and promotions; stores/branches; customers with tags/blacklists. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers.

The order domain handles order/order_item states (pending → confirmed → fulfilled|cancelled), assignment to stores, notes/attachments, promotions, taxes, and fraud flags. Fulfillment involves shipments (shipment/shipment_item) and inter-store dispatches (dispatch + tracking, scan events, POD) with transactional stock movements. Returns are managed via RMA (return/return_item), including receive/restock/scrap, refunds, and exchanges (exchange_order). Payments follow an intent → payment capture/void lifecycle, with refund handling and order.payment_status synchronization.

Accounting uses transaction headers + ledger_entry lines for all movements, supporting reversals, reconciliation, and exports. Services include service/service_order with lifecycle and profitability tracking. Integrations cover carriers & accounts, waybills/rates/tracking; webhooks with deliveries; and notification templates (email/SMS).

Security and identity features include user/role/permission with abilities (role ↔ perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; and API keys. Observability and compliance encompass audit_event, logs, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware stack includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, and cache headers.

Reporting/analytics provide revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, and activity. State machines ensure legal transitions for orders, order items, dispatch, shipments, returns, payments, and cycle counts; conflicts return RFC7807 problem+json.

APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC with soft deletes for archival; EAV for attributes; polymorphic notes/attachments; and strict referential links across junctions. The design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This issue focuses on implementing the 'Refresh Token' API endpoint in the auth category, which refreshes the authentication token for employees, ensuring secure session prolongation in the Deshio ERP system.

## API Specifications

- **Category:** auth
- **Title:** Refresh Token
- **Description:** Refresh auth token
- **Route:** api/auth/refresh
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint handles POST requests to /api/auth/refresh and refreshes valid tokens
- [ ] Returns new access and refresh tokens on success
- [ ] Invalidates old refresh token after use
- [ ] Applies middleware for auth, RBAC (employee role/permission), active user, email-verified, and 2FA
- [ ] Includes request-id, idempotency, input sanitization, and proper error handling per RFC7807
- [ ] Logs audit events for token refresh actions
- [ ] Handles rate limiting and throttling for security
- [ ] Supports JSON content-negotiation with versioning
- [ ] Tests cover success, invalid token, expired token, and unauthorized access scenarios
- [ ] Integrates with JWT/session/API key auth mechanisms
- [ ] Ensures UTC handling and soft delete compliance if applicable

## Technical Requirements

- Implement in Laravel using a dedicated controller (e.g., AuthController@refresh)
- Define route in api.php with appropriate middleware stack: auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks for employee access
- Use Laravel's built-in validation for request inputs (e.g., refresh_token field)
- Handle token refresh logic: validate refresh token, generate new access/refresh tokens, invalidate old refresh token
- Include domain guards if relevant (e.g., for auth-related fraud detection)
- Ensure idempotency via request-id or token
- Add proper cache headers and ETag support
- Integrate with observability: audit_event logging, request-id tracing, PII masking for tokens
- Use state machine if needed for auth state transitions
- Support bulk or related operations if extensible (e.g., refresh with session data)
- Write unit/integration tests with PHPUnit, covering edge cases
- Document in API specs (e.g., OpenAPI/Swagger)

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- RBAC check: User must have employee role with permission to refresh tokens (e.g., 'auth.refresh')
- Enforce active user status, email verification, and 2FA (TOTP or backup codes)
- Branch scope if applicable (though auth may be global)
- Optional tenancy isolation
- Reject if user is blacklisted or fraud-flagged

## Expected Request/Response Format Considerations

- **Request:** JSON body with {""refresh_token"": ""string""} or via Authorization header; supports idempotency-key header
- **Response (Success 200):** JSON {""access_token"": ""string"", ""refresh_token"": ""string"", ""expires_in"": integer, ""token_type"": ""Bearer""}
- **Response (Error 401/403):** RFC7807 problem+json, e.g., {""type"": ""https://example.com/probs/unauthorized"", ""title"": ""Invalid refresh token"", ""status"": 401, ""detail"": ""Token expired or invalid""}
- Validate inputs with Laravel Validator: required refresh_token string
- Ensure secure token handling: HTTPS only, no logging of token values (PII masking)
- Content-type: application/json; versioned via Accept header (e.g., application/vnd.deshio.v1+json)

## Relevant Business Logic

- Token refresh extends active sessions without re-authentication, supporting long-running ERP operations (e.g., order processing, inventory adjustments)
- Invalidate old refresh token to prevent replay attacks; rotate tokens for security
- Sync with user state: if user deactivated or permissions changed during session, deny refresh
- Integrate with audit trails: log refresh events with user_id, ip, timestamp for compliance
- Align with overall auth flow: post-login tokens can be refreshed until expiry or revocation
- Handle edge cases like concurrent refreshes or token revocation via blacklist
- Ensure consistency with ledger/audit posting if refresh triggers any state change (unlikely, but check for session updates)"
4,auth,Logout,Revoke current session,api/auth/logout,post,Employee,Implement Auth Logout Endpoint for Employee Sessions,"## Overview

This GitHub issue is for implementing the Logout API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain handles states from pending to fulfilled/cancelled, with assignments, notes, promos, taxes, and fraud flags. Fulfillment involves shipments, inter-store dispatches with tracking and POD. Returns manage RMAs, restocking, refunds, and exchanges. Payments track intents, captures, voids, refunds, and order synchronization. Accounting uses transaction headers and ledger entries for movements, reversals, and reconciliation. Services include service orders with lifecycle and profitability. Integrations cover carriers, waybills, rates, tracking, webhooks, and notifications. Security and identity encompass users/roles/permissions, sessions, email verification, password reset, TOTP MFA, backup codes, and API keys. Observability includes audit events, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines ensure legal transitions for orders, dispatches, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, strict referential links. Design supports deterministic admin assignment, safe reservation/consumption, and consistent ledger posting.

The Logout endpoint specifically revokes the current employee session, ensuring secure session termination as part of the auth category.

## API Specifications

- **Category:** auth
- **Title:** Logout
- **Description:** Revoke current session
- **Route:** api/auth/logout
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST /api/auth/logout endpoint in Laravel to revoke the current employee session
- [ ] Ensure the endpoint invalidates the session and returns a success response
- [ ] Add unit and integration tests for session revocation, including authenticated and unauthenticated requests
- [ ] Verify integration with middleware for auth (JWT/session/API key), active user, email-verified, 2FA, and RBAC checks
- [ ] Test error handling for invalid sessions or unauthorized access, returning RFC7807 problem+json
- [ ] Confirm audit logging of the logout event in audit_event table
- [ ] Ensure the endpoint respects idempotency and throttling
- [ ] Validate that post-logout, the user cannot access protected resources without re-authentication
- [ ] Document the endpoint in API specs with request/response examples

## Technical Requirements

- Use Laravel controller (e.g., AuthController) and define the route in api.php with proper middleware stack: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (session for employee), active user, email-verified, 2FA, RBAC & permission checks (logout permission), branch scope, throttles, idempotency, input sanitizer
- Implement session invalidation using Laravel's Auth::logout() or equivalent for employee sessions
- Handle soft deletes and UTC timestamps for any related audit records
- Integrate with state machines if applicable for session lifecycle
- Use ETag/caching headers appropriately (likely none for logout)
- Ensure polymorphic attachments or notes are not affected
- Support feature flags for enabling/disabling logout behavior if needed
- Include input validation (minimal, as POST body may be empty)
- Add proper error handling with domain guards for auth-related conflicts

## Authentication/Authorization Requirements

- Requires Employee authentication via session, JWT, or API key
- Employee must be active, email-verified, and 2FA-enabled if configured
- RBAC: Employee role must have permission for logout action (defined in ability/role/permission tables with user_role multi-role support)
- Post-revocation, invalidate all associated sessions and tokens
- Integrate with security middleware for replay defense and signature checks if extending to API keys

## Expected Request/Response Format Considerations

- **Request:** POST /api/auth/logout
  - Body: Empty JSON {} (no required parameters)
  - Headers: Authorization (Bearer/JWT or session cookie), Accept: application/json, Content-Type: application/json
- **Response (Success - 204 No Content):** Empty body, indicating successful revocation
- **Response (Unauthorized - 401):** RFC7807 problem+json { ""title"": ""Unauthorized"", ""detail"": ""Session invalid or missing"" }
- **Response (Forbidden - 403):** RFC7807 problem+json if RBAC/permissions fail
- All responses include request-id header; use problem+json for errors with PII masking
- Data in UTC; no caching for sensitive auth endpoints

## Relevant Business Logic

- Revoke session to prevent further access, aligning with security & identity features (sessions, TOTP MFA, backup codes)
- Trigger audit_event for logout with user_id, timestamp, and request-id
- Synchronize with observability: log the event, update metrics for session activity
- Ensure transactional integrity: if revocation fails, rollback and return error
- No impact on other domains like orders/inventory, but may affect active user scope in branch/RBAC
- Support for multi-role users: revoke all applicable sessions
- Comply with compliance: soft delete any temporary session data, avoid PII in logs"
5,auth,Logout All,Revoke all active sessions,api/auth/logout-all,post,Employee,Implement Auth API: Logout All Sessions (POST /api/auth/logout-all),"## Overview

This GitHub issue is for implementing the 'Logout All' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint allows authenticated employees to revoke all their active sessions for enhanced security.

## API Specifications

- **Category:** auth
- **Title:** Logout All
- **Description:** Revoke all active sessions
- **Route:** api/auth/logout-all
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint handles POST requests to /api/auth/logout-all
- [ ] Successfully revokes all active sessions for the authenticated employee
- [ ] Returns a 200 OK response on success
- [ ] Returns appropriate error (401 Unauthorized) if not authenticated
- [ ] Returns 403 Forbidden if user lacks necessary permissions
- [ ] Integrates with middleware stack including auth, RBAC, and session management
- [ ] Logs audit event for the logout action
- [ ] Handles concurrent requests idempotently
- [ ] Includes unit and integration tests covering success, auth failure, and permission denial
- [ ] Documentation updated for API reference
- [ ] Endpoint is versioned and follows content-negotiation

## Technical Requirements

- Implement in a Laravel controller (e.g., AuthController) with route registration in api.php
- Use Laravel's session and auth facades to invalidate all user sessions
- Apply input validation if any parameters are added (currently none expected)
- Integrate with state machines if session revocation triggers any transitions
- Ensure compatibility with UTC timestamps and soft deletes for session records
- Use Eloquent for any database interactions related to sessions or audit logs
- Follow middleware chain: auth (JWT/session/API key), active user, RBAC & permission checks
- Implement proper error handling with RFC7807 problem+json for conflicts
- Add observability: request-id, audit_event logging, PII masking if applicable
- Consider caching/etag for related auth resources
- Support idempotency to prevent duplicate revocations

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- RBAC: User must have appropriate role/permission for self-session management (e.g., ability in role↔perm mapping)
- Enforce active user status, email verification, and optional 2FA
- Branch scope and optional tenancy if applicable to auth context
- Permission checks via middleware to ensure only the authenticated user can revoke their own sessions

## Expected Request/Response Format Considerations

- **Request:** POST /api/auth/logout-all
  - Body: Empty JSON object {} (no parameters required)
  - Headers: Authorization (Bearer token or API key), Content-Type: application/json, Accept: application/json

- **Response (Success - 200 OK):**
  ```json
  {
    ""message"": ""All active sessions revoked successfully""
  }
  ```

- **Response (Unauthorized - 401):**
  ```json
  {
    ""type"": ""https://tools.ietf.org/html/rfc7235#section-3.1"",
    ""title"": ""Unauthorized"",
    ""status"": 401,
    ""detail"": ""Invalid or missing authentication""
  }
  ```

- **Response (Forbidden - 403):**
  ```json
  {
    ""type"": ""https://tools.ietf.org/html/rfc7231#section-6.5.3"",
    ""title"": ""Forbidden"",
    ""status"": 403,
    ""detail"": ""Insufficient permissions to revoke sessions""
  }
  ```

- Use JSON limits middleware and input sanitizer
- Versioned responses via content-negotiation
- Cache headers disabled for auth endpoints

## Business Logic

- Upon successful authentication, query and invalidate all active sessions associated with the user (multi-role support via user_role)
- Trigger audit_event for compliance and observability
- Synchronize with security features like TOTP MFA and backup codes if sessions are tied to them
- Ensure no impact on other users' sessions; revocation is user-specific
- If integrated with queues, process revocation asynchronously if needed, but prefer synchronous for immediate effect
- Align with overall design for safe, deterministic operations in the auth domain
- Handle any polymorphic attachments or notes related to session events if applicable"
6,auth,Me,Get current user profile,api/auth/me,get,Employee,Implement GET /api/auth/me - Get Current User Profile,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the 'Me' API endpoint. This endpoint retrieves the current user's profile, supporting core entities like product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. Order domain includes states (pending→confirmed→fulfilled|cancelled), assignment, notes/attachments, promos, taxes, fraud flag. Fulfillment covers shipments, inter-store dispatch with tracking, scan events, POD, and transactional stock movements. Returns handle RMA, receive/restock/scrap, refunds, exchanges. Payments include intent→capture/void, refund lifecycle, order.payment_status sync. Accounting features transaction headers + ledger_entry lines, reversals, reconciliation/export. Services include service/service_order with lifecycle and profitability. Integrations cover carriers, waybills/rates/tracking, webhooks, notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm), user_role (multi-role), sessions, email verification, password reset, TOTP MFA + backup codes, API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive transitions for orders, items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data in UTC; soft deletes; EAV for attributes; polymorphic notes/attachments; strict referential links. Design enables deterministic admin assignment, safe reservation/consumption, consistent ledger posting.

This endpoint provides access to the authenticated employee's profile, ensuring compliance with security middleware and RBAC.

## API Specifications

- **Category:** auth
- **Title:** Me
- **Description:** Get current user profile
- **Route:** api/auth/me
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET /api/auth/me endpoint in Laravel controller
- [ ] Ensure endpoint returns current user profile with relevant details (e.g., user info, roles, permissions, branch scope)
- [ ] Apply all relevant middleware: auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, throttles, idempotency, input sanitizer
- [ ] Handle unauthenticated requests with appropriate 401 error (RFC7807 problem+json)
- [ ] Include audit_event logging for access
- [ ] Support PII masking in response if applicable
- [ ] Add request-id and cache headers (e.g., etag)
- [ ] Write unit/integration tests covering success, auth failure, inactive user, unverified email, 2FA required cases
- [ ] Ensure response is versioned via content-negotiation
- [ ] Validate against state machines if user state affects access
- [ ] Test with multi-role users and permission checks

## Technical Requirements

- Use Laravel framework for controller and routes definition
- Define route in api.php or relevant routes file: Route::get('/auth/me', [AuthController::class, 'me'])->middleware(['auth:employee', 'active.user', 'email.verified', '2fa', 'rbac', 'branch.scope', 'throttle', 'idempotency', 'sanitize.input'])
- Implement in AuthController or UserController with method to fetch Auth::user() or equivalent
- Leverage Eloquent models for User, Role, Permission with relationships (user_role multi-role, role↔perm abilities)
- Ensure soft deletes are respected (do not return deleted users)
- Use UTC timestamps in response
- Integrate with observability: log access via audit_event, include request-id
- Handle errors with RFC7807 problem+json for conflicts/invalid states
- Support locale/tz from middleware
- No input validation needed for GET, but apply domain guards if profile access has restrictions (e.g., fraud flag)
- Consider caching with etag for performance

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- Middleware chain: auth (JWT/session/API key) → active user → email-verified → 2FA (TOTP MFA + backup codes) → RBAC & permission checks (user must have permission to view own profile) → branch scope (limit to user's branches)
- Optional tenancy if enabled
- Reject if user is blacklisted or fraud flagged
- Sessions must be valid; API keys verified

## Expected Request/Response Format Considerations

- **Request:** GET /api/auth/me (no body, query params optional for locale/tz if not from headers)
- **Response:** 200 OK with JSON user profile, e.g., {
  ""data"": {
    ""id"": 1,
    ""name"": ""John Doe"",
    ""email"": ""john@example.com"",
    ""roles"": [{""id"":1,""name"":""admin""}],
    ""permissions"": [""view_profile"", ""manage_orders""],
    ""branches"": [{""id"":1,""name"":""Main Store""}],
    ""email_verified_at"": ""2023-01-01T00:00:00Z"",
    ""two_factor_enabled"": true,
    ""created_at"": ""2023-01-01T00:00:00Z"",
    ""updated_at"": ""2023-01-01T00:00:00Z""
  }
}
- Mask PII if required (e.g., partial email)
- Use problem+json for errors: e.g., 401 {""type"":""https://example.com/probs/unauthorized"",""title"":""Unauthorized"",""status"":401}
- Content-Type: application/json; version via header (e.g., Accept: application/vnd.deshio.v1+json)
- Cache-Control: private (user-specific)

## Relevant Business Logic

- Fetch current authenticated user via guard (employee)
- Include multi-role assignments and effective permissions
- Enforce state checks: user must be active, email verified, 2FA if enabled
- Apply branch scope: return only branches user has access to
- Log access as audit_event for compliance
- If user has customer tags/blacklist, include if relevant to profile
- Ensure no sensitive data (e.g., password hash, backup codes) in response
- Support feature flags for profile fields (e.g., hide certain attrs)
- Integrate with sessions: invalidate if needed post-2FA
- Consistent with overall design: deterministic, safe, ledger-aware (though not directly applicable here)"
7,auth,Send Email Verification,Send verification email,api/auth/email/send-verification,post,Employee,Implement Send Email Verification API (POST /api/auth/email/send-verification),"## Overview

This GitHub issue is for implementing the 'Send Email Verification' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. Order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment covers shipments (shipment/shipment_item) and inter-store dispatch with tracking, scan events, POD, and transactional stock movements. Returns include RMA (return/return_item), receive/restock/scrap, refunds, exchanges. Payments handle intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting features transaction headers + ledger_entry lines for movements; reversals; reconciliation/export. Services include service/service_order with lifecycle and profitability. Integrations cover carriers & accounts, waybills/rates/tracking; webhooks; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint specifically handles sending a verification email as part of the security and identity features, ensuring users verify their email addresses before full access.

## API Specifications

- **Category:** auth
- **Title:** Send Email Verification
- **Description:** Send verification email
- **Route:** api/auth/email/send-verification
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST endpoint at /api/auth/email/send-verification
- [ ] Ensure authentication requires Employee role with proper RBAC checks
- [ ] Add input validation for any request parameters (e.g., user email if provided)
- [ ] Integrate with email notification templates for verification emails
- [ ] Handle cases where email is already verified (return appropriate response)
- [ ] Include audit logging for the verification send event
- [ ] Write unit and integration tests covering success, failure, and edge cases
- [ ] Ensure compliance with middleware stack (auth, RBAC, email-verified checks, etc.)
- [ ] Verify response follows RFC7807 for errors and includes request-id
- [ ] Test for PII masking in logs and proper UTC handling

## Technical Requirements

- Use Laravel controller (e.g., AuthController) and define route in api.php with middleware (auth:employee, rbac:permission_check)
- Implement input validation using Laravel's Form Requests or Validator, sanitizing inputs
- Integrate with Laravel's notification system to send email using configurable templates (email/SMS fallback if needed)
- Handle business logic: Check if user email needs verification; generate and store verification token; queue email if high volume
- Ensure soft deletes and referential integrity are respected in user-related queries
- Add proper error handling: Return 200 for success, 400/403/422 for validation/auth errors in problem+json format
- Include observability: Log audit_event, add metrics for email send success/failure rates
- Support idempotency if multiple sends are possible (e.g., via request header)
- Consider caching/etag for repeated requests and throttles to prevent abuse
- Align with state machines if verification ties into user lifecycle transitions

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT/session/API key
- RBAC: Employee role must have permission for email verification actions (e.g., 'user:verify-email')
- Apply middleware: auth (JWT/session/API key), active user, email-verified (for the actor), 2FA if enabled, RBAC & permission checks
- Optional: Branch scope if verification is store-specific; tenancy if multi-tenant
- Reject unauthenticated/unauthorized with 401/403, including domain guards for auth actions

## Expected Request/Response Format Considerations

- **Request:** POST with optional JSON body (e.g., {""email"": ""user@example.com""} if resending for specific user); support multipart if attachments needed (unlikely)
- **Response:** 200 OK with JSON {""message"": ""Verification email sent"", ""request_id"": ""uuid""} on success; 204 No Content alternative
- Errors: RFC7807 problem+json, e.g., {""type"": ""https://example.com/probs/validation"", ""title"": ""Invalid email"", ""status"": 422, ""detail"": ""Email already verified""}
- Headers: Include X-Request-Id, Cache-Control, ETag if applicable; enforce CORS, JSON limits
- Versioned via content-negotiation; locale/tz from request for email formatting

## Relevant Business Logic

- Triggered for new user registrations or manual resends; part of user onboarding in security & identity
- Email contains unique verification token/link, valid for limited time (configurable)
- Upon send, update user record with sent_at timestamp; prevent spam with rate limiting
- Integrates with sessions and email verification flow; post-verification enables full features like order placement
- Audit every send for compliance; sync with observability for metrics on verification completion rates
- Handle failures gracefully (e.g., queue retry); support backups/restore for verification tokens if needed
- Ensure consistency with overall ERP design: UTC timestamps, soft deletes for failed attempts, polymorphic attachments if email includes files"
8,auth,Verify Email,Confirm email verification token,api/auth/email/verify,post,nan,Implement Verify Email API Endpoint (POST /api/auth/email/verify),"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.
Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This issue is for implementing the 'Verify Email' API endpoint in the auth category. This endpoint confirms the email verification token as part of the security and identity features, enabling email verification for users.

## API Specifications

- **Category:** auth
- **Title:** Verify Email
- **Description:** Confirm email verification token
- **Route:** api/auth/email/verify
- **HTTP Method:** post
- **Authentication:** nan

## Acceptance Criteria

- [ ] Implement the POST /api/auth/email/verify endpoint in Laravel
- [ ] Handle email verification token validation and user email marking as verified
- [ ] Return success response on valid token and appropriate RFC7807 problem+json errors for invalid/expired tokens or other failures
- [ ] Integrate with middleware stack including RequestId, input sanitizer, and no auth since 'nan'
- [ ] Ensure data handling in UTC and log audit_event for verification actions
- [ ] Add unit/integration tests covering valid/invalid token scenarios, error handling, and response formats
- [ ] Verify compatibility with email verification flow in security & identity (sessions, user roles)
- [ ] Confirm no PII exposure without masking in logs/responses
- [ ] Test endpoint with versioned content-negotiation and locale/tz middleware

## Technical Requirements

- Use Laravel controller (e.g., Auth\EmailVerificationController) and define route in api.php with POST method
- Implement input validation for the verification token (likely a required string field in request body)
- On success, update user record to mark email as verified, invalidate the token, and redirect or return JSON success (e.g., { ""message"": ""Email verified"" })
- Handle errors: token not found/expired (401/422), rate limiting via throttles middleware
- No authentication required ('nan'), but post-verification may trigger session/JWT updates if applicable
- Follow Deshio conventions: soft deletes awareness, EAV if attributes involved, polymorphic relations if notes/attachments needed
- Integrate with state machines if verification transitions user state (e.g., from pending to verified)
- Add observability: audit_event logging, request-id tracing, caching/etag if response cacheable
- Ensure idempotency for repeated verifications (e.g., ignore if already verified)
- Response format: JSON, with problem+json for errors per RFC7807
- Business logic: Align with security features like email verification, preventing access until verified (via middleware); support for multi-role users post-verification
- Consider integrations: Trigger notifications (email/SMS) on verification if templates exist; webhook if needed for external systems
- Testing: Include tests for middleware (CORS, JSON limits, sanitizer), error scenarios, and full flow from token generation to verification"
9,auth,Resend Verification,Resend verification email,api/auth/email/resend,post,Employee,Implement API: Resend Email Verification (POST /api/auth/email/resend),"## Overview

This API endpoint enables authenticated employees to resend a verification email to users who have not yet verified their email address. It is part of the authentication category in the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations. Deshio features ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core security and identity management includes user/role/permission with multi-role support, sessions, email verification, password reset, TOTP MFA + backup codes, and API keys. This endpoint supports the email verification process, ensuring secure user onboarding. Data is stored in UTC, with soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential links. Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified (skippable for resend), 2FA, RBAC & permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, and domain guards.

## API Specifications

- **Category:** auth
- **Title:** Resend Verification
- **Description:** Resend verification email
- **Route:** api/auth/email/resend
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST endpoint at /api/auth/email/resend
- [ ] Ensure endpoint is accessible only to authenticated employees via RBAC
- [ ] Resend verification email only if the user's email is not already verified
- [ ] Return appropriate success response (e.g., 200 with message) on successful resend
- [ ] Handle errors per RFC7807 problem+json (e.g., 400 if already verified, 401 unauthorized)
- [ ] Apply relevant middleware: auth, active user, RBAC permission checks (e.g., 'resend-verification')
- [ ] Include state machine legality checks if applicable for user verification transitions
- [ ] Add unit tests for controller logic, integration tests for email sending
- [ ] Add API documentation with request/response examples
- [ ] Ensure idempotency and throttle protection
- [ ] Test for PII masking in logs and audit events

## Technical Requirements

- Develop in Laravel: Create controller (e.g., Auth\EmailVerificationController@resend) and register route in api.php with 'api' middleware group
- Use Laravel's built-in MustVerifyEmail trait and queueable mailable for verification emails (e.g., VerifyEmail mailable with signed URL)
- Input validation: Minimal or empty request body; validate authenticated user and unverified status (e.g., if (auth()->user()->hasVerifiedEmail()) abort(400))
- Business logic: Fetch authenticated user, generate new signed verification URL with expiration (e.g., 60 minutes), queue email via notification system (email templates from integrations)
- Authentication/authorization: Require 'Employee' auth (JWT/session/API key); RBAC check via Gate/Policy for 'resend-verification' permission; skip email-verified middleware for this endpoint; enforce active user and optional 2FA
- Expected request format: JSON POST with empty body or optional { ""email"": ""user@example.com"" } (if for other users, else use auth user); validate with FormRequest
- Expected response format: 200 OK with JSON { ""message"": ""Verification email resent"" }; errors as problem+json (e.g., { ""type"": ""https://example.com/probs/already-verified"", ""title"": ""Email already verified"", ""status"": 400 })
- Error handling: Conflicts return RFC7807; log audit_event for resend action; handle queue failures with retries; use request-id for tracing
- Integrations: Leverage notification templates (email/SMS if extended); observability via health/metrics, queues, caching/etag; ensure transactional consistency
- Testing: Cover happy path (unverified resend), edge cases (already verified, invalid auth, rate limit); mock mailer for tests
- Additional: Support bulk if future-scoped; align with Deshio's design for deterministic admin actions and consistent ledger posting (if audit impacts financials, though unlikely here)"
10,auth,Forgot Password,Request password reset email,api/auth/password/forgot,post,nan,Implement Forgot Password API Endpoint (POST /api/auth/password/forgot),"## Overview

Implement the 'Forgot Password' API endpoint for the Deshio ERP system, which allows users to request a password reset email. This endpoint is part of the authentication category and supports the security & identity features, including password reset functionality. Deshio is a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include users with email verification and password reset capabilities. Data is stored in UTC, with soft deletes, EAV for attributes, and strict referential links. Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers. Observability includes audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. State machines drive legality of transitions, with conflicts returning RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

## API Specifications

- **Category:** auth
- **Title:** Forgot Password
- **Description:** Request password reset email
- **Route:** api/auth/password/forgot
- **HTTP Method:** post
- **Authentication:** nan (no authentication required, as this is a public endpoint for password recovery)

## Acceptance Criteria

- [ ] Endpoint responds to POST requests at /api/auth/password/forgot without requiring authentication
- [ ] Validates input email address and ensures it exists in the users table
- [ ] Generates and sends a password reset email using notification templates (email/SMS if applicable)
- [ ] Handles rate limiting to prevent abuse (integrate with throttles middleware)
- [ ] Returns appropriate success/error responses in JSON format, following RFC7807 for errors
- [ ] Logs the request with request-id and audit_event for observability and compliance
- [ ] Ensures PII masking in logs for email addresses
- [ ] Integrates with email verification and password reset features in the user entity
- [ ] Tests cover valid/invalid emails, duplicate requests, and edge cases like soft-deleted users
- [ ] Endpoint is versioned and supports content-negotiation

## Technical Requirements

- Use Laravel controller (e.g., Auth\PasswordResetController) and define route in api.php with proper middleware stack (excluding auth, but including RequestId, JSON limits, locale/tz, throttles, input sanitizer, idempotency)
- Implement input validation using Laravel's Form Requests or Validator: require 'email' as string, validated against user emails
- Generate a unique reset token (e.g., via Laravel's Password::broker()) and store in password_resets table with expiration
- Queue the email notification using Laravel's notification system, with templates from notification templates entity (email/SMS)
- Handle exceptions with proper error responses: 422 for validation errors, 429 for throttling, 200 for success (no sensitive info in response)
- Ensure UTC timestamps for any created records
- Integrate with soft deletes: check if user is soft-deleted before processing
- Add unit/integration tests using PHPUnit, covering request/response, validation, email dispatching, and middleware
- Follow Deshio's design for deterministic behavior and consistent ledger/audit posting if applicable (though minimal for this endpoint)

## Authentication/Authorization Requirements

- No authentication required ('nan'), as this is an unauthenticated public endpoint for password recovery
- Post-reset, subsequent actions (e.g., actual reset) will require token validation
- RBAC not applicable here, but ensure active user checks are bypassed appropriately
- Supports email-verified users; optionally skip for recovery if business rules allow
- Integrate with TOTP MFA + backup codes indirectly, as reset may lead to re-enabling 2FA

## Expected Request/Response Format Considerations

- **Request Body (JSON):** {""email"": ""user@example.com""} – Validate email format and existence
- **Success Response (200 OK):** {""message"": ""If an account with that email exists, a reset link has been sent.""} – Generic to avoid email enumeration attacks
- **Error Responses:** 
  - 422 Unprocessable Entity: {""errors"": {""email"": [""The selected email is invalid.""]}}
  - 429 Too Many Requests: Rate limit exceeded
  - Use problem+json for detailed errors per RFC7807
- Response headers: Include request-id, cache headers (no-cache for security), ETag if applicable
- Support for bulk? No, single email per request

## Relevant Business Logic

- Check if email exists in users table (without revealing existence to prevent enumeration)
- If valid, create password_reset record with token, expiration (e.g., 60 minutes), and user_id
- Dispatch email with reset link containing signed token, using notification templates
- Handle timezone/locale from request for email formatting
- Ensure idempotency: If request repeated, don't send duplicate emails (use existing token if within expiry)
- Compliance: Audit the reset request event, mask PII in logs, support GDPR-like data handling
- Integration: After reset, sync with sessions, API keys, and user_role multi-role assignments
- Edge cases: Blacklisted customers (from customer tags/blacklist) may block resets; handle fraud flags if applicable
- Align with overall ERP flow: Enables recovery for users in orders, inventory adjustments, etc., maintaining referential integrity"
11,auth,Reset Password,Confirm reset with token,api/auth/password/reset,post,nan,Implement Reset Password API Endpoint (POST /api/auth/password/reset),"## Overview

This GitHub issue is for implementing the Reset Password API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The Reset Password endpoint allows users to confirm a password reset using a provided token, integrating with the security & identity features including password reset, email verification, and sessions.

## API Specifications

- **Category:** auth
- **Title:** Reset Password
- **Description:** Confirm reset with token
- **Route:** api/auth/password/reset
- **HTTP Method:** post
- **Authentication:** nan

## Acceptance Criteria

- [ ] Implement the POST /api/auth/password/reset endpoint in Laravel
- [ ] Add input validation for required fields like token, email, and new password
- [ ] Verify the reset token and ensure it matches the user's email
- [ ] Hash and update the user's password upon successful confirmation
- [ ] Invalidate the used reset token to prevent reuse
- [ ] Handle errors such as invalid/expired tokens or mismatched email with RFC7807 problem+json format
- [ ] Write unit tests for successful reset, invalid token, expired token, and edge cases
- [ ] Write integration tests to ensure endpoint works with email verification flow
- [ ] Ensure compliance with middleware: RequestId, JSON limits, versioned content-negotiation, locale/tz, input sanitizer, and no auth required (nan)
- [ ] Log audit_event for password reset actions
- [ ] Test for PII masking in logs and responses
- [ ] Verify data stored in UTC and soft deletes if applicable

## Technical Requirements

- Use Laravel controller (e.g., Auth\PasswordResetController) and define route in api.php
- Implement input validation using Laravel's FormRequest or Validator, enforcing strong password policies (length, complexity)
- Integrate with User model for token verification (e.g., using password_reset_tokens table or similar)
- Generate response in JSON format, following Deshio's REST API standards
- Apply relevant middleware: TLS/HSTS, CORS, no auth, active user checks if needed post-reset, email-verified optional
- Handle state transitions securely, ensuring token expiry and single-use
- Include proper error handling with HTTP status codes (200 for success, 400/422 for validation, 410 for expired token)
- Ensure idempotency if applicable, though unlikely for password reset
- Align with observability: add request-id, log events, metrics for reset attempts
- Support for sessions and API keys in broader auth context, but none for this endpoint

## Authentication/Authorization Requirements

- No authentication required (nan) as this is a public endpoint for password recovery
- Post-reset, user may need to re-authenticate via login
- Integrates with RBAC indirectly via user identity; ensure no unauthorized access to user data
- Align with security features: TOTP MFA + backup codes can be set post-reset if enabled

## Expected Request/Response Format Considerations

- **Request Body (JSON):** Expect fields like {""email"": ""user@example.com"", ""token"": ""reset-token-string"", ""password"": ""new-password"", ""password_confirmation"": ""new-password""}
- Validation: Email must match token owner, passwords must match and meet policy
- **Response (Success - 200):** {""message"": ""Password reset successfully"", ""user"": {basic user info without PII exposure}}
- **Response (Error - e.g., 422):** RFC7807 problem+json, e.g., {""title"": ""Invalid Token"", ""detail"": ""The provided token is invalid or expired"", ""status"": 422}
- Use content-negotiation for JSON; include cache headers (no-cache for security)
- Consider locale/tz for any timestamped responses

## Relevant Business Logic

- Confirm reset token validity and expiry (e.g., 60 minutes from generation)
- Ensure token is tied to user's email to prevent hijacking
- After reset, invalidate token and optionally notify user via email/SMS using notification templates
- Synchronize with user states: mark email as verified if part of flow, update last_password_reset timestamp
- Prevent concurrent resets; use transactions for atomicity
- Align with overall auth flow: password reset is part of identity management, enabling secure access to ERP features like orders, inventory, etc.
- Log for compliance: audit_event for reset confirmation, with request-id for traceability
- No financial/stock impacts, but ensures secure access to sensitive domains like payments and RBAC"
12,auth,Change Password,Change password (logged-in),api/auth/password/change,post,Employee,Implement Change Password API Endpoint (POST /api/auth/password/change),"## Overview

This GitHub issue is for implementing the 'Change Password' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. Order domain includes states (pending→confirmed→fulfilled|cancelled), assignment, notes/attachments, promos, taxes, fraud flags. Fulfillment covers shipments, inter-store dispatch with tracking and scan events. Returns handle RMA, restock/scrap, refunds, exchanges. Payments manage intents, captures/voids, refunds, and synchronization. Accounting uses transaction headers and ledger entries for movements, reversals, reconciliation. Services include service orders with lifecycle and profitability. Integrations cover carriers, waybills, tracking, webhooks, notifications. Security & identity: user/role/permission with abilities, multi-role, sessions, email verification, password reset, TOTP MFA, backup codes, API keys. Observability: audit events, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware: TLS/HSTS, CORS, RequestId, JSON limits, versioned negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC, branch scope, tenancy, throttles, idempotency, sanitizer, domain guards, upload guards, webhook signatures, cache headers. Reporting: revenue/orders/units by store/product/user, LTV/AOV, return rates, SLA, dispatch performance, inventory aging, price history, cycle accuracy, promo impact. State machines ensure legal transitions for orders, dispatches, etc., with RFC7807 errors. APIs support bulk import/export, search, attachments, reindex, backups, feature flags, maintenance. Data in UTC, soft deletes, EAV attributes, polymorphic notes, strict junctions. Design supports deterministic assignment, safe reservations, consistent ledger posting.

The endpoint allows logged-in employees to change their password securely, aligning with the system's security and identity features including password reset and MFA.

## API Specifications

- **Category:** auth
- **Title:** Change Password
- **Description:** Change password (logged-in)
- **Route:** api/auth/password/change
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST /api/auth/password/change endpoint in Laravel
- [ ] Ensure endpoint requires Employee authentication and is only accessible to logged-in users
- [ ] Validate input: require old_password, new_password, and confirm_new_password; enforce password strength policies (e.g., min length, complexity)
- [ ] Verify the old password matches the current one before allowing change
- [ ] Hash the new password using Laravel's built-in hashing (e.g., bcrypt)
- [ ] Update the user's password in the database and invalidate any active sessions if required by policy
- [ ] Return success response on valid change; handle errors like invalid old password or mismatch with RFC7807 problem+json
- [ ] Add unit and integration tests covering success, invalid old password, mismatch, weak password, and unauthorized access
- [ ] Ensure audit logging of the password change event
- [ ] Integrate with middleware stack: auth, active user, RBAC checks for password change permission
- [ ] Handle soft deletes and UTC timestamps appropriately
- [ ] Test for idempotency and throttling

## Technical Requirements

- Use Laravel controller (e.g., AuthController) and define route in api.php with proper naming and middleware
- Implement input validation using Form Requests or Validator facade; rules: old_password required and matches current hash, new_password required with strength rules (min:8, confirmed), no reuse of recent passwords if policy applies
- Error handling: 401 for unauthenticated, 403 for unauthorized, 422 for validation errors, 400 for business logic failures (e.g., invalid old password)
- Response: JSON with success message on 200, or error details; consider versioning via content-negotiation
- Database: Update users table password field; trigger any related events for sessions or MFA reset if needed
- Security: Use hashed comparisons (Hash::check), rate limit attempts, log via audit_event for compliance
- Integration: Align with RBAC (permission for 'change-password'), email verification if post-change, and observability (request-id, logs)

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- User must be active and email-verified
- Optional 2FA check before allowing change
- RBAC: Employee role must have permission for password self-management; admins may have broader access if extended
- Branch scope and tenancy if applicable, but likely global for auth

## Expected Request/Response Format Considerations

- **Request Body (JSON):** {
  ""old_password"": ""string"",
  ""new_password"": ""string"",
  ""confirm_new_password"": ""string""
}
- **Success Response (200):** {
  ""message"": ""Password changed successfully"",
  ""data"": {}  // or user details if needed
}
- **Error Response (e.g., 422):** RFC7807 problem+json, e.g., {
  ""title"": ""Validation Error"",
  ""detail"": ""Old password is incorrect"",
  ""status"": 422,
  ""errors"": { ""old_password"": [""Invalid""] }
}
- Use ETag/caching headers if applicable; sanitize inputs; limit JSON size

## Relevant Business Logic

- Password change must be secure: verify old, ensure new != old, confirm match, apply strength rules
- Invalidate sessions post-change to force re-login, enhancing security
- Log as audit_event for compliance and tracking
- If user has MFA, consider prompting reset or integration
- Align with state machine if password lifecycle is modeled; prevent changes during certain states (e.g., locked account)
- Support for backup codes or TOTP if change affects them
- Ensure consistency with password reset flow but for logged-in self-service"
13,auth,Enable 2FA,Enable TOTP 2FA,api/auth/2fa/enable,post,Employee,Implement API: Enable TOTP 2FA (POST /api/auth/2fa/enable),"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint enables TOTP 2FA for the authenticated employee user, integrating with Deshio's security and identity features including TOTP MFA and backup codes. It supports the overall auth category and ensures compliance with middleware like 2FA checks, RBAC, and audit events.

## API Specifications

- **Category:** auth
- **Title:** Enable 2FA
- **Description:** Enable TOTP 2FA
- **Route:** api/auth/2fa/enable
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST endpoint at /api/auth/2fa/enable
- [ ] Validate input for enabling TOTP 2FA (e.g., secret or code verification)
- [ ] Ensure endpoint requires Employee authentication and proper RBAC permissions
- [ ] Generate or store TOTP secret and backup codes upon successful enablement
- [ ] Return appropriate success response with 2FA status
- [ ] Handle errors per RFC7807 problem+json for invalid inputs or auth failures
- [ ] Add unit/integration tests covering happy path, validation errors, and auth denial
- [ ] Integrate with middleware stack including auth, 2FA, RBAC, and audit logging
- [ ] Verify soft deletes and UTC handling if applicable to user records
- [ ] Document the endpoint in API specs with request/response examples

## Technical Requirements

- Use Laravel controller (e.g., AuthController or TwoFactorController) and define route in api.php
- Implement input validation using Laravel's FormRequest or Validator for TOTP-related fields (e.g., secret, code)
- Leverage Laravel's built-in encryption for storing TOTP secrets securely
- Integrate with existing user model for updating 2FA status and storing backup codes
- Apply middleware: auth (JWT/session/API key), active user, email-verified, RBAC & permission checks
- Ensure idempotency and throttling via middleware
- Log audit_event for 2FA enablement actions
- Use state machine if needed for 2FA lifecycle transitions
- Handle exceptions with proper error responses (e.g., 401 Unauthorized, 422 Unprocessable Entity)
- Consider caching/etag for related user data if performance impacts

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- Employee must have active status and email verified
- RBAC: User must have permission to enable 2FA for their own account (self-service)
- Post-enablement, enforce 2FA in subsequent requests via middleware
- Support multi-role via user_role junction

## Expected Request/Response Format Considerations

- **Request:** JSON body, e.g., {""totp_code"": ""123456"", ""secret"": ""base32secret""} (validate against TOTP algorithm)
- **Response (Success 200):** JSON, e.g., {""success"": true, ""message"": ""2FA enabled"", ""backup_codes"": [""code1"", ""code2""], ""qr_code"": ""data:image/png;base64,...""} (optional QR for mobile app setup)
- **Response (Error):** RFC7807 problem+json, e.g., {""title"": ""Invalid TOTP Code"", ""status"": 422, ""detail"": ""Code does not match secret""}
- Content negotiation: versioned, JSON only
- Headers: Include Request-Id, cache headers; PII masking for secrets in logs

## Relevant Business Logic

- Enabling 2FA updates the user's MFA status in the database
- Generate backup codes upon enablement and store securely (hashed)
- Verify provided TOTP code against the secret to confirm setup
- Trigger email/SMS notification if configured in notification templates
- Ensure transactional integrity: if enable fails, rollback any partial updates
- Integrate with sessions: invalidate/renew session post-2FA enable
- Comply with observability: log the event with request-id, mask sensitive data
- For employees, scope to user's branch if applicable via middleware
- Align with overall security: supports TOTP MFA + backup codes for recovery
- If conflicts (e.g., already enabled), return appropriate error without state change"
14,auth,Verify 2FA,Verify TOTP code,api/auth/2fa/verify,post,Employee,Implement Auth API: Verify 2FA TOTP Code Endpoint,"## Overview

This issue covers the implementation of the 'Verify 2FA' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring approximately 290 REST APIs built over a normalized ERD. It covers key domains including catalog, orders, inventory, logistics, payments, RBAC, and audits.

Core entities include products/categories/vendors with attributes (fields/features), media (product images), barcodes, pricing (price overrides), and promotions; stores/branches; customers with tags/blacklists.

Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers.

The order domain handles order/order_item states (pending → confirmed → fulfilled|cancelled), assignment to stores, notes/attachments, promotions, taxes, and fraud flags.

Fulfillment involves shipments (shipment/shipment_item) and inter-store dispatches (dispatch + tracking, scan events, POD) with transactional stock movements.

Returns manage RMAs (return/return_item), receiving/restocking/scrap, refunds, and exchanges (exchange_order).

Payments cover intent → payment capture/void; refund lifecycles; and order.payment_status synchronization.

Accounting includes transaction headers + ledger_entry lines for all movements; reversals; and reconciliation/export.

Services handle service/service_order with lifecycles and profitability.

Integrations include carriers & accounts, waybills/rates/tracking; webhooks with deliveries; and notification templates (email/SMS).

Security & identity: user/role/permission with ability (role ↔ perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.

Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The 'Verify 2FA' endpoint specifically verifies TOTP codes as part of the security and identity features, integrating with TOTP MFA and backup codes.

## API Specifications

- **Category:** auth
- **Title:** Verify 2FA
- **Description:** Verify TOTP code
- **Route:** api/auth/2fa/verify
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST endpoint at api/auth/2fa/verify for verifying TOTP codes
- [ ] Ensure endpoint requires Employee authentication
- [ ] Add input validation for the TOTP code
- [ ] Integrate with existing TOTP MFA system, including support for backup codes
- [ ] Handle successful verification by updating user session/state (e.g., mark 2FA as verified)
- [ ] Return appropriate success response on valid code
- [ ] Return error responses for invalid/expired codes using RFC7807 problem+json format
- [ ] Apply relevant middleware: auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks
- [ ] Log audit events for verification attempts
- [ ] Write unit and integration tests covering valid/invalid codes, edge cases (e.g., expired sessions)
- [ ] Ensure compliance with observability: request-id, PII masking, caching/etag

## Technical Requirements

- Use Laravel controller and routes: Define in AuthController or dedicated 2FA controller, register route in api.php with proper prefix
- Input validation: Require TOTP code (e.g., 6-digit string), validate format and timeliness; consider idempotency for repeated submissions
- Proper error handling: Use state machine-like validation for 2FA flow; return 400 for invalid input, 401/403 for auth issues, 422 for validation failures
- Database interactions: Query user TOTP secret/backup codes from users table; update 2fa_verified_at or similar timestamp on success; soft deletes and UTC handling
- Integration with broader system: Tie into user/role/permission model; ensure post-verification enables access to protected endpoints

## Authentication/Authorization Requirements

- Authentication: Employee-level (JWT/session/API key); user must be active and email-verified
- Authorization: RBAC check for 2FA-related permissions; branch scope if applicable; enforce 2FA middleware only after initial auth
- Security: TLS/HSTS, CORS, throttles, input sanitizer; replay defense for 2FA attempts; domain guards for auth flows

## Expected Request/Response Format Considerations

- Request: JSON body with { ""totp_code"": ""123456"" } or { ""backup_code"": ""abcdef"" }; versioned content-negotiation
- Response: On success (200): { ""success"": true, ""message"": ""2FA verified"" }; On error (e.g., 400): RFC7807 problem+json like { ""type"": ""invalid_totp"", ""title"": ""Invalid code"", ""detail"": ""TOTP code is incorrect"" }
- Headers: Include request-id, cache headers; locale/tz support

## Relevant Business Logic

- Verify against user's TOTP secret (e.g., using Google Authenticator lib) or consume one-time backup code
- On success, extend session validity, enable 2FA-protected actions (e.g., sensitive order/payment ops)
- On failure, increment attempt counter; lockout after threshold to prevent brute-force
- Audit every attempt: Log user_id, ip, timestamp, success/failure in audit_event table
- Integrate with password reset/email verification flows; ensure deterministic state transitions for auth lifecycle
- Conflicts (e.g., code already used) return problem+json; support for multi-role users in RBAC context"
15,auth,Disable 2FA,Disable TOTP 2FA,api/auth/2fa/disable,post,Employee,Implement API: Disable TOTP 2FA (POST /api/auth/2fa/disable),"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint allows authenticated employees to disable TOTP-based two-factor authentication (2FA) for their account, enhancing user security management within the Deshio ERP system's auth category.

## API Specifications

- **Category:** auth
- **Title:** Disable 2FA
- **Description:** Disable TOTP 2FA
- **Route:** api/auth/2fa/disable
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint responds successfully to valid authenticated requests to disable 2FA
- [ ] Requires proper employee authentication and authorization
- [ ] Validates that 2FA is currently enabled before allowing disable
- [ ] Updates user record to reflect 2FA disabled status
- [ ] Clears any associated TOTP secrets and backup codes
- [ ] Logs audit event for the disable action
- [ ] Returns appropriate error for unauthorized or invalid requests (e.g., RFC7807 problem+json)
- [ ] Integrates with middleware stack including auth, RBAC, and 2FA checks
- [ ] Handles soft deletes and UTC timestamps correctly
- [ ] Includes unit and integration tests covering success, failure, and edge cases

## Technical Requirements

- Implement in Laravel using a dedicated controller (e.g., AuthController or TwoFactorController)
- Define route in api.php with proper middleware (auth:employee, verified, etc.)
- Use Laravel's built-in validation for request inputs (if any, e.g., current 2FA code for verification)
- Integrate with user model to update 2FA-related fields (e.g., totp_secret, backup_codes)
- Ensure compliance with observability: add audit_event, request-id, and logging
- Apply state machine if applicable for 2FA status transitions
- Support idempotency and throttling via middleware
- Use Eloquent for database interactions with soft deletes
- Version the API endpoint per content-negotiation middleware

## Authentication/Authorization Requirements

- Requires Employee authentication (JWT/session/API key)
- Enforce active user, email-verified, and current 2FA (if enabled) via middleware
- RBAC check: User must have permission to manage own 2FA (e.g., via role/permission abilities)
- Multi-role support; branch scope if applicable
- Optional tenancy isolation

## Expected Request/Response Format Considerations

- **Request:** POST with potential body for verification (e.g., {""totp_code"": ""123456""}); empty body if no verification needed, but recommend including for security
- **Response:** On success, 200 OK with JSON {""message"": ""2FA disabled successfully"", ""data"": {}} or similar; use consistent JSON structure
- **Errors:** 401 Unauthorized, 403 Forbidden, 422 Validation Error; return RFC7807 problem+json for conflicts (e.g., 2FA not enabled)
- Content negotiation for JSON; include cache headers and ETag if applicable
- PII masking for any sensitive logs

## Relevant Business Logic

- Disabling 2FA should only occur after verifying the current TOTP code to prevent unauthorized disables
- Update user session to reflect no 2FA requirement post-disable
- Trigger any notification templates (e.g., email confirmation of disable)
- Ensure ledger or audit trail for security events; no financial impact but compliance with observability
- Align with security & identity features: sessions, TOTP MFA + backup codes; post-disable, user may need to re-enable for access
- Conflicts (e.g., disable during active 2FA requirement) return problem+json; state machine enforces legal transitions"
16,auth,Get Backup Codes,Retrieve 2FA backup codes,api/auth/2fa/backup-codes,get,Employee,Implement API: Get 2FA Backup Codes (auth/2fa/backup-codes),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue covers implementing the 'Get Backup Codes' API endpoint in the auth category. This endpoint retrieves 2FA backup codes for employees, ensuring secure access management. Core entities include user/role/permission with multi-role support, sessions, email verification, password reset, TOTP MFA + backup codes, and API keys. Security features encompass middleware like TLS/HSTS, CORS, auth (JWT/session/API key), active user checks, email-verified, 2FA, RBAC & permission checks, and more. Data is stored in UTC with soft deletes, EAV for attributes, and strict referential integrity.

## API Specifications

- **Category:** auth
- **Title:** Get Backup Codes
- **Description:** Retrieve 2FA backup codes
- **Route:** api/auth/2fa/backup-codes
- **HTTP Method:** GET
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint returns a list of 2FA backup codes for the authenticated employee
- [ ] Requires 2FA to be enabled for the user
- [ ] Handles cases where no backup codes exist (e.g., generate if needed or error)
- [ ] Implements proper RBAC: only authenticated employees with relevant permissions
- [ ] Includes unit and integration tests for success, auth failure, and 2FA not enabled scenarios
- [ ] Adheres to RFC7807 problem+json for errors
- [ ] Supports middleware stack: auth, active user, email-verified, 2FA, RBAC checks
- [ ] Ensures response uses versioned content-negotiation and cache headers

## Technical Requirements

- Develop in Laravel: Create controller method in AuthController or similar, register route in api.php with 'api' middleware group
- Apply middleware: auth (JWT/session/API key), active user, email-verified, 2FA enforcement, RBAC & permission checks
- Input validation: None required for GET, but validate authentication context
- Error handling: 401 for unauth, 403 for insufficient perms, 404/422 if 2FA not set up; use problem+json format
- Integrate with user model: Fetch backup codes from user's 2FA configuration (e.g., encrypted storage in user table or related model)
- Observability: Log audit_event for access, include request-id, PII masking if applicable
- State machines: Ensure legality of 2FA state transitions if relevant

## Authentication/Authorization Requirements

- Authentication: Employee via JWT, session, or API key
- Authorization: RBAC check for permissions related to 2FA management (e.g., '2fa:read' permission via user_role and ability tables)
- Additional guards: User must be active, email-verified, and 2FA enabled; optional branch scope or tenancy if applicable
- Security: Input sanitizer, throttles, idempotency (though GET is idempotent)

## Expected Request/Response Format Considerations

- **Request:** No body; query params optional (e.g., ?format=plain for code display, but default JSON)
- **Response:** 200 OK with JSON: {""backup_codes"": [""code1"", ""code2"", ...]} – codes should be single-use, regenerate after use if policy requires
- Headers: ETag for caching, Content-Type: application/json; versioned via Accept header
- Errors: 4xx/5xx with problem+json: {""type"": ""urn:ietf:rfc:7807"", ""title"": ""Error message"", ""status"": 401, ...}

## Relevant Business Logic

- Backup codes are part of TOTP MFA setup; retrieve only for the authenticated user
- Codes enable recovery if TOTP device is lost; ensure they are securely stored/retrieved (e.g., hashed or encrypted)
- On retrieval, mark as viewed or regenerate if all used (per security best practices)
- Integrate with audit_event for logging access attempts
- Align with overall security: No PII exposure, comply with observability (logs, metrics), and support feature flags for 2FA variations
- Deterministic: Always return current valid codes; handle soft deletes if user history affects"
17,auth,Rotate API Key,Generate a new API key,api/auth/api-key/rotate,post,Admin,Implement Rotate API Key Endpoint (POST /api/auth/api-key/rotate),"## Overview

This GitHub issue covers the implementation of the 'Rotate API Key' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD that spans catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain handles states (pending→confirmed→fulfilled|cancelled), assignments, notes/attachments, promos, taxes, and fraud flags. Fulfillment involves shipments, inter-store dispatches with tracking and POD, and transactional stock movements. Returns manage RMAs, restocking, refunds, and exchanges. Payments cover intents, captures/voids, refunds, and synchronization. Accounting uses transaction headers and ledger entries for movements, reversals, and reconciliation. Services include service orders with lifecycle and profitability. Integrations handle carriers, waybills, rates, tracking, webhooks, and notifications. Security and identity encompass users/roles/permissions, sessions, email verification, password reset, TOTP MFA, backup codes, and API keys. Observability includes audit events, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC/permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures, replay defense, and cache headers. Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, and activity. State machines ensure legal transitions for orders, dispatches, shipments, returns, payments, cycle counts, with conflicts returning RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential links. Design supports deterministic admin assignment, safe reservations, and consistent ledger posting.

The endpoint allows admin users to rotate (generate a new) API key for enhanced security, integrating with the system's RBAC, auditing, and middleware stack.

## API Specifications

- **Category:** auth
- **Title:** Rotate API Key
- **Description:** Generate a new API key
- **Route:** api/auth/api-key/rotate
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST endpoint at /api/auth/api-key/rotate
- [ ] Ensure only authenticated admin users can access the endpoint
- [ ] Generate a new API key and invalidate/revoke the existing one for the user
- [ ] Return the new API key in the response (consider masking for security)
- [ ] Log the rotation event in the audit_event table
- [ ] Handle errors with RFC7807 problem+json format (e.g., 401 Unauthorized, 403 Forbidden)
- [ ] Add unit and integration tests for success and failure scenarios
- [ ] Include API documentation in OpenAPI/Swagger format
- [ ] Verify integration with middleware (auth, RBAC, throttles, idempotency)
- [ ] Ensure no impact on active sessions or other auth methods (JWT/session)

## Technical Requirements

- Define the route in Laravel's routes/api.php file with proper middleware stack (auth:admin, rbac:permission('api-key.rotate'), throttle, idempotency)
- Create or extend a controller (e.g., ApiKeyController) with a rotate method
- Use Laravel's API key generation utilities; store new key hashed in the database (e.g., api_keys table with user_id, key_hash, expires_at, last_used_at)
- Implement soft delete or revocation flag for the old key
- Input validation: No request body required, but validate if optional (e.g., specific key_id to rotate)
- Output: JSON response with { ""success"": true, ""new_api_key"": ""generated_key"" } or masked version
- Error handling: Use Laravel exceptions for auth failures, permission denials; return standardized errors
- Database: Ensure UTC timestamps; use transactions for key rotation to maintain consistency
- Testing: Cover admin auth, non-admin denial, key generation, audit logging, and edge cases like expired keys
- Security: Generate cryptographically secure keys; apply rate limiting to prevent abuse
- Observability: Add request-id tracing, log rotation events, and metrics for key management

## Authentication/Authorization Requirements

- Requires Admin-level authentication via JWT, session, or existing API key
- RBAC check: User must have 'api-key.rotate' permission via role→permission mapping
- Middleware enforcement: active user, email-verified, 2FA if enabled, branch scope (if applicable)
- For API key rotation, target the caller's own keys or specify via permission scope
- Integrate with TOTP MFA and backup codes if rotation requires elevated auth

## Expected Request/Response Format Considerations

- **Request:** POST /api/auth/api-key/rotate
  - Headers: Authorization (Bearer/JWT), Content-Type: application/json, X-Request-Id
  - Body: Optional JSON { ""key_id"": ""uuid-of-key-to-rotate"" } or empty for default user's key
  - Validation: Use Laravel FormRequest for optional fields, sanitize inputs

- **Response (Success - 200 OK):**
  {
    ""success"": true,
    ""data"": {
      ""new_api_key"": ""sk_abc123..."",
      ""rotated_at"": ""2023-10-01T12:00:00Z"",
      ""expires_at"": ""2024-10-01T12:00:00Z""
    }
  }

- **Response (Error - e.g., 403 Forbidden):**
  {
    ""type"": ""https://tools.ietf.org/html/rfc7231#section-6.5.3"",
    ""title"": ""Forbidden"",
    ""status"": 403,
    ""detail"": ""Insufficient permissions to rotate API key""
  }

- Consider content-negotiation for versioned responses; use ETag/caching headers if applicable
- PII masking: Do not log full API keys; mask in responses if needed

## Relevant Business Logic

- Rotation invalidates the old key immediately to prevent reuse, enhancing security against key compromise
- Associate new key with the admin user (via user_id in api_keys table); support multi-key per user if needed
- Trigger audit_event for the rotation: { user_id, action: 'api_key_rotated', old_key_id, new_key_id (masked), ip_address }
- Ensure idempotency: If retried, do not generate duplicate keys; use request-id to track
- No state machine needed, but validate key existence and non-expired status before rotation
- Integrate with broader security: Post-rotation, invalidate any active sessions tied to old key if applicable
- Compliance: Align with observability (logs, metrics) and middleware guards (domain guards not directly applicable here)
- Edge cases: Handle if no existing key (generate first), or if rotation fails due to DB constraints (rollback transaction)"
18,auth,Token Introspect,Check token validity and scopes,api/auth/token/introspect,post,Admin,Implement Token Introspect API Endpoint for Deshio Auth,"## Overview

Deshio is a Laravel-based ERP system for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. Order domain handles states (pending→confirmed→fulfilled|cancelled), assignment, notes, promos, taxes, fraud. Fulfillment includes shipments, inter-store dispatch with tracking and POD. Returns via RMA with receive/restock/scrap, refunds, exchanges. Payments manage intent→capture/void, refunds, synchronization. Accounting uses transaction headers + ledger entries for movements, reversals, reconciliation/export. Services cover service/service_order lifecycle and profitability. Integrations include carriers, waybills/rates/tracking, webhooks, notifications. Security & identity: user/role/permission with abilities, multi-role, sessions, email verification, password reset, TOTP MFA + backup codes, API keys. Observability: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines ensure legal transitions for orders, items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data in UTC; soft deletes; EAV for attributes; polymorphic notes/attachments; strict referential links. Design enables deterministic admin assignment, safe reservation/consumption, consistent ledger posting.

This issue covers implementing the Token Introspect API endpoint in the auth category. It checks token validity and scopes, ensuring secure access control within Deshio's RBAC and security framework, integrating with JWT/session/API key auth, user roles/permissions, and middleware like active user checks, 2FA, and RBAC.

## API Specifications

- **Category:** auth
- **Title:** Token Introspect
- **Description:** Check token validity and scopes
- **Route:** api/auth/token/introspect
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint handles POST requests to /api/auth/token/introspect
- [ ] Validates incoming token (e.g., JWT or API key) and returns validity status
- [ ] Extracts and returns token scopes/permissions based on RBAC (user/role/permission with abilities)
- [ ] Integrates with middleware: auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks
- [ ] Returns RFC7807 problem+json for invalid/expired tokens or unauthorized access
- [ ] Logs audit_event for introspection attempts
- [ ] Handles errors like invalid input, rate limiting via throttles, and idempotency
- [ ] Supports versioned content-negotiation and locale/tz
- [ ] Includes request-id and proper cache headers
- [ ] Unit and integration tests cover valid/invalid tokens, scopes, and edge cases (e.g., soft-deleted users)
- [ ] Documentation updated for API specs, including request/response examples
- [ ] Endpoint is secured against replay attacks and includes input sanitizer

## Technical Requirements

- Use Laravel controller (e.g., AuthController@introspect) and define route in api.php with admin middleware group
- Implement input validation (e.g., token as required string in request body) using FormRequest or Validator
- Token validation: Decode JWT or verify API key against user sessions; check expiry, issuer, audience
- Scopes extraction: Map to user permissions via role↔perm and user_role junctions; include user details (id, email, roles) if valid
- Business logic: Ensure introspection only for admin-authenticated requests; tie into security features like TOTP MFA status and branch scope; prevent PII exposure with masking
- Error handling: 401 Unauthorized for invalid tokens, 403 Forbidden for insufficient scopes, 422 Unprocessable for validation errors; use problem+json format
- Request format: JSON body { ""token"": ""eyJ..."" } (or similar for API key); optional params for client_id if OAuth-like
- Response format: JSON { ""active"": true/false, ""scope"": [""read:orders"", ...], ""client_id"": null, ""username"": ""user@example.com"", ""exp"": 1234567890, ""iat"": 1234567890, ""sub"": 1 } for active; { ""active"": false } or error details for inactive
- Integrate with observability: Generate request-id, log events, emit metrics; use queues if async validation needed
- Database interactions: Query users, roles, permissions tables; use Eloquent with soft deletes awareness
- Testing: PHPUnit tests for controller, validation, auth flows; mock middleware and token providers
- Security: Enforce TLS/HSTS, CORS, JSON limits; optional domain guards for auth-related actions
- Performance: Use caching/etag for repeated introspects; ensure idempotency for POST
- Compliance: Align with state machines if transitions involved; support feature flags for endpoint enablement"
19,rbac,List Roles,List Roles,api/roles,get,Admin,Implement List Roles API Endpoint (GET /api/roles),"## Overview

Implement the 'List Roles' API endpoint for the Deshio ERP system's RBAC (Role-Based Access Control) category. This endpoint allows admin users to retrieve a list of all roles in the system. Deshio is a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core RBAC entities include user/role/permission with ability (role↔perm) and user_role (multi-role support). This endpoint supports security and identity management, enabling deterministic admin assignment and RBAC checks. Data is stored in UTC, with soft deletes for archival, and state machines for legality of transitions.

## API Specifications

- **Category:** rbac
- **Title:** List Roles
- **Description:** List Roles
- **Route:** api/roles
- **HTTP Method:** GET
- **Authentication:** Admin

The endpoint should integrate with middleware for TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, throttles, idempotency, input sanitizer, and cache headers. Conflicts should return RFC7807 problem+json.

## Acceptance Criteria

- [ ] Endpoint returns a list of all roles when accessed by an admin user
- [ ] Endpoint requires authentication and authorizes only admin users (e.g., via RBAC permission check)
- [ ] Supports pagination, filtering, and sorting if applicable (e.g., query params for limit, offset, search)
- [ ] Handles unauthenticated or unauthorized requests with appropriate 401/403 errors
- [ ] Includes proper error handling for server issues (500) and validation errors (422)
- [ ] Response includes role details like id, name, permissions, and timestamps
- [ ] Integrates with observability: audit_event logging, request-id tracing, PII masking
- [ ] Tests cover successful listing, auth failures, empty list, and large datasets
- [ ] Documentation updated with OpenAPI spec for this endpoint
- [ ] Endpoint follows Deshio's design for bulk operations, search/autosuggest if extended

## Technical Requirements

- Use Laravel framework: Define route in api.php, create a dedicated Controller (e.g., RoleController@list)
- Implement in RoleController with Eloquent models for Role and related Permission/Ability
- Input validation: Use Laravel's Form Requests for any query parameters (e.g., ?search=, ?per_page=)
- Response formatting: Return JSON with standard structure (e.g., {data: [...], meta: {pagination}} ); use resources for serialization
- Pagination: Default to Laravel's paginate() or LengthAwarePaginator for large role lists
- Soft deletes: Exclude soft-deleted roles unless specified
- Caching: Consider ETag or cache headers for performance, especially with static role data
- Integration with broader system: Ensure compatibility with user_role junctions, multi-role assignments, and polymorphic relations
- Database: Query from roles table with joins to permissions if needed; use strict referential integrity
- State machines: No transitions here, but ensure role data consistency for RBAC enforcement elsewhere

## Authentication/Authorization Requirements

- Authentication: Requires valid JWT, session, or API key via middleware
- Authorization: Admin-only access; check if user has 'admin' role or specific permission (e.g., 'roles.view') using Laravel's Gate or Policy
- Additional checks: Active user, email-verified, 2FA if enabled; branch scope if applicable (though roles are global)
- Security: Rate limiting via throttles; idempotency not applicable for GET; domain guards for RBAC

## Expected Request/Response Format Considerations

- **Request:** GET /api/roles?per_page=15&search=admin&page=1
  - No body; query params for pagination/filtering (optional: search by name/description)
- **Response (200 OK):** 
  {
    ""data"": [
      {
        ""id"": 1,
        ""name"": ""Admin"",
        ""description"": ""Full access role"",
        ""permissions"": [""*""],
        ""created_at"": ""2023-01-01T00:00:00Z"",
        ""updated_at"": ""2023-01-01T00:00:00Z""
      }
    ],
    ""meta"": {
      ""current_page"": 1,
      ""per_page"": 15,
      ""total"": 50
    }
  }
- **Errors:** 401 Unauthorized, 403 Forbidden, 422 Unprocessable (validation), 500 Internal Server Error; all in problem+json format
- Content negotiation: Versioned (e.g., /api/v1/roles), JSON only; caching headers

## Relevant Business Logic

- Roles define permissions for users via multi-role assignments (user_role pivot)
- List should include role attributes like name, slug, description, and associated abilities (role↔perm)
- Supports Deshio's security model: TOTP MFA, API keys, sessions; integrates with audits for role access logs
- Business rules: Prevent listing if user lacks permission; ensure data integrity with UTC timestamps and soft deletes
- Ties into broader ERP: Roles control access to orders, inventory, payments, etc.; enable feature flags and system maintenance
- No stock/financial movements here, but ensures consistent RBAC for ledger postings and state transitions elsewhere
- Reporting: Roles may influence analytics like activity by user/role"
20,rbac,Create Role,Create Role,api/roles,post,Admin,Implement Create Role API Endpoint (POST /api/roles),"## Overview

This GitHub issue is for implementing the 'Create Role' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD that covers catalog, orders, inventory, logistics, payments, RBAC, and audits. This endpoint falls under the RBAC (Role-Based Access Control) category, allowing administrators to create new roles, which are essential for managing user permissions and access control within the system.

## Deshio ERP Context

Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

## API Specifications

- **Category:** rbac
- **Title:** Create Role
- **Description:** Create Role
- **Route:** api/roles
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST /api/roles endpoint to create a new role
- [ ] Ensure the endpoint requires Admin authentication and authorization
- [ ] Validate incoming request data (e.g., role name, permissions) according to business rules
- [ ] Handle successful creation by returning the created role with appropriate HTTP status (201 Created)
- [ ] Implement error handling for invalid inputs, duplicate roles, or unauthorized access using RFC7807 problem+json format
- [ ] Integrate with RBAC models (role, permission, ability) for associating permissions during creation
- [ ] Add unit and integration tests covering happy path, validation errors, auth failures, and edge cases
- [ ] Ensure the endpoint adheres to middleware chain (auth, RBAC checks, input sanitization, etc.)
- [ ] Log audit events for role creation
- [ ] Verify compatibility with soft deletes and UTC storage

## Technical Requirements

- Use Laravel framework: Define the route in api.php, create or update a RolesController with a store method
- Leverage Eloquent models for Role and Permission, with relationships (e.g., role->permissions via ability pivot)
- Implement input validation using Laravel's Form Requests or Validator, enforcing unique role names and valid permission IDs
- Apply middleware: auth (JWT/API key), RBAC permission checks (e.g., 'create-role' permission), throttles, idempotency if applicable
- Handle transactions for atomic creation (role + permission associations)
- Use state machines if role creation involves transitions (though likely not for initial create)
- Ensure response includes ETag for caching, and proper headers (Content-Type: application/json)
- Integrate with observability: Generate request-id, log events, mask PII if any
- Support bulk or advanced features if extensible, but focus on core create
- Follow Deshio's design: Normalized ERD, strict referential integrity, polymorphic relations for notes/attachments on roles if needed

## Authentication/Authorization Requirements

- Authentication: Requires valid JWT, session, or API key
- Authorization: Restricted to Admin users/roles with specific permissions (e.g., 'roles.create')
- Enforce active user, email-verified, and 2FA if enabled via middleware
- Use RBAC checks: Verify user's roles/permissions via user_role and ability tables
- On failure, return 401 Unauthorized or 403 Forbidden with problem+json details

## Expected Request/Response Format Considerations

- **Request Format:** JSON body expected, e.g.:
  {
    ""name"": ""string (required, unique)"",
    ""description"": ""string (optional)"",
    ""permissions"": [""array of permission IDs or slugs""]
  }
  Content-Type: application/json; validation for required fields, data types, and existence of permissions
- **Response Format:** JSON, e.g. on success (201):
  {
    ""data"": {
      ""id"": integer,
      ""name"": string,
      ""description"": string,
      ""permissions"": [array of permission objects],
      ""created_at"": timestamp (UTC)
    }
  }
  On error (e.g., 422 Unprocessable Entity): RFC7807 problem+json, e.g.
  {
    ""type"": ""validation_error"",
    ""title"": ""Invalid Input"",
    ""detail"": ""Role name is required"",
    ""status"": 422,
    ""violations"": [array of field errors]
  }
- Consider versioning via content-negotiation, locale/tz headers
- Idempotency: Optional key in request for safe retries

## Relevant Business Logic

- Role creation must associate with permissions via the ability (role↔perm) junction, supporting multi-role users
- Prevent creation of reserved/system roles (e.g., 'admin', 'superuser') via validation
- Trigger audit_event for creation, including user_id, changes, and request-id
- Ensure consistency with user_role for multi-role assignments post-creation
- No direct impact on other domains (e.g., orders, inventory), but roles control access across all (e.g., via RBAC middleware for branch scope, domain guards)
- Handle conflicts gracefully, e.g., if permission doesn't exist, return validation error
- Align with security features: Sessions, MFA, API keys may influence how roles are used post-creation, but not during create"
21,rbac,Get Role,Get Role,api/roles/{id},get,Admin,Implement GET /api/roles/{id} to Retrieve Role Details,"## Overview

This issue covers the implementation of the 'Get Role' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint retrieves details of a specific role by ID in the RBAC system, supporting multi-role assignments via user_role and role-permission mappings via ability.

## API Specifications

- **Category:** rbac
- **Title:** Get Role
- **Description:** Get Role
- **Route:** api/roles/{id}
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET /api/roles/{id} endpoint to fetch role details by ID
- [ ] Ensure endpoint requires Admin authentication and RBAC permission checks
- [ ] Validate the {id} parameter as a valid role ID (e.g., integer or UUID)
- [ ] Return role data including associated permissions and other relevant fields
- [ ] Handle cases where role ID does not exist (e.g., 404 response)
- [ ] Apply middleware for auth, RBAC checks, request ID, throttling, and error handling per Deshio standards
- [ ] Write unit and integration tests covering success, invalid ID, unauthorized access, and soft-deleted roles
- [ ] Ensure response uses RFC7807 problem+json for errors
- [ ] Document the endpoint in API specs with examples
- [ ] Verify compatibility with soft deletes (exclude deleted roles or handle appropriately)
- [ ] Test for PII masking if role data includes sensitive info

## Technical Requirements

- Use Laravel controller (e.g., RoleController@show) and define route in api.php with {id} parameter
- Implement input validation using Laravel's FormRequest or validator for {id} (required, exists in roles table, not soft-deleted)
- Fetch role using Eloquent model (Role::with('permissions')->findOrFail($id)) to include related permissions via ability pivot
- Apply Deshio middleware stack: auth (JWT/session/API key), active user, RBAC & permission checks (admin role required), branch scope if applicable, throttles, idempotency, input sanitizer
- Handle soft deletes: query should respect withTrashed() if needed, but default to excluding deleted roles
- Use state machine considerations if role transitions apply, though unlikely for retrieval
- Ensure transactional integrity if fetching involves ledger or audit events
- Integrate with observability: log request-id, audit_event for access, metrics for endpoint performance
- Support caching/etag for repeated requests, with cache headers
- Follow data standards: UTC timestamps, strict referential integrity

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have admin role or specific permission to view roles (e.g., 'roles.view')
- Include middleware for email-verified, 2FA if enabled, and active user status
- Reject unauthorized requests with 401/403, using problem+json format
- Support multi-role user assignments; check all user roles for permissions

## Expected Request/Response Format Considerations

- **Request:** GET /api/roles/{id} (no body; {id} as path param, e.g., /api/roles/1)
  - Headers: Authorization (Bearer/JWT), Accept: application/json, X-Request-ID
- **Success Response (200):** JSON object with role details, e.g., {""id"": 1, ""name"": ""Admin"", ""permissions"": [...], ""created_at"": ""UTC timestamp"", ...}
  - Include related data: permissions array from ability table, exclude soft-deleted
  - Use resource classes for transformation if following API standards
- **Error Responses:** 
  - 400: Invalid ID format (validation error)
  - 401: Unauthorized (missing/invalid auth)
  - 403: Forbidden (insufficient permissions)
  - 404: Role not found
  - All errors in RFC7807 problem+json, e.g., {""title"": ""Not Found"", ""detail"": ""Role not found"", ""status"": 404}
- Versioned endpoint (e.g., /v1/api/roles/{id}), content-negotiation for JSON
- Locale/tz handling via headers for any display fields

## Relevant Business Logic

- Roles are core to RBAC: each role links to permissions via ability (role↔perm) table
- Support multi-role per user via user_role junction
- Retrieval should not trigger state changes; use read-only query
- Ensure consistency with audits: log audit_event for role access if sensitive
- Align with security: mask PII if role names/descriptions contain sensitive data
- No bulk operations here; for search/autosuggest, reference other endpoints
- Conflicts (e.g., concurrent updates) handled via ETag/caching, but retrieval is idempotent"
22,rbac,Update Role,Update Role,api/roles/{id},put,Admin,Implement Update Role API Endpoint (PUT /api/roles/{id}),"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This issue covers implementing the 'Update Role' API endpoint in the RBAC category, allowing admins to update role details such as name, description, and associated permissions.

## API Specifications

- **Category:** rbac
- **Title:** Update Role
- **Description:** Update Role
- **Route:** api/roles/{id}
- **HTTP Method:** put
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint responds to PUT requests on /api/roles/{id} with valid admin authentication
- [ ] Successfully updates role attributes (e.g., name, description) and permissions
- [ ] Validates input data, rejecting invalid or unauthorized updates
- [ ] Returns updated role in JSON response on success (HTTP 200)
- [ ] Handles errors appropriately (e.g., 404 for non-existent role, 403 for insufficient permissions, 422 for validation failures) using RFC7807 problem+json
- [ ] Logs audit events for role updates
- [ ] Integrates with state machines if applicable for role state transitions
- [ ] Includes unit and integration tests covering happy path, edge cases, and errors
- [ ] Applies relevant middleware (auth, RBAC checks, input sanitization, throttling)
- [ ] Supports soft deletes and referential integrity for roles linked to users

## Technical Requirements

- Implement in Laravel controller (e.g., RoleController@update) with route in api.php
- Use Eloquent models for Role, Permission, and related entities (user_role junction)
- Apply input validation using Form Requests or Validator facade for fields like name (unique), description, permissions array
- Ensure transactional updates to maintain consistency (e.g., sync permissions via attach/detach)
- Handle soft deletes: prevent updating deleted roles, or restore if needed
- Integrate with observability: generate audit_event, request-id, and log updates
- Use UTC for timestamps; support caching/etag if role data is cached
- Follow middleware stack: auth (JWT/API key), active user, email-verified, 2FA, RBAC (admin permission to update roles), branch scope if applicable, throttles, idempotency
- Polymorphic support for notes/attachments on roles if extended
- Enable bulk operations or search if future-proofing for role management

## Authentication/Authorization Requirements

- Requires admin authentication via JWT, session, or API key
- RBAC check: User must have 'update-role' permission or equivalent admin role
- Enforce multi-role support: Updating a role affects all assigned users
- Include 2FA and email verification checks via middleware
- Reject requests from inactive or unverified users
- Scope to branch/tenancy if roles are organization-specific

## Expected Request/Response Format Considerations

**Request:**
- Headers: Authorization (Bearer/JWT), Content-Type: application/json, Accept: application/json
- Body (JSON): {""name"": ""Updated Role Name"", ""description"": ""Updated description"", ""permissions"": [1, 2, 3]}  // permissions as array of IDs
- Path param: {id} as UUID or integer role ID

**Response:**
- Success (200): {""data"": {""id"": 1, ""name"": ""Updated Role Name"", ""description"": ""..."", ""permissions"": [...]}, ""message"": ""Role updated successfully""}
- Error (e.g., 422): RFC7807 problem+json like {""title"": ""Validation Error"", ""detail"": ""Name is required"", ""status"": 422, ""problems"": [...]}
- Include ETag for caching if applicable; versioned via content-negotiation

## Relevant Business Logic

- Roles manage permissions via role↔perm abilities and user_role multi-role assignments
- Updates must validate against existing roles (e.g., unique name), permissions existence, and prevent circular dependencies
- Trigger audit_event for compliance; sync with user permissions if role is assigned
- Support feature flags for role updates; integrate with reporting for activity analytics
- Ensure deterministic behavior: safe updates without affecting active sessions (or invalidate if critical)
- Conflicts (e.g., concurrent updates) handled via optimistic locking or idempotency keys
- Tie into overall security: updated roles affect access to other domains like orders, inventory, payments"
23,rbac,Delete Role,Delete Role,api/roles/{id},delete,Admin,Implement Delete Role API Endpoint (RBAC),"## Context about Deshio ERP

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.
Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

## Overview

Implement the Delete Role API endpoint in the Deshio ERP system's RBAC category. This endpoint allows administrators to delete a specific role, which is part of the security and identity management. Roles are linked to users and permissions via user_role and ability (role↔perm) relationships. Deletion should use soft deletes for archival purposes, ensuring referential integrity and preventing deletion if the role is actively assigned to users or critical permissions. Handle conflicts with RFC7807 problem+json responses. Integrate with middleware for authentication, RBAC checks, and audit logging.

## API Specifications

- **Category:** rbac
- **Title:** Delete Role
- **Description:** Delete Role
- **Route:** api/roles/{id}
- **HTTP Method:** delete
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint returns 204 No Content on successful deletion of a non-assigned role
- [ ] Endpoint returns 404 if role ID not found
- [ ] Endpoint returns 403 if user lacks admin permissions
- [ ] Soft delete the role record instead of hard delete
- [ ] Prevent deletion or return 409 Conflict if role is assigned to active users
- [ ] Cascade removal of role-permission associations if applicable
- [ ] Log audit_event for the deletion action
- [ ] Validate {id} as a valid UUID or integer
- [ ] Implement idempotency for repeated requests
- [ ] Write unit tests for controller method covering success and error cases
- [ ] Write integration tests verifying middleware and RBAC enforcement
- [ ] Ensure response includes cache headers and request-id

## Technical Requirements

- Use Laravel controller (e.g., RoleController@destroy) and define route in api.php with prefix 'api/roles/{id}'
- Implement input validation for {id} using FormRequest or route model binding with Role model
- Apply soft deletes on the Role model (use HasSoftDeletes trait)
- Integrate with state machine if role has lifecycle states (though not specified, align with overall design)
- Handle exceptions with custom error responses in RFC7807 format for validation, authorization, or business rule violations
- Use Eloquent for database operations, ensuring transactions for integrity
- Add polymorphic notes/attachments if deletion notes are needed
- Ensure strict referential links: check user_role junction before deletion

## Authentication/Authorization Requirements

- Require JWT/session/API key authentication via middleware
- Enforce admin role or specific permission (e.g., 'roles.delete') via RBAC middleware
- Apply active user, email-verified, and 2FA checks if enabled
- Use branch scope if roles are scoped (though RBAC is global)
- Throttle requests and validate idempotency keys if provided

## Expected Request/Response Format Considerations

- **Request:** No body required; path parameter {id} must be valid role identifier (UUID/integer). Headers: Authorization, X-Request-Id, X-Idempotency-Key (optional).
- **Success Response (204):** Empty body, no content.
- **Error Responses:** JSON in RFC7807 problem+json format, e.g., 400 for invalid ID, 403 for unauthorized, 409 for conflict (role in use), 422 for validation errors. Include title, detail, type, and instance.
- Content negotiation: Accept application/json; versioned via header or path.
- Data in UTC; PII masking if role data includes sensitive info.

## Relevant Business Logic

- Roles manage permissions via ability table (role↔perm); deletion should remove associations but preserve audit trails.
- Check user_role assignments: if users are linked, return conflict to prevent orphaning or require explicit unassignment.
- Align with soft deletes policy for archival; deleted roles remain queryable via withTrashed().
- Trigger audit_event on deletion for compliance.
- Ensure no impact on active sessions or ongoing RBAC checks; use cache invalidation if roles are cached.
- Integrate with overall middleware stack: auth, RBAC, throttles, input sanitizer.
- For multi-role users, deletion affects only the specified role without impacting other roles."
24,rbac,List Permissions,List Permissions,api/permissions,get,Admin,Implement List Permissions API Endpoint (RBAC),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue covers the implementation of the 'List Permissions' API endpoint in the RBAC category. This endpoint allows authenticated admins to retrieve a list of all permissions available in the system, supporting core entities like user/role/permission with ability (role↔perm) and user_role (multi-role). Permissions are integral to security & identity features, including RBAC & permission checks in middleware. The design ensures strict referential links across junctions, soft deletes for archival, and state machines for legality of transitions, with conflicts returning RFC7807 problem+json. Data is stored in UTC, with observability via audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers.

## API Specifications

- **Category:** rbac
- **Title:** List Permissions
- **Description:** List Permissions
- **Route:** api/permissions
- **HTTP Method:** GET
- **Authentication:** Admin

This endpoint supports integrations like webhooks with deliveries, notification templates (email/SMS), and reporting/analytics on activity, ensuring deterministic admin assignment and consistent ledger posting on events.

## Acceptance Criteria

- [ ] Implement the GET /api/permissions endpoint in a Laravel controller to list all permissions
- [ ] Ensure the endpoint requires Admin authentication and authorization via RBAC checks
- [ ] Add input validation (though minimal for GET, include query params if needed for filtering/pagination)
- [ ] Handle errors with RFC7807 problem+json format for unauthorized access, internal errors, etc.
- [ ] Write unit and feature tests covering successful listing, auth failures, and edge cases like empty permission list
- [ ] Verify response includes relevant permission fields (e.g., id, name, description) without exposing sensitive data
- [ ] Integrate with middleware for auth, RBAC, request-id, caching/etag, and throttles
- [ ] Ensure compatibility with bulk import/export, search/autosuggest, and system maintenance features
- [ ] Test against soft deletes and EAV for attributes in permissions
- [ ] Confirm audit_event logging for endpoint access

## Technical Requirements

- Use Laravel framework: Define route in api.php, create a dedicated PermissionsController with index() method
- Implement Eloquent models for Permission entity, leveraging relationships to roles/abilities (role↔perm)
- Support pagination (e.g., via query params ?page=1&per_page=50) and optional filtering/sorting
- Use resource classes for JSON responses, ensuring proper serialization
- Input validation: Optional query validation using Form Requests for params like search, sort
- Proper error handling: 401 for unauth, 403 for unauthorized, 500 for server errors, with problem+json
- Database: Query permissions table, respecting soft deletes and UTC storage
- Performance: Use caching/etag, indexes on permission names, and queues if needed for heavy loads
- Security: Enforce Admin role/permission via middleware; PII masking if applicable; idempotency not required for GET
- Testing: PHPUnit tests for controller, middleware integration, and response formats; coverage >80%
- Documentation: Add OpenAPI/Swagger annotations for the endpoint
- Integrations: Align with overall ERD, polymorphic notes/attachments, and feature flags

## Authentication/Authorization Requirements

- Authentication: Requires JWT, session, or API key via middleware
- Authorization: Admin role only, checked via RBAC & permission middleware (e.g., 'view-permissions' permission)
- Additional: Active user, email-verified, 2FA if enabled; branch scope if applicable; domain guards for RBAC actions

## Expected Request/Response Format Considerations

- **Request:** GET /api/permissions?page=1&per_page=50&search=query (optional params for pagination/filtering)
  - Headers: Accept: application/json, Authorization: Bearer <token>, X-Request-ID
- **Response (200 OK):** JSON array of permissions, e.g., {""data"": [{ ""id"": 1, ""name"": ""view-users"", ""description"": ""View user list"", ""guard_name"": ""web"" }], ""meta"": { ""current_page"": 1, ""per_page"": 50 }}
  - Use API resources for consistent formatting; include etag for caching
- **Error Responses:** 401/403/422 with problem+json, e.g., {""title"": ""Unauthorized"", ""status"": 401, ""detail"": ""Admin access required""}
- Content negotiation: Versioned (e.g., /api/v1/permissions), locale/tz aware if needed

## Relevant Business Logic

- Permissions define granular access (e.g., view/edit/delete on entities like products, orders, inventory)
- List should return active permissions only (exclude soft-deleted); support for multi-role users
- Align with core entities: Integrate with user/role/permission model; enable abilities for role↔perm assignments
- Ensure no conflicts with state machines; log audit events for access
- Business rules: Permissions are system-wide, not tenant-scoped unless optional tenancy enabled; support TOTP MFA + backup codes in auth flow
- Reporting: Permissions list can feed into analytics on activity and RBAC usage
- Edge cases: Handle large lists with pagination; empty response as empty array; search/autosuggest on permission names"
25,rbac,Create Permission,Create Permission,api/permissions,post,Admin,Implement Create Permission API Endpoint (POST /api/permissions),"## Overview

Implement the Create Permission API endpoint for the Deshio ERP system's RBAC (Role-Based Access Control) category. This endpoint allows administrators to create new permissions, which are essential for managing user roles and abilities within the system. Permissions link to roles via abilities (role↔perm) and support multi-role assignments for users. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include user/role/permission, with security features like sessions, email verification, password reset, TOTP MFA + backup codes, and API keys. Observability includes audit_event, log, request-id, PII masking, health/metrics, queues, and caching/etag. Middleware encompasses TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, and cache headers. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential links. Design ensures deterministic admin assignment, safe reservation/consumption, and consistent ledger posting.

## API Specifications

- **Category:** rbac
- **Title:** Create Permission
- **Description:** Create Permission
- **Route:** api/permissions
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint responds with 201 Created on successful permission creation
- [ ] Validates required fields (e.g., permission name, description) and returns 422 for invalid input
- [ ] Ensures permission name is unique; returns 409 if duplicate
- [ ] Requires admin authentication and authorization; returns 401/403 for unauthorized access
- [ ] Logs audit events for creation
- [ ] Integrates with RBAC: new permission can be assigned to roles/abilities
- [ ] Handles soft deletes and referential integrity
- [ ] Supports idempotency for repeated requests
- [ ] Returns RFC7807 problem+json for errors (e.g., conflicts in state machines, though not directly applicable here)
- [ ] Includes proper caching/etag headers
- [ ] Unit and integration tests cover happy path, validation errors, auth failures, and edge cases
- [ ] Documentation updated with request/response examples

## Technical Requirements

- Implement in Laravel: Create a dedicated controller (e.g., PermissionController) with a store method
- Define route in api.php: POST /api/permissions with middleware stack (auth, rbac checks, etc.)
- Use Eloquent model for Permission entity, ensuring UTC storage and soft deletes
- Input validation via FormRequest or Validator: require 'name' (unique string), 'description' (optional string), and any EAV attributes
- Business logic: Check for existing permission by name; create with timestamps; trigger audit_event; polymorphic support for notes/attachments if extended
- Error handling: Use Laravel exceptions for 4xx/5xx responses, formatted as problem+json
- Integration: Ensure compatibility with user/role/permission relationships, multi-role support, and permission checks in middleware
- Testing: PHPUnit tests for controller, validation, auth; feature tests for full request flow; cover RBAC denial scenarios
- Observability: Add request-id tracing, log creation events, PII masking if applicable
- Performance: Apply throttles, idempotency keys; optional caching for permission lookups post-creation

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Authorization: User must have admin role or specific 'create-permission' permission checked via RBAC middleware
- Enforce active user, email-verified, and 2FA if enabled
- Branch scope and optional tenancy checks if permission creation is scoped

## Expected Request/Response Format Considerations

- **Request:** JSON body, e.g., {""name"": ""view-orders"", ""description"": ""View order details""}; support EAV attributes if provided
- **Headers:** Authorization (Bearer/JWT), Content-Type: application/json, X-Idempotency-Key (optional)
- **Response (201):** JSON with created permission, e.g., {""id"": 1, ""name"": ""view-orders"", ""description"": ""..."", ""created_at"": ""UTC timestamp""}; include ETag for caching
- **Error Responses:** 400/422 for validation (problem+json with details), 401 Unauthorized, 403 Forbidden, 409 Conflict (duplicate name), 500 Internal with request-id
- Versioned via content-negotiation; locale/tz from headers; sanitize inputs against domain guards

## Relevant Business Logic

- Permissions drive RBAC: Created permissions enable granular control over abilities (e.g., role↔perm mappings)
- Ensure creation doesn't conflict with existing roles/users; support multi-role via user_role junction
- Align with state machines for legality (though creation is straightforward); post-creation, permissions integrate with audits, sessions, and security features like TOTP MFA
- Comply with compliance: Audit all creations, mask PII, support backups/restore and feature flags for RBAC extensions
- Broader context: Ties into reporting (e.g., activity by user/permission), integrations (webhooks on permission changes if extended), and maintenance (reindex for search/autosuggest on permissions)"
26,rbac,Get Permission,Get Permission,api/permissions/{id},get,Admin,Implement Get Permission API Endpoint (RBAC),"## Overview

Deshio is a Laravel-based ERP system for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. Order domain handles states (pending→confirmed→fulfilled|cancelled), assignments, notes/attachments, promos, taxes, fraud flags. Fulfillment includes shipments, inter-store dispatches with tracking and POD. Returns manage RMA, restock/scrap, refunds, exchanges. Payments cover intents, captures/voids, refunds, and order synchronization. Accounting uses transaction headers + ledger entries for movements, reversals, reconciliation/export. Services include service orders with lifecycle and profitability. Integrations handle carriers, waybills/rates/tracking, webhooks, notifications. Security & identity: user/role/permission with abilities (role↔perm), user_role (multi-role), sessions, email verification, password reset, TOTP MFA + backup codes, API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines ensure legal transitions for orders, dispatches, etc., with RFC7807 problem+json for conflicts. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data in UTC; soft deletes; EAV for attributes; polymorphic notes/attachments; strict referential links. Design enables deterministic admin assignment, safe reservation/consumption, consistent ledger posting.

This issue implements the 'Get Permission' endpoint in the RBAC category, allowing admins to retrieve a specific permission by ID. Permissions are part of the RBAC system, linked to roles via abilities (role↔perm), supporting multi-role user assignments.

## API Specifications

- **Category:** rbac
- **Title:** Get Permission
- **Description:** Get Permission
- **Route:** api/permissions/{id}
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint returns the permission details for a valid ID when accessed by an admin
- [ ] Endpoint returns 404 for non-existent permission ID
- [ ] Endpoint enforces admin authentication and RBAC permission checks
- [ ] Response follows JSON API standards with proper structure (e.g., id, name, description, abilities)
- [ ] Handles soft-deleted permissions appropriately (e.g., not returned or flagged)
- [ ] Includes audit logging for the request
- [ ] Integrates with middleware stack (auth, RBAC, request-id, etc.)
- [ ] Unit and integration tests cover success, error cases, and edge cases (e.g., invalid ID)
- [ ] Documentation updated in API specs

## Technical Requirements

- Implement in Laravel: Define route in api.php, create or update PermissionsController with show() method
- Use Eloquent model for Permission with relationships to Role and Ability
- Input validation: Ensure {id} is a valid UUID or integer via route model binding
- Proper error handling: Use RFC7807 problem+json for errors (e.g., 401 Unauthorized, 403 Forbidden, 404 Not Found)
- Response formatting: Return JSON with permission data, including related roles/abilities if applicable; use resource classes for transformation
- Pagination or includes not required for single GET, but support ?include=roles if needed
- Ensure UTC handling and soft delete awareness

## Authentication/Authorization Requirements

- Requires admin authentication via JWT/session/API key
- Middleware chain: auth, active user, email-verified, 2FA (if enabled), RBAC & permission checks (e.g., user must have 'view_permissions' permission)
- Branch scope and optional tenancy if applicable
- Throttling and idempotency for repeated requests

## Expected Request/Response Format Considerations

- **Request:** GET /api/permissions/{id} (path param {id} required; optional query params like ?include=roles for eager loading)
- **Response (200 OK):** {
  ""data"": {
    ""id"": ""uuid"",
    ""name"": ""string"",
    ""description"": ""string"",
    ""abilities"": [...] // or included via relationships
  }
}
- **Error Responses:** 401/403/404 with problem+json: {
  ""title"": ""string"",
  ""detail"": ""string"",
  ""status"": 404,
  ""type"": ""uri""
}
- Content negotiation: JSON only, versioned if applicable; cache headers (ETag)
- Request ID in headers for tracing

## Relevant Business Logic

- Permissions define granular access (e.g., view/edit/delete on entities like orders, inventory)
- Linked to roles via ability table (role_id ↔ perm_id); users inherit via user_role junctions
- State machines not directly applicable, but ensure RBAC checks prevent unauthorized access
- Audit event logged on retrieval for compliance
- Integrates with broader security: PII masking if permission data includes sensitive info (unlikely), replay defense not needed for GET
- Supports feature flags for endpoint enablement if required"
27,rbac,Update Permission,Update Permission,api/permissions/{id},put,Admin,Implement Update Permission API Endpoint (RBAC),"## Overview

This GitHub issue is for implementing the 'Update Permission' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment covers shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns handle RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments manage intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting includes transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services cover service/service_order with lifecycle and profitability. Integrations include carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint specifically handles updating permissions in the RBAC system, allowing administrators to modify permission details such as name, description, or associated abilities.

## API Specifications

- **Category:** rbac
- **Title:** Update Permission
- **Description:** Update Permission
- **Route:** api/permissions/{id}
- **HTTP Method:** put
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the PUT /api/permissions/{id} endpoint in the Laravel controller
- [ ] Ensure the endpoint updates the permission entity with provided data
- [ ] Add input validation for request body fields (e.g., name, description, abilities)
- [ ] Verify that only authenticated admins with appropriate RBAC permissions can access the endpoint
- [ ] Handle soft deletes and archival considerations for permissions
- [ ] Implement proper error handling using RFC7807 problem+json for conflicts or invalid states
- [ ] Write unit and integration tests covering success, validation errors, unauthorized access, and non-existent permission IDs
- [ ] Ensure the endpoint respects middleware stack including auth (JWT/session/API key), RBAC & permission checks, and throttles
- [ ] Confirm audit_event logging for the update action
- [ ] Test integration with related entities like roles and abilities (role↔perm)
- [ ] Validate that data remains in UTC and maintains referential integrity

## Technical Requirements

- Use Laravel framework for controller, routes, and Eloquent models (permission model with fields like id, name, description, guard_name, etc.)
- Define routes in api.php with resource routing where applicable, ensuring versioned content-negotiation
- Implement input validation using Laravel's Form Requests or Validator, sanitizing inputs per middleware plan
- Handle permission updates atomically, considering state machines if transitions apply (though permissions may not have states)
- Integrate with RBAC: Update permission should allow modifying abilities linked to roles, ensuring multi-role user_role consistency
- Support polymorphic relations if permissions link to notes/attachments
- Use EAV for any extensible attributes on permissions if needed
- Ensure idempotency for repeated updates via middleware
- Add caching/etag support and proper cache headers
- Log the update in audit_event and request-id for observability
- Handle PII masking if permission data includes sensitive info
- Consider bulk operations compatibility, though this is single update

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce active user, email-verified, and 2FA (TOTP MFA + backup codes) checks via middleware
- RBAC & permission checks: User must have a role with 'update-permissions' permission or equivalent ability
- Branch scope and optional tenancy if permissions are scoped (e.g., per-branch permissions)
- Reject unauthorized requests with 403 Forbidden, using problem+json format

## Expected Request/Response Format Considerations

- **Request:** JSON body with fields like {""name"": ""string"", ""description"": ""string"", ""abilities"": [""array of strings""]}; path param {id} as UUID or integer
- Validate required/optional fields, max lengths, and unique constraints (e.g., permission name uniqueness)
- Support JSON limits and input sanitizer middleware
- **Response:** On success, 200 OK with updated permission JSON (including id, name, description, guard_name, created_at, updated_at); use ETag for caching
- Errors: 400 Bad Request for validation failures, 404 Not Found for invalid ID, 403 Forbidden for auth issues, 422 Unprocessable Entity for business rule violations; all in RFC7807 problem+json
- Ensure responses include request-id header and are in UTC

## Relevant Business Logic

- Permissions are core to RBAC: Updating a permission should not break existing role↔perm associations; validate that changes don't conflict with active roles or users
- If permission is soft-deleted, handle restoration or prevent updates on deleted entities
- Trigger any necessary reindex or cache invalidation for permission-related searches/autosuggest
- Ensure consistency with user_role multi-role assignments; updates should propagate safely without affecting sessions
- Align with overall design: Deterministic updates, strict referential links, and ledger posting if financial/audit implications (though unlikely for permissions)
- Conflicts (e.g., concurrent updates) should use optimistic locking or return problem+json"
28,rbac,Delete Permission,Delete Permission,api/permissions/{id},delete,Admin,Implement Delete Permission API Endpoint (RBAC),"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint allows administrators to delete a specific permission in the RBAC system, ensuring secure management of user roles and abilities.

## API Specifications

- **Category:** rbac
- **Title:** Delete Permission
- **Description:** Delete Permission
- **Route:** api/permissions/{id}
- **HTTP Method:** delete
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the DELETE endpoint for deleting a permission by ID
- [ ] Ensure only authenticated admins can access the endpoint
- [ ] Validate that the permission ID exists and is not in use before deletion
- [ ] Handle soft deletes for the permission entity
- [ ] Return appropriate HTTP status codes: 204 on success, 404 if not found, 403 if unauthorized
- [ ] Log the deletion event in audit_event for compliance
- [ ] Write unit and integration tests covering success, failure, and edge cases
- [ ] Ensure integration with RBAC middleware for permission checks
- [ ] Verify no cascading effects on roles or users without explicit handling

## Technical Requirements

- Use Laravel controller (e.g., PermissionController) and define route in api.php with {id} parameter
- Implement input validation for the {id} parameter (must be a valid UUID or integer)
- Apply soft deletes on the permission model; use forceDelete if permanent deletion is required (per business rules)
- Integrate with Laravel's Eloquent for querying and deleting the permission
- Handle referential integrity: check if permission is assigned to any roles; if so, prevent deletion or unassign first
- Use state machines if applicable for permission lifecycle, but deletion is terminal
- Ensure all data operations are in UTC
- Add middleware stack: auth, RBAC checks (admin permission required, e.g., 'delete-permissions'), throttles, idempotency

## Authentication/Authorization Requirements

- Requires JWT/session/API key authentication
- User must be active, email-verified, and have 2FA if enabled
- RBAC: User must have admin role or specific 'permissions.delete' permission
- Branch scope and tenancy optional, but apply if multi-tenant setup
- Reject unauthorized requests with 403 and RFC7807 problem+json

## Expected Request/Response Format Considerations

- **Request:** No body required; path parameter {id} for permission ID (e.g., DELETE /api/permissions/123)
- Headers: Authorization, Accept: application/json, Content-Type: application/json
- **Response:** 
  - Success: 204 No Content
  - Error: 404 Not Found ({""type"": ""https://tools.ietf.org/html/rfc7231#section-6.5.4"", ""title"": ""Permission not found"", ""status"": 404})
  - Unauthorized: 401/403 with problem+json
- Use versioned content-negotiation; cache headers (no-cache for mutations)
- Idempotency: Support idempotent keys if re-submission possible

## Relevant Business Logic

- Permissions are part of RBAC with user/role/permission entities and role↔perm abilities
- Deletion should audit the event with request-id and user context
- Prevent deletion of system/reserved permissions (e.g., core admin perms)
- If permission is linked to roles, business rules may require unlinking or blocking deletion to maintain referential integrity
- Post-deletion, invalidate any related caches (e.g., permission lists)
- Ensure consistency with multi-role user assignments; no automatic role updates
- Comply with PII masking if permission involves sensitive data, though unlikely for perms
- Integrate with observability: log to audit_event, metrics for deletion rate"
29,rbac,Grant Permission to Role,Assign permission to role,api/roles/{role_id}/permissions,post,Admin,Implement API: Grant Permission to Role (POST /roles/{role_id}/permissions),"## Overview

This GitHub issue is for implementing the 'Grant Permission to Role' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs built over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes (fields/features), media (product images), barcodes, pricing (price overrides), promotions; stores/branches; customers with tags/blacklists.

Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending → confirmed → fulfilled|cancelled), assignment to stores, notes/attachments, promotions, taxes, and fraud flags. Fulfillment handles shipments (shipment/shipment_item) and inter-store dispatches (dispatch + tracking, scan events, POD) with transactional stock movements. Returns manage RMAs (return/return_item), receiving/restocking/scrap, refunds, and exchanges (exchange_order).

Payments cover intent → payment capture/void; refund lifecycles; and order.payment_status synchronization. Accounting uses transaction headers + ledger_entry lines for all movements, reversals, and reconciliation/export. Services include service/service_order with lifecycles and profitability. Integrations encompass carriers & accounts, waybills/rates/tracking; webhooks with deliveries; and notification templates (email/SMS).

Security & identity features user/role/permission with ability (role ↔ perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance include audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plans cover TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics provide revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines ensure legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint specifically handles RBAC by assigning a permission to a role via the role_permission pivot table, enabling multi-role user assignments and granular access control.

## API Specifications

- **Category:** rbac
- **Title:** Grant Permission to Role
- **Description:** Assign permission to role
- **Route:** api/roles/{role_id}/permissions
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST endpoint to assign a permission to the specified role
- [ ] Validate input parameters, including role_id existence and permission_id validity
- [ ] Ensure the assignment is stored in the role_permission pivot table without duplicates
- [ ] Return a 201 Created response on success with the updated role details or confirmation
- [ ] Handle errors appropriately, such as 404 for non-existent role, 409 for duplicate assignment, using RFC7807 problem+json format
- [ ] Apply RBAC checks to ensure only admins can grant permissions
- [ ] Include audit logging for the permission grant event
- [ ] Write unit and integration tests covering success, failure, validation, and authorization scenarios
- [ ] Ensure endpoint respects middleware like throttling, idempotency, and input sanitization
- [ ] Verify compatibility with soft deletes and UTC storage

## Technical Requirements

- Use Laravel framework: Define the route in api.php, create or update a RolesController with a grantPermission method
- Leverage Eloquent models: Role and Permission with a many-to-many relationship via role_permission pivot table
- Implement input validation using Form Requests or Validator facade, e.g., require 'permission_id' as integer and ensure it exists
- Handle business logic in the controller or a dedicated service class to attach the permission to the role (e.g., $role->permissions()->attach($permissionId))
- Integrate with state machines if role/permission states evolve (though not specified, ensure transition legality)
- Add proper error handling with exceptions mapped to JSON responses
- Ensure transactional integrity for the database operation
- Follow Deshio's observability: Generate audit_event, use request-id, and log the action
- Support polymorphic relations if notes/attachments are needed for audit trails

## Authentication and Authorization Requirements

- Require Admin authentication: Use JWT/session/API key middleware
- Enforce RBAC: The requesting user must have a specific permission (e.g., 'roles.manage' or 'permissions.grant') via ability checks
- Include middleware chain: auth, active user, email-verified, 2FA, RBAC & permission checks
- Handle unauthorized access with 401/403 responses in problem+json format
- Consider branch scope or tenancy if applicable, though RBAC is system-wide

## Expected Request/Response Format Considerations

- **Request Body:** JSON object, e.g., {""permission_id"": 123} – Validate permission_id as required integer referencing an existing Permission
- **Path Parameter:** {role_id} as UUID or integer ID of an existing Role
- **Response on Success (201 Created):** JSON with updated role object including permissions array, e.g., {""role"": {""id"": 1, ""name"": ""Admin"", ""permissions"": [{""id"": 123, ""name"": ""users.view""}]}} or simple {""message"": ""Permission granted successfully"", ""role_id"": 1, ""permission_id"": 123}
- **Error Responses:** Use RFC7807 problem+json, e.g., 400 for validation errors {""type"": ""https://example.com/probs/validation"", ""title"": ""Invalid Input"", ""detail"": ""Permission ID is required""}, 404 {""type"": ""https://example.com/probs/not-found"", ""title"": ""Role Not Found""}
- Support content-negotiation for versioned API, caching/etag headers
- Ensure PII masking if any user data is involved indirectly

## Relevant Business Logic

- Prevent duplicate assignments: Check if the permission is already attached to the role before attaching
- Maintain referential integrity: Ensure role and permission exist; use soft deletes awareness (e.g., withTrashed if needed)
- Trigger audit_event on successful grant for compliance and observability
- Synchronize with user_role: No direct impact, but role changes affect user permissions via multi-role assignments
- Align with security model: Abilities (role ↔ perm) define granular access; this endpoint updates the pivot for role-permission links
- Handle conflicts via state machines if permission grants have states (e.g., pending approval, though not specified)
- Ensure idempotency: Use unique keys or checks to allow safe retries
- Post-grant, invalidate relevant caches for permissions to ensure real-time updates in sessions or API responses"
30,rbac,Revoke Permission from Role,Remove permission from role,api/roles/{role_id}/permissions/{permission_id},delete,Admin,Implement DELETE /api/roles/{role_id}/permissions/{permission_id} for RBAC,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue covers the implementation of the 'Revoke Permission from Role' API endpoint in the RBAC category. Deshio's core entities include product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. Order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment covers shipments and inter-store dispatch with tracking and transactional stock movements. Returns handle RMA, receive/restock/scrap, refunds, exchanges. Payments include intent→payment capture/void, refund lifecycle, order.payment_status synchronization. Accounting features transaction headers + ledger_entry lines for movements, reversals, reconciliation/export. Services include service/service_order with lifecycle and profitability. Integrations cover carriers, waybills/rates/tracking, webhooks, notification templates. Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, consistent ledger posting on every stock/financial event.

This endpoint removes a permission from a specified role, supporting Deshio's RBAC system to manage user/role/permission associations via pivot tables (role↔perm).

## API Specifications

- **Category:** rbac
- **Title:** Revoke Permission from Role
- **Description:** Remove permission from role
- **Route:** api/roles/{role_id}/permissions/{permission_id}
- **HTTP Method:** DELETE
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint revokes the specified permission from the role successfully when authenticated as admin
- [ ] Returns 204 No Content on success
- [ ] Returns 404 if role or permission not found
- [ ] Returns 403 if user lacks admin privileges
- [ ] Validates {role_id} and {permission_id} as valid UUIDs or integers
- [ ] Handles soft deletes appropriately (e.g., does not revoke from archived roles)
- [ ] Logs audit_event for the revocation action
- [ ] Integrates with RBAC middleware for permission checks
- [ ] Includes unit and integration tests covering success, error cases, and edge cases (e.g., role with no permissions, non-existent IDs)
- [ ] Ensures no direct database mutations without transactions
- [ ] Complies with RFC7807 for error responses (problem+json)

## Technical Requirements

- Implement in Laravel controller (e.g., RolePermissionController) with route registration in api.php
- Use Eloquent models for Role and Permission with a many-to-many relationship via pivot table (role_permission)
- Apply input validation using Form Requests or controller validation for route parameters
- Handle errors with proper HTTP status codes and JSON responses
- Integrate with existing middleware stack: auth (JWT/session/API key), RBAC & permission checks
- Ensure idempotency for repeated DELETE requests
- Add caching/etag considerations if role permissions are cached
- Use request-id for observability and log the action in audit_event
- Support versioned content-negotiation and locale/tz if applicable
- Write comprehensive tests using PHPUnit, including mocking auth and database

## Authentication/Authorization Requirements

- Requires Admin authentication (JWT, session, or API key)
- Enforce RBAC: Caller must have permission to manage roles (e.g., 'roles.manage')
- Apply active user, email-verified, and 2FA checks via middleware
- Branch scope and optional tenancy if roles are scoped
- Reject if not admin, returning 403 Forbidden

## Expected Request/Response Format Considerations

- **Request:** No body required; path parameters {role_id} and {permission_id} (UUID/integer)
- **Headers:** Authorization (Bearer/JWT), Accept: application/json, Content-Type: application/json
- **Success Response (204):** Empty body, no content
- **Error Responses:**
  - 400 Bad Request: Invalid parameters (validation fails)
  - 403 Forbidden: Insufficient permissions
  - 404 Not Found: Role or permission does not exist
  - 422 Unprocessable Entity: Semantic validation errors
  - All errors in problem+json format per RFC7807, with request-id
- Data in UTC; no PII exposure

## Relevant Business Logic

- Detach the permission from the role using Eloquent's detach() on the relationship
- Prevent revocation if it would violate referential integrity (e.g., if permission is required for role)
- Trigger any state machine transitions if applicable (though unlikely for RBAC)
- Post to audit_event log with details: user_id, role_id, permission_id, action='revoke'
- Ensure consistency with multi-role support (user_role); revocation affects all users with that role
- Handle soft deletes: Skip if role/permission is soft-deleted, or restore if needed
- No financial/stock impact, but ensure transactional integrity for the pivot update
- Integrate with feature flags if RBAC changes are gated"
31,rbac,List Role Permissions,Permissions under a role,api/roles/{role_id}/permissions,get,Admin,Implement API: List Role Permissions (GET /api/roles/{role_id}/permissions),"## Overview

This issue covers the implementation of the 'List Role Permissions' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD that spans catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment involves shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns handle RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments manage intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting uses transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services include service/service_order with lifecycle and profitability. Integrations cover carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint specifically retrieves permissions associated with a given role in the RBAC system, supporting multi-role assignments and permission checks.

## API Specifications

- **Category:** rbac
- **Title:** List Role Permissions
- **Description:** Permissions under a role
- **Route:** api/roles/{role_id}/permissions
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET endpoint to retrieve a list of permissions for the specified role ID
- [ ] Ensure the endpoint requires Admin authentication and returns 401/403 for unauthorized access
- [ ] Validate that {role_id} exists; return 404 if role not found
- [ ] Return a JSON array of permissions associated with the role, including relevant fields like permission ID, name, and description
- [ ] Handle errors per RFC7807 problem+json format for conflicts or invalid states
- [ ] Include proper middleware: auth (JWT/session/API key), RBAC & permission checks, branch scope (if applicable), throttles, input sanitizer
- [ ] Add unit and integration tests for success, unauthorized, not found, and error scenarios
- [ ] Ensure response includes ETag for caching and proper cache headers
- [ ] Log audit_event for access to role permissions
- [ ] Support soft deletes; exclude deleted roles/permissions
- [ ] Test integration with user_role multi-role capabilities

## Technical Requirements

- Use Laravel framework: Define route in api.php, create or extend RolesController with permissions() method
- Query the ability (role↔permission) pivot table to fetch associated permissions for the given role_id
- Implement input validation for {role_id} as a valid UUID or integer via Route Model Binding
- Proper error handling: Use Laravel exceptions for 404 (ModelNotFoundException), 403 (AuthorizationException)
- Response format: JSON array of permission objects, e.g., [{ ""id"": 1, ""name"": ""edit-products"", ""description"": ""Edit product details"" }]; paginate if large sets expected
- Business logic: Fetch permissions via Eloquent relationships (e.g., Role::findOrFail($role_id)->permissions); respect RBAC hierarchy if roles inherit permissions
- Authentication/Authorization: Middleware stack includes admin role check; verify user has permission to view role permissions (e.g., 'view-roles')
- Expected request: No body; query params optional for filtering/sorting (e.g., ?include=description)
- Expected response: 200 OK with JSON list; 4xx/5xx as per standards; include request-id header
- Integrate with observability: Add metrics for endpoint usage, PII masking if permissions contain sensitive data
- Ensure UTC handling and locale/tz middleware if descriptions are localized
- Align with overall API design: Versioned endpoint, content-negotiation, idempotency if applicable"
32,rbac,Assign Role to User,Attach role to user,api/users/{user_id}/roles,post,Admin,Implement API: Assign Role to User (POST /api/users/{user_id}/roles),"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint handles attaching a role to a user in the RBAC system, supporting multi-role assignments via the user_role junction table.

## API Specifications

- **Category:** rbac
- **Title:** Assign Role to User
- **Description:** Attach role to user
- **Route:** api/users/{user_id}/roles
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST endpoint to attach a role to the specified user
- [ ] Validate that the user exists and is not soft-deleted
- [ ] Validate that the role exists and is active
- [ ] Prevent duplicate role assignments for the same user-role pair
- [ ] Handle multi-role support via user_role junction
- [ ] Log audit_event for the role assignment
- [ ] Return RFC7807 problem+json for validation errors or conflicts
- [ ] Add unit and integration tests covering success, failure, and edge cases (e.g., non-existent user/role, duplicates)
- [ ] Ensure endpoint respects middleware stack including auth, RBAC checks, and request sanitization
- [ ] Verify response includes updated user roles or success confirmation

## Technical Requirements

- Use Laravel controller (e.g., UserRoleController) and define route in api.php with resource naming
- Implement input validation using Laravel Form Requests (e.g., validate role_id as required integer referencing roles table)
- Use Eloquent models for User and Role with a many-to-many relationship via user_role pivot table
- Attach role using $user->roles()->attach($roleId) or sync if needed, handling transactions for consistency
- Apply soft deletes awareness; query withUser() or similar scopes
- Integrate with state machines if role assignment affects permissions or user state
- Add proper error handling: 404 for non-existent user/role, 409 for duplicates, 403 for insufficient permissions
- Ensure data integrity with strict referential links; store timestamps in UTC
- Consider idempotency for repeated requests
- Include caching/etag if role list is frequently queried post-assignment

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: Caller must have permission to manage user roles (e.g., 'users.manage-roles')
- Apply active user, email-verified, and 2FA middleware
- Include branch scope if applicable (though RBAC is system-wide)
- Use permission checks via Laravel's Gate or Policy classes for 'attach-role' ability

## Expected Request/Response Format Considerations

- **Request Body:** JSON with { ""role_id"": integer } – role_id must reference an existing role
- **Query Params:** None specified; optional includes for expanded response (e.g., ?include=roles)
- **Response (Success 201):** JSON { ""message"": ""Role assigned successfully"", ""data"": { ""user_id"": int, ""role_id"": int } } or updated user object with roles
- **Response (Error):** RFC7807 problem+json, e.g., { ""type"": ""https://example.com/probs/validation"", ""title"": ""Invalid Input"", ""status"": 422, ""detail"": ""Role does not exist"", ""source"": { ""pointer"": ""/role_id"" } }
- Support versioned content-negotiation (e.g., Accept: application/vnd.deshio.v1+json)
- Include request-id header in responses
- Handle PII masking if user details are returned

## Relevant Business Logic

- Role assignment enables multi-role support for users, affecting permissions via role↔perm abilities
- Trigger audit_event with details like assigner user_id, target user_id, role_id, and timestamp
- Ensure consistency with user lifecycle: assignments persist through soft deletes but respect active status
- Integrate with observability: log the event, metrics for RBAC operations
- Conflicts (e.g., assigning restricted role) should use state machine validation if extended to RBAC transitions
- Post-assignment, user permissions are dynamically recomputed based on all attached roles
- Align with security features like TOTP MFA and API keys for admin access"
33,rbac,Remove Role from User,Detach role from user,api/users/{user_id}/roles/{role_id},delete,Admin,Implement DELETE api/users/{user_id}/roles/{role_id} for RBAC,"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint handles detaching a role from a user in the RBAC system, removing the association from the user_role junction table while supporting multi-role assignments.

## API Specifications

- **Category:** rbac
- **Title:** Remove Role from User
- **Description:** Detach role from user
- **Route:** api/users/{user_id}/roles/{role_id}
- **HTTP Method:** delete
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the DELETE endpoint to detach the specified role from the user
- [ ] Validate that the user and role exist before attempting detachment
- [ ] Ensure the detachment does not delete the role or user, only the association
- [ ] Handle cases where the role is not assigned to the user (e.g., return 404 or 204)
- [ ] Add unit and integration tests for success, failure, and edge cases
- [ ] Verify audit logging for the role detachment event
- [ ] Test RBAC permission checks to ensure only admins can perform this action
- [ ] Confirm compliance with middleware stack including auth, RBAC checks, and error handling
- [ ] Ensure response follows RFC7807 for errors

## Technical Requirements

- Use Laravel controller (e.g., UserRoleController) and define the route in api.php
- Implement input validation for {user_id} and {role_id} as required integers
- Leverage Eloquent models for User and Role, detaching via user->roles()->detach($role_id)
- Apply soft deletes if applicable, but ensure archival compliance
- Integrate with state machines if role changes trigger transitions (though unlikely for detachment)
- Use transactional database operations to ensure consistency in user_role junction
- Add proper error handling: 404 for non-existent user/role, 403 for unauthorized access
- Include observability: log the event in audit_event table with request-id
- Follow Deshio's data standards: UTC timestamps, PII masking if user data is logged

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: Caller must have 'admin' role or specific permission (e.g., 'users.manage-roles')
- Apply middleware: auth, active user, email-verified, 2FA, RBAC & permission checks
- Support multi-role users; detachment should not affect other roles
- Include branch scope if applicable, though RBAC is likely global

## Expected Request/Response Format Considerations

- **Request:** No body required; path parameters {user_id} and {role_id} as integers
- **Success Response:** 204 No Content on successful detachment
- **Error Responses:** 
  - 401 Unauthorized if not authenticated
  - 403 Forbidden if not admin/authorized
  - 404 Not Found if user or role does not exist or role not assigned
  - 422 Unprocessable Entity for validation errors (e.g., invalid IDs)
- Use JSON for errors per RFC7807 problem+json format
- Set cache headers and etag if caching is applicable (likely not for mutations)
- Ensure idempotency support via middleware

## Relevant Business Logic

- Detachment removes the role from the user's active roles, revoking associated permissions immediately
- Support multi-role: User can retain other roles; check for remaining roles post-detachment
- Trigger audit_event for compliance, logging who detached what role from whom
- Prevent detachment if it would leave the user without required roles (e.g., if system mandates at least one role—business rule to confirm)
- Integrate with sessions: Invalidate or refresh user session if online to reflect permission changes
- Ensure referential integrity: No cascading deletes; only junction record affected
- Align with Deshio's security model: Post-detachment, user permissions are re-evaluated on next request via RBAC checks"
34,rbac,List User Roles,Roles assigned to a user,api/users/{user_id}/roles,get,Admin,Implement API: List User Roles (GET /api/users/{user_id}/roles),"## Overview

This GitHub issue is for implementing the 'List User Roles' API endpoint in the Deshio ERP system. This endpoint retrieves the roles assigned to a specific user, as part of the RBAC (Role-Based Access Control) category. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.

Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint supports multi-role assignments via the user_role junction table.

## API Specifications

- **Category:** rbac
- **Title:** List User Roles
- **Description:** Roles assigned to a user
- **Route:** api/users/{user_id}/roles
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET endpoint to retrieve roles for a given user ID
- [ ] Ensure the endpoint requires admin authentication and authorization
- [ ] Validate the {user_id} parameter as a valid integer or UUID
- [ ] Return a JSON array of role objects with relevant fields (e.g., id, name, permissions)
- [ ] Handle cases where no roles are assigned (empty array)
- [ ] Include proper HTTP status codes: 200 for success, 401/403 for auth issues, 404 for invalid user
- [ ] Add unit and integration tests covering success, error cases, and edge scenarios
- [ ] Ensure compliance with middleware stack (e.g., RBAC checks, request ID, caching)
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger)
- [ ] Log audit events for access to user roles

## Technical Requirements

- Use Laravel framework: Define route in api.php, create or extend a controller (e.g., UserRoleController)
- Leverage Eloquent models: User, Role, and user_role pivot table for querying assigned roles
- Implement input validation using Form Requests or controller validation (e.g., user_id exists and is integer)
- Proper error handling: Use RFC7807 problem+json for conflicts/errors, integrate with exception handler
- Response formatting: Paginated if needed, but default to simple list; include ETag for caching
- Integration with observability: Add request-id tracing, audit_event logging for RBAC access
- Follow Deshio conventions: UTC timestamps, soft deletes awareness, strict referential integrity

## Authentication/Authorization Requirements

- Authentication: Requires admin-level JWT, session, or API key
- Authorization: Caller must have admin role or specific permission to view user roles (e.g., 'view-user-roles')
- Middleware: Apply auth, active user, RBAC & permission checks; optional 2FA if enabled
- Scope: Admin-only access; prevent users from viewing their own or others' roles without permission

## Expected Request/Response Format Considerations

- **Request:** GET /api/users/{user_id}/roles
  - Path param: user_id (required, integer/UUID of existing user)
  - Query params: Optional filters like ?include=permissions or pagination (page, limit)
  - Headers: Authorization, Accept: application/json, X-Request-ID

- **Response (200 OK):**
  ```json
  {
    ""data"": [
      {
        ""id"": 1,
        ""name"": ""admin"",
        ""slug"": ""admin"",
        ""permissions"": [""create-user"", ""view-order""],
        ""pivot"": {
          ""user_id"": 123,
          ""role_id"": 1
        }
      }
    ],
    ""meta"": {
      ""total"": 1,
      ""per_page"": 15
    }
  }
  ```

- **Error Responses:**
  - 401 Unauthorized: Missing/invalid auth
  - 403 Forbidden: Insufficient permissions
  - 404 Not Found: User not found
  - 422 Unprocessable: Invalid user_id format
  - Body: RFC7807 problem+json, e.g., {""type"": ""https://example.com/errors/user-not-found"", ""title"": ""User not found"", ""status"": 404}

## Relevant Business Logic

- Retrieve roles via user's many-to-many relationship (User::roles())
- Include associated permissions if requested (eager load)
- Respect soft deletes: Exclude deleted users/roles
- Ensure data privacy: Mask PII if applicable, though roles are non-PII
- Idempotency: Safe GET, no side effects; support caching with ETag/Last-Modified
- Auditing: Log audit_event for admin viewing user roles, including request-id
- State/Consistency: Roles can be multi-assigned; no state machine here, but ensure referential integrity with user_role table
- Edge Cases: Handle user with no roles, deleted roles (via soft delete), large role sets (pagination)
- Integration: Align with broader RBAC system for permissions and abilities (role↔perm)"
35,rbac,Check Permission,Check if user has permission,api/rbac/check,post,Admin,Implement RBAC Check Permission API Endpoint,"## Overview

This GitHub issue is for implementing the 'Check Permission' API endpoint in the Deshio ERP system's RBAC (Role-Based Access Control) category. Deshio is a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include user/role/permission with ability (role↔perm) and user_role (multi-role), supporting sessions, email verification, password reset, TOTP MFA + backup codes, and API keys. This endpoint allows checking if a user has a specific permission, enabling fine-grained access control across the system. Middleware includes auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, and domain guards. State machines drive legality of transitions, with conflicts returning RFC7807 problem+json. Data is stored in UTC, with soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential links.

## API Specifications

- **Category:** rbac
- **Title:** Check Permission
- **Description:** Check if user has permission
- **Route:** api/rbac/check
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST /api/rbac/check endpoint in Laravel
- [ ] Add request validation for permission identifier
- [ ] Verify authentication and admin role requirement
- [ ] Integrate RBAC logic to check user permissions via roles
- [ ] Handle successful response with boolean has_permission flag
- [ ] Implement error handling for unauthorized access or invalid permissions (RFC7807 problem+json)
- [ ] Write unit and integration tests for various user scenarios (e.g., admin, regular user with/without permission)
- [ ] Ensure endpoint respects middleware stack (auth, RBAC checks, throttles, input sanitizer)
- [ ] Document request/response formats in API specs
- [ ] Test for idempotency and proper caching/etag if applicable
- [ ] Verify soft deletes and UTC handling in related queries

## Technical Requirements

- Use Laravel controller (e.g., RbacController) and define route in api.php with POST method
- Implement input validation using Form Requests or Validator for required fields like permission name (e.g., 'orders.create')
- Query user roles and permissions using Eloquent relationships (user->roles->permissions)
- Support multi-role checks: user has permission if any assigned role grants it
- Include observability: log audit_event for permission checks, request-id tracing, PII masking
- Error handling: Return 401/403 for auth/RBAC failures, 422 for validation errors, using standardized JSON responses
- Integrate with broader system: Ensure compatibility with feature flags, queues, and system maintenance APIs
- Follow design principles: Deterministic checks, safe reservation/consumption analogies for access, consistent ledger posting if audited
- Bulk/search considerations: While this is single-check, design for potential future bulk permission checks

## Authentication/Authorization Requirements

- Requires Admin authentication (JWT/session/API key)
- Enforce active user, email-verified, and 2FA via middleware
- RBAC check: Only admin users (or roles with 'rbac.check' permission) can invoke this endpoint
- Branch scope and optional tenancy must be respected if applicable
- Provider webhook signatures + replay defense not directly relevant but ensure idempotency keys if extended

## Expected Request/Response Format Considerations

- **Request Body (JSON):** {""permission"": ""string""} – e.g., {""permission"": ""orders.view""} (required, validated as dotted notation for hierarchical perms)
- **Headers:** Authorization (Bearer/JWT), Content-Type: application/json, Accept: application/json, X-Request-ID
- **Success Response (200):** {""has_permission"": true} or {""has_permission"": false}
- **Error Response (4xx/5xx):** RFC7807 problem+json, e.g., {""title"": ""Forbidden"", ""detail"": ""User lacks permission"", ""status"": 403, ""type"": ""https://example.com/probs/forbidden""}
- Versioned content-negotiation, locale/tz support, JSON limits, upload mime guard (N/A here), cache headers
- Response should include ETag for caching if permission sets are stable

## Relevant Business Logic

- Permission check: Traverse user->roles (multi-role support) and check if any role has the exact permission via ability (role↔perm) junction
- Permissions use dotted notation (e.g., 'catalog.products.edit') for granularity across domains like orders, inventory, payments
- Deny by default: Return false if no matching permission found
- Audit the check: Log audit_event with user_id, permission checked, outcome for compliance
- Conflicts/Illegality: If state machine or domain guards (e.g., fraud flag) affect access, integrate checks; return problem+json for violations
- Integrations: Supports webhooks/notifications if permission changes trigger events; aligns with reporting/analytics on activity and RBAC usage
- Edge Cases: Handle soft-deleted roles/users, EAV attributes on permissions, polymorphic attachments if permissions have notes"
36,rbac,Simulate Policy,Simulate access decision,api/rbac/simulate,post,Admin,Implement RBAC Simulate Policy API Endpoint,"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This issue covers the implementation of the 'Simulate Policy' API endpoint in the RBAC category. It allows simulating access decisions for users/roles against permissions without executing the action, aiding in debugging and policy testing.

## API Specifications

- **Category:** rbac
- **Title:** Simulate Policy
- **Description:** Simulate access decision
- **Route:** api/rbac/simulate
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST /api/rbac/simulate endpoint in Laravel
- [ ] Add request validation for input parameters (e.g., user_id, action, resource)
- [ ] Integrate with RBAC system to simulate policy evaluation
- [ ] Return appropriate response indicating access decision (allowed/denied) with reasons
- [ ] Handle errors per RFC7807 problem+json format
- [ ] Ensure endpoint is protected by Admin authentication and RBAC checks
- [ ] Write unit and integration tests covering success, denial, and edge cases
- [ ] Add documentation for request/response schemas
- [ ] Verify middleware application (auth, RBAC, throttling, etc.)
- [ ] Audit logging for simulation requests

## Technical Requirements

- Use Laravel controller (e.g., RbacController@simulate) and define route in api.php
- Implement input validation using Form Requests or Validator facade
- Leverage existing RBAC models (user, role, permission, ability) for policy simulation
- Apply state machine checks if applicable to permissions
- Use Eloquent for querying user roles and permissions efficiently
- Support soft deletes and UTC handling
- Integrate with middleware stack: auth (JWT/API key), RBAC & permission checks, request-id, etc.
- Ensure idempotency and caching/etag where feasible
- Handle polymorphic relations if simulations involve attachments/notes

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Caller must have admin privileges to simulate policies (enforce via RBAC)
- Include active user, email-verified, and 2FA checks if enabled
- Branch scope and optional tenancy enforcement
- Log audit_event for all simulation requests

## Expected Request/Response Format Considerations

- **Request:** JSON body, e.g., {""user_id"": 123, ""action"": ""view"", ""resource"": ""orders"", ""context"": {}} – Validate required fields, sanitize inputs
- **Response:** JSON, e.g., 200: {""allowed"": true, ""reasons"": [""role X grants perm Y""]} or 403: problem+json with details
- Use versioned content-negotiation and locale/tz from headers
- Limit JSON payload size; apply CORS and TLS
- For denials, provide detailed reasons without exposing sensitive PII (mask if needed)

## Relevant Business Logic

- Simulate access without side effects: query user_role, role→permission mappings, and abilities
- Consider multi-role support and permission inheritance
- Evaluate against domain guards (e.g., fraud, promo) if context provided
- Align with overall security model: no actual state changes, just decision
- Ensure determinism for testing; return consistent results for same inputs
- Integrate with observability: metrics on simulation frequency, log request-id for tracing"
37,user,List Users,List Users,api/users,get,Admin,Implement List Users API Endpoint (GET /api/users),"## Overview

This GitHub issue is for implementing the 'List Users' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs built over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits.

Core entities include: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.

Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.

Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.

Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).

Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.

Services: service/service_order with lifecycle and profitability.

Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.

Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The 'List Users' endpoint falls under the 'user' category and is part of the security & identity domain, allowing admins to retrieve a list of users, potentially including roles, permissions, and other user-related details while respecting RBAC and PII masking.

## API Specifications

- **Category:** user
- **Title:** List Users
- **Description:** List Users
- **Route:** api/users
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET /api/users endpoint in Laravel to return a paginated list of users
- [ ] Ensure only authenticated Admin users can access the endpoint
- [ ] Support query parameters for filtering, sorting, and pagination (e.g., ?page=1&per_page=20&search=query&role_id=1)
- [ ] Include relevant user fields like id, name, email, roles, permissions, status (active/inactive), email_verified, with PII masking where applicable
- [ ] Handle soft deletes by excluding deleted users or providing an option to include them
- [ ] Return RFC7807 problem+json for errors (e.g., unauthorized, invalid params)
- [ ] Add audit logging for endpoint access
- [ ] Write unit and feature tests covering success, auth failure, invalid params, and edge cases
- [ ] Ensure response caching with ETag and proper cache headers
- [ ] Integrate with middleware stack: auth (JWT/session/API key), RBAC & permission checks, active user, email-verified, 2FA, throttles, input sanitizer

## Technical Requirements

- Use Laravel controller (e.g., UserController@list) and define route in api.php with prefix 'api/'
- Implement Eloquent query on User model with joins to user_role, role, permission tables for role/permission data
- Use Laravel's pagination (LengthAwarePaginator) with default per_page=15, support ?page and ?per_page
- Apply Resource classes (e.g., UserResource) for response formatting, transforming sensitive data
- Input validation using FormRequest or validator for query params (e.g., search as string, role_id as integer)
- Error handling: Use Laravel exceptions (e.g., AuthorizationException) mapped to Problem Details
- Database: Query in UTC, respect soft deletes with withTrashed() if needed
- Performance: Index on user fields like email, name; use eager loading for relations
- Testing: PHPUnit tests with factories for users/roles; mock auth
- Documentation: Update API docs (e.g., Swagger/OpenAPI) with endpoint details

## Authentication/Authorization Requirements

- Require Admin authentication via JWT, session, or API key
- RBAC check: User must have 'view-users' permission or equivalent in their role
- Enforce active user status and email verification
- Optional: 2FA enforcement if enabled globally
- Branch scope: Not applicable for users, but ensure global access for admins

## Expected Request/Response Format Considerations

- **Request:** GET /api/users?page=1&per_page=20&search=joh&sort=name&direction=asc&role_id=1
  - Query params: page (int, default 1), per_page (int, 1-100), search (string), sort (string: name,email,created_at), direction (asc/desc), role_id (int)
  - No body required

- **Response (200 OK):** JSON with pagination metadata
  {
    ""data"": [
      {
        ""id"": 1,
        ""name"": ""John Doe"",
        ""email"": ""john@example.com"",
        ""roles"": [""Admin""],
        ""permissions"": [""view-users"", ""edit-users""],
        ""email_verified_at"": ""2023-01-01T00:00:00Z"",
        ""created_at"": ""2023-01-01T00:00:00Z"",
        ""updated_at"": ""2023-01-01T00:00:00Z""
      }
    ],
    ""links"": { ... },
    ""meta"": { ""current_page"": 1, ""last_page"": 10, ... }
  }

- **Error Responses:**
  - 401 Unauthorized: { ""type"": ""https://tools.ietf.org/html/rfc7235#section-3.1"", ""title"": ""Unauthenticated"", ""status"": 401 }
  - 403 Forbidden: { ""type"": ""https://tools.ietf.org/html/rfc7231#section-6.5.3"", ""title"": ""Forbidden"", ""status"": 403, ""detail"": ""Insufficient permissions"" }
  - 422 Unprocessable Entity: For invalid query params

- Content-Type: application/json; charset=utf-8
- Versioned: Support content negotiation for API version (e.g., Accept: application/vnd.deshio.v1+json)
- Locale/TZ: Respect request headers for localization if applicable

## Relevant Business Logic

- Users can have multi-roles via user_role junction; include active roles only
- Permissions via role↔perm abilities; expose user permissions aggregated from roles
- PII masking: Mask or omit sensitive fields (e.g., partial email) based on viewer permissions or compliance rules
- Soft deletes: Exclude deleted users by default; audit events should log access
- Integration with observability: Log request-id, audit_event for list action
- State: Users have status (active/inactive); filterable
- Conflicts: If RBAC denies, return 403; use state machines if user state transitions are involved (though not primary for list)
- Deterministic: Ensure consistent ordering and pagination for reproducible lists
- Security: Prevent enumeration attacks via throttling and no user count leaks without auth"
38,user,Create User,Create User,api/users,post,Admin,Implement Create User API Endpoint (POST /api/users),"## Overview

This GitHub issue tracks the implementation of the 'Create User' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. Order domain includes states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment covers shipments, inter-store dispatch with tracking and POD. Returns handle RMA, restock/scrap, refunds, exchanges. Payments include intent→capture/void, refunds, synchronization. Accounting uses transaction headers + ledger entries for movements, reversals, reconciliation/export. Services include service orders with lifecycle and profitability. Integrations cover carriers, waybills/rates/tracking, webhooks, notifications (email/SMS). Security & identity: user/role/permission with abilities and multi-role support; sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines ensure legal transitions for orders, items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links. Design enables deterministic admin assignment, safe reservation/consumption, consistent ledger posting.

The 'Create User' endpoint allows administrators to create new users in the system, integrating with RBAC (roles/permissions), email verification, and other security features.

## API Specifications

- **Category:** user
- **Title:** Create User
- **Description:** Create User
- **Route:** api/users
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST /api/users endpoint in the Laravel controller
- [ ] Validate input data including required fields like email, password, name, and optional fields like roles, permissions, branch scope
- [ ] Ensure user creation triggers email verification process
- [ ] Handle role assignment during creation (multi-role support via user_role junction)
- [ ] Integrate with state machines for user lifecycle (e.g., pending verification)
- [ ] Apply middleware: auth (Admin JWT/session/API key), RBAC permission checks for 'create user'
- [ ] Return RFC7807 problem+json for validation errors or unauthorized access
- [ ] Log audit_event for user creation
- [ ] Write unit tests for controller logic, validation, and error handling
- [ ] Write integration tests for full request/response cycle including database interactions
- [ ] Ensure soft delete compatibility and UTC timestamping
- [ ] Test with PII masking in logs
- [ ] Verify idempotency for duplicate email attempts

## Technical Requirements

- Use Laravel framework: Define route in api.php, create UserController@store method
- Implement input validation using Form Requests or Validator facade (e.g., unique email, password hashing with bcrypt)
- Handle business logic: Create user record, assign default or specified roles/permissions, generate verification token, queue email notification
- Integrate with EAV for user attributes if extended; polymorphic attachments if notes provided
- Error handling: 201 Created on success, 400 Bad Request for validation, 401/403 for auth issues, 409 Conflict for duplicates
- Database: Use users table with fields like id, name, email, password, email_verified_at, remember_token; junctions for user_role
- Middleware stack: Apply RequestId, JSON limits, auth, active user, RBAC (permission: 'users.create'), branch scope if applicable
- Observability: Add audit_event logging, request-id tracing, metrics for endpoint performance
- Caching: Use etag for responses if applicable; queues for email sending

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC check: User must have 'users.create' permission via role→permission mapping
- Enforce active user status and email verification on the requesting admin
- Optional 2FA if enabled; branch scope limits creation to assigned branches
- Post-creation, new user starts in unverified state; admin can override if permitted

## Expected Request/Response Format Considerations

- **Request Body (JSON):** 
  {
    ""name"": ""string (required)"",
    ""email"": ""string (required, unique)"",
    ""password"": ""string (required, min:8)"",
    ""roles"": [""array of role ids (optional, for multi-role)"",
    ""permissions"": [""array of perm ids (optional, direct assign)"",
    ""branch_id"": ""int (optional, for scope)"",
    ""attributes"": {""key-value for EAV (optional)""}
  }
- **Response (201 Created):** 
  {
    ""data"": {
      ""id"": int,
      ""name"": string,
      ""email"": string,
      ""email_verified_at"": null|datetime (UTC),
      ""roles"": [array of role objects],
      ""created_at"": datetime (UTC)
    },
    ""message"": ""User created successfully""
  }
- **Error Response (e.g., 400):** RFC7807 format, e.g., {""type"": ""validation_error"", ""title"": ""Invalid data"", ""detail"": ""Email already exists"", ""status"": 400, ""violations"": [array]}
- Content negotiation: versioned (e.g., /api/v1/users), JSON only; locale/tz from headers
- Idempotency: Use client-generated key in header to prevent duplicates

## Relevant Business Logic

- User creation must comply with security policies: Hash password, generate secure tokens for verification/reset
- Integrate with multi-role system: Assign roles via user_role pivot, compute abilities (role↔perm)
- Trigger email verification workflow; optional immediate verification by admin
- Support TOTP MFA setup post-creation; generate backup codes if enabled
- Enforce domain guards: Prevent creation if fraud flags or blacklists apply (cross-check with customer entities if linked)
- Ledger/audit: Post audit_event; if financial implications (e.g., user-linked payments), ensure consistency
- State machine: Initial state 'pending', transitions to 'verified' on email confirm
- Soft delete: New users not deleted; archival via timestamps
- Integrations: Queue notification template (email for welcome/verification); webhook if user events configured"
39,user,Get User,Get User,api/users/{id},get,Admin,Implement GET /api/users/{id} Endpoint for Admin,"## Overview

This GitHub issue tracks the implementation of the ""Get User"" API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. The endpoint retrieves detailed information for a specific user by ID, accessible only to administrators. It aligns with the system's security, observability, and data integrity standards.

Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

## API Specifications

- **Category:** user
- **Title:** Get User
- **Description:** Get User
- **Route:** api/users/{id}
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET /api/users/{id} endpoint to retrieve user details by ID
- [ ] Ensure the endpoint requires admin authentication and authorization
- [ ] Validate the {id} parameter (e.g., must be a valid user ID, handle non-existent IDs with 404)
- [ ] Return user data in JSON format, including relevant relations like roles and permissions
- [ ] Handle soft-deleted users appropriately (e.g., exclude or flag them)
- [ ] Apply PII masking if applicable for compliance
- [ ] Log the request with request-id and audit_event for observability
- [ ] Write unit tests for successful retrieval, invalid ID, and unauthorized access
- [ ] Write integration tests covering full request flow with middleware
- [ ] Update API documentation with request/response examples
- [ ] Ensure response uses ETag for caching and versioned content-negotiation

## Technical Requirements

- Develop in Laravel framework: Define the route in routes/api.php with appropriate middleware stack
- Create or update UserController with a show() method to fetch the user using Eloquent (e.g., User::with(['roles', 'permissions'])->findOrFail($id))
- Implement input validation using FormRequest or validator for {id} (integer/UUID, exists in users table)
- Use Laravel's resource classes for consistent JSON response formatting
- Handle errors with RFC7807 problem+json for validation failures, unauthorized access (401), or not found (404)
- Integrate with state machines if user state affects retrieval (e.g., active/inactive)
- Ensure data is returned in UTC; support locale/tz from middleware
- Add idempotency and throttling support via middleware
- Consider EAV attributes for user-specific fields and polymorphic relations for notes/attachments
- Enable soft deletes handling; query with()->withTrashed() if archival access needed for admins

## Authentication/Authorization Requirements

- Require JWT, session, or API key authentication via middleware
- Enforce admin role/permission checks using RBAC (e.g., 'view-users' permission)
- Apply active user, email-verified, and 2FA middleware if session-based
- Include branch scope if users are scoped to branches/stores
- Use domain guards for user-related operations
- Reject unauthorized requests with 403 Forbidden

## Expected Request/Response Format Considerations

- **Request:** GET /api/users/{id} (e.g., GET /api/users/123)
  - Path parameter: {id} - User ID (integer or UUID)
  - Headers: Authorization (Bearer/JWT), Accept (application/json), X-Request-ID
  - No body required

- **Response (200 OK):** JSON object with user details
  ```json
  {
    ""data"": {
      ""id"": 123,
      ""name"": ""John Doe"",
      ""email"": ""john@example.com"",
      ""roles"": [...],
      ""permissions"": [...],
      ""created_at"": ""2023-01-01T00:00:00Z"",
      // Additional fields: phone, status, attributes (EAV), etc.
    }
  }
  ```
  - Include ETag header for caching
  - Mask sensitive PII (e.g., hash emails in logs but full for admin response)

- **Error Responses:**
  - 401 Unauthorized: Missing/invalid auth
  - 403 Forbidden: Insufficient permissions
  - 404 Not Found: User does not exist
  - 422 Unprocessable Entity: Invalid ID format
  - All errors in RFC7807 problem+json format

## Relevant Business Logic

- Retrieve full user profile including multi-roles (user_role junction), permissions (ability matrix), and security features (MFA status, email verification)
- Support for customer tags/blacklist if user is a customer
- Ensure consistency with RBAC: Admins can view any user; respect tenancy/branch scope if enabled
- Trigger audit_event on access for compliance
- If user is soft-deleted, return 404 or include archival flag based on admin privileges
- Integrate with reporting: User data may feed into analytics like activity or LTV
- No state transitions involved, but check user status (e.g., active) via middleware
- Align with overall design: Deterministic retrieval, safe data exposure, and ledger posting if access logs financial events"
40,user,Update User,Update User,api/users/{id},put,Admin,Implement Update User API Endpoint (PUT /api/users/{id}),"## Overview

Deshio is a Laravel-based ERP system for retail/omni-channel operations, featuring approximately 290 REST APIs built over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes (fields/features), media (product images), barcodes, pricing (price overrides), promotions; stores/branches; customers with tags/blacklists.

Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending → confirmed → fulfilled|cancelled), assignment to stores, notes/attachments, promotions, taxes, and fraud flags.

Fulfillment handles shipments (shipment/shipment_item) and inter-store dispatches (dispatch + tracking, scan events, POD) with transactional stock movements. Returns manage RMAs (return/return_item), receiving/restocking/scrap, refunds, and exchanges (exchange_order).

Payments involve intent → payment capture/void; refund lifecycles; and order payment status synchronization. Accounting uses transaction headers + ledger_entry lines for all movements, reversals, and reconciliation/export.

Services include service/service_order with lifecycles and profitability. Integrations cover carriers & accounts, waybills/rates/tracking; webhooks with deliveries; and notification templates (email/SMS).

Security & identity: users/roles/permissions with abilities (role ↔ perm) and user_roles (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_events, logs, request-ids, PII masking, health/metrics, queues, caching/etag.

Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines ensure legal transitions for orders, order items, dispatches, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint allows administrators to update user information in the Deshio ERP system, focusing on the user entity within the security & identity domain.

## API Specifications

- **Category:** user
- **Title:** Update User
- **Description:** Update User
- **Route:** api/users/{id}
- **HTTP Method:** put
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint successfully updates user details when provided with valid admin authentication and user ID
- [ ] Validates input data according to user entity schema (e.g., name, email, roles, permissions, MFA status)
- [ ] Handles soft deletes and archival considerations for user updates
- [ ] Enforces RBAC: only admins can access and modify user data
- [ ] Returns appropriate success response with updated user data (excluding sensitive fields like passwords)
- [ ] Implements error handling for invalid IDs, unauthorized access, or validation failures using RFC7807 problem+json
- [ ] Logs audit events for user updates
- [ ] Includes unit and integration tests covering happy path, edge cases, and security scenarios
- [ ] Ensures PII masking in logs and responses where applicable
- [ ] Supports idempotency for repeated update requests

## Technical Requirements

- Implement in Laravel: Define route in api.php, create/update UserController method
- Use Eloquent for User model interactions, respecting soft deletes and relationships (e.g., user_roles, permissions)
- Apply middleware stack: auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks
- Input validation with Laravel Form Requests: Validate fields like email uniqueness, role assignments, password hashing if updated
- Output: JSON response with HTTP 200 OK on success, standardized error formats
- Integrate with state machines if user state transitions are involved (e.g., activating/deactivating users)
- Ensure UTC handling for any timestamp fields
- Add caching/etag support if applicable for user data retrieval post-update
- Write comprehensive tests: PHPUnit for unit/integration, feature tests for endpoint

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC check: User must have 'admin' role or specific 'update-user' permission
- Enforce multi-role support: Updates can assign/remove roles via user_role junction
- Include 2FA and email verification checks via middleware
- Branch scope if applicable (though users are global)
- Throttle requests to prevent abuse

## Expected Request/Response Format Considerations

- **Request:** JSON body with updatable user fields, e.g., {""name"": ""Updated Name"", ""email"": ""new@example.com"", ""roles"": [1,2], ""mfa_enabled"": true}. Exclude or hash passwords if provided.
- **Path Parameter:** {id} as numeric user ID
- **Headers:** Authorization, Content-Type: application/json, Accept: application/json, X-Request-ID
- **Response (Success):** 200 OK, JSON: {""data"": {""id"": 1, ""name"": ""Updated Name"", ...}} (exclude sensitive data like passwords, backup codes)
- **Response (Error):** 4xx/5xx with RFC7807 problem+json, e.g., {""type"": ""https://example.com/probs/validation"", ""title"": ""Invalid Input"", ""detail"": ""Email already exists""}
- Versioned via content-negotiation (e.g., /v1/users/{id})
- Locale/tz handling for any display fields

## Relevant Business Logic

- Updates must respect user entity relationships: roles/permissions via abilities, multi-role assignments
- Handle email verification: If email updated, trigger re-verification process
- MFA considerations: Updates to TOTP or backup codes require secure handling
- Audit logging: Record all changes in audit_event table with request-id
- Referential integrity: Prevent updates that break strict links (e.g., if user is assigned to orders)
- Fraud/Blacklist: If user is customer-linked, check tags/blacklists
- Soft deletes: Allow updates on non-deleted users only
- Idempotency: Use key to avoid duplicate updates
- Domain guards: Sanitize inputs, check for fraud flags if applicable to user actions
- Post-update: Trigger events for notifications (e.g., email confirmation), ledger if financial (unlikely for users), or queue jobs for background processing"
41,user,Delete User,Delete User,api/users/{id},delete,Admin,Implement DELETE /api/users/{id} for Admin User Deletion,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the Delete User API endpoint. This endpoint allows an admin to delete a user, supporting core entities like users/roles/permissions with multi-role assignments, sessions, email verification, password reset, TOTP MFA + backup codes, and API keys. Data is stored in UTC with soft deletes for archival, EAV for attributes, polymorphic notes/attachments, and strict referential links. The design ensures deterministic admin assignment, safe operations, and consistent ledger posting. Observability includes audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting covers revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

The Delete User endpoint deletes a specified user, handling soft deletion to maintain archival integrity and triggering relevant audits.

## API Specifications

- **Category:** user
- **Title:** Delete User
- **Description:** Delete User
- **Route:** api/users/{id}
- **HTTP Method:** delete
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint returns 204 No Content on successful deletion of a valid user ID
- [ ] Endpoint returns 404 Not Found if user ID does not exist
- [ ] Endpoint returns 403 Forbidden if requester lacks admin permissions
- [ ] Soft delete the user record instead of hard delete, preserving referential integrity
- [ ] Trigger audit_event for the deletion action with request-id and PII masking
- [ ] Handle dependencies: prevent deletion if user has active sessions or unresolved orders; queue cleanup if possible
- [ ] Validate {id} as a valid UUID or integer user identifier
- [ ] Apply RBAC checks via middleware for admin role/permission
- [ ] Ensure idempotency for repeated delete requests
- [ ] Write unit/integration tests covering success, error cases, auth, and audit logging
- [ ] Document endpoint in API specs with OpenAPI/Swagger annotations
- [ ] Verify no stock/financial events are affected unless user-linked

## Technical Requirements

- Implement in Laravel controller (e.g., UserController@destroy) with route registration in api.php
- Use Eloquent model for User with softDeletes trait enabled
- Input validation: Ensure {id} is required and exists via route model binding
- Proper error handling: Use RFC7807 problem+json for validation/auth errors; log exceptions with request-id
- Middleware stack: Apply auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks (admin ability), throttles, idempotency, input sanitizer
- Integrate with observability: Log deletion in audit_event, apply PII masking for user data
- Consider branch scope and optional tenancy if user is scoped
- Use queues for any post-deletion cleanup (e.g., session invalidation)
- Cache invalidation: Clear any user-related caches/etag
- Testing: PHPUnit tests for controller, including mocking auth and RBAC

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC check: User must have 'delete-user' permission or admin role
- Middleware enforces active user, email-verified, and 2FA where applicable
- Branch scope: If enabled, ensure admin has access to the user's branch

## Expected Request/Response Format Considerations

- **Request:** No body required; {id} as path parameter (e.g., DELETE /api/users/123)
- Headers: Authorization (Bearer/JWT), Accept: application/json, Content-Type: application/json (if needed), X-Request-ID
- **Response:** 
  - Success: 204 No Content
  - Error: 4xx/5xx with JSON body per RFC7807 (e.g., {""type"": ""https://example.com/probs/validation"", ""title"": ""Invalid ID"", ""status"": 400, ""detail"": ""User ID must be valid""})
- Versioned: Support content-negotiation for API version (e.g., /api/v1/users/{id})
- Locale/TZ: Respect Accept-Language and X-Timezone headers; store events in UTC

## Relevant Business Logic

- Soft delete user to allow archival and reversal if needed
- Cascade effects: Invalidate sessions, remove from user_role junctions, flag linked orders/customers for re-assignment
- Prevent deletion if user is in active transactions (e.g., open orders, payments, audits) – return conflict error
- Post-deletion: Update any polymorphic relations (notes/attachments) to null or archive
- Audit trail: Record deletion event with actor user ID, timestamp, reason (if provided), and affected user details (masked)
- Compliance: Ensure GDPR-like PII handling; no hard delete without backup/restore considerations
- Integrations: Notify via webhooks if user deletion impacts external systems (e.g., carriers, notifications)
- State machine: If applicable, transition user state to 'deleted' with legality checks"
42,user,Activate User,Activate User,api/users/{id}/activate,post,Admin,Implement POST /api/users/{id}/activate Endpoint,"## Overview

As a technical writer creating GitHub issues for API implementation in the Deshio ERP system, this issue covers the development of the 'Activate User' API endpoint. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint specifically handles user activation within the security and identity domain, ensuring compliance with RBAC, email verification, and audit logging.

## API Specifications

- **Category:** user
- **Title:** Activate User
- **Description:** Activate User
- **Route:** api/users/{id}/activate
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the endpoint in a Laravel controller
- [ ] Ensure the route is registered in the API routes file with proper middleware
- [ ] Validate that the user ID exists and is currently inactive before activation
- [ ] Update the user's status to active upon successful activation
- [ ] Trigger any necessary events, such as audit logging or notifications (e.g., email verification if pending)
- [ ] Handle errors according to RFC7807 problem+json format for invalid states or permissions
- [ ] Write unit tests for successful activation, invalid user, and unauthorized access
- [ ] Write integration tests covering the full request-response cycle with authentication
- [ ] Ensure the endpoint integrates with the middleware chain (auth, RBAC, active user checks)
- [ ] Verify soft deletes and UTC handling for user records
- [ ] Test for idempotency if multiple activations are attempted

## Technical Requirements

- Use Laravel framework for controller, routes, and validation
- Implement input validation for the {id} parameter (e.g., UUID or integer, must exist in users table)
- Leverage Eloquent model for User with activation logic (e.g., set 'is_active' = true, handle email_verified_at if applicable)
- Integrate with state machines if user lifecycle transitions require it (e.g., from 'pending' to 'active')
- Apply proper error handling: 404 for non-existent user, 403 for insufficient permissions, 409 for already active
- Include audit_event logging for the activation action with request-id
- Support PII masking in logs and responses
- Ensure compatibility with queues for any asynchronous notifications (e.g., email/SMS)
- Use versioned content-negotiation and cache headers as per middleware plan
- Handle polymorphic attachments or notes if activation adds any

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: Only users with 'admin' role or specific 'user.activate' permission can access
- Apply middleware: auth, active user, email-verified, 2FA, RBAC & permission checks
- Scope to branch if multi-tenancy is enabled (optional)
- Throttle requests and ensure idempotency key support

## Expected Request/Response Format Considerations

- **Request:** POST to /api/users/{id}/activate; body expected to be empty JSON {} or optional fields like {'reason': 'string'} if business logic requires notes. Use JSON limits middleware.
- **Response:** On success, return 200 OK with JSON body including the updated user object (e.g., {""id"": ""uuid"", ""email"": ""masked"", ""is_active"": true, ""activated_at"": ""UTC-timestamp""}) or a simple success message {""message"": ""User activated successfully""}. Include ETag for caching.
- **Errors:** Return RFC7807 problem+json, e.g., 403 {""type"": ""https://example.com/probs/forbidden"", ""title"": ""Insufficient permissions"", ""detail"": ""Admin role required""}. Use request-id in headers.
- All data in UTC; mask PII in responses (e.g., email partial).

## Relevant Business Logic

- Activation should only occur for inactive users (e.g., pending email verification or manual deactivation); use state machine to validate transition legality.
- Post-activation, enable login sessions, API keys, and TOTP MFA if configured.
- Trigger ledger_entry or audit_event for compliance tracking.
- If user has multi-roles, ensure activation propagates without affecting role permissions.
- Integrate with password reset or backup codes if activation follows a recovery flow.
- Ensure transactional consistency: rollback on failure to maintain referential integrity.
- Consider integrations like notifications (email/SMS templates) for activation confirmation.
- Align with observability: log metrics for user activation rates in reporting/analytics."
43,user,Deactivate User,Deactivate User,api/users/{id}/deactivate,post,Admin,Implement Deactivate User API Endpoint (POST /api/users/{id}/deactivate),"## Overview

This GitHub issue is for implementing the 'Deactivate User' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint allows authenticated admins to deactivate a specific user account, which is part of the user management in the security & identity domain. Deactivation should set the user's active status to inactive, log an audit event, and prevent further logins while preserving data for compliance.

## API Specifications

- **Category:** user
- **Title:** Deactivate User
- **Description:** Deactivate User
- **Route:** api/users/{id}/deactivate
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the endpoint in a Laravel controller handling POST requests to /api/users/{id}/deactivate
- [ ] Validate that the {id} exists and belongs to a valid user
- [ ] Ensure only admins (via RBAC) can access and execute the deactivation
- [ ] Deactivate the user by updating is_active to false and trigger an audit_event log
- [ ] Handle cases where the user is already deactivated (return appropriate error)
- [ ] Return RFC7807 problem+json for conflicts or invalid states
- [ ] Add unit and integration tests covering success, failure, and edge cases (e.g., non-existent user, unauthorized access)
- [ ] Integrate with middleware for auth, RBAC checks, request-id, and error handling
- [ ] Ensure data remains in UTC and respects soft deletes if applicable
- [ ] Document the endpoint in API specs with request/response examples

## Technical Requirements

- Use Laravel framework: Define route in api.php, create or extend UserController with deactivate method
- Input validation: Validate {id} as a valid UUID/integer; no request body expected, but sanitize if present
- Proper error handling: Use state machine if applicable for user status transitions; return 404 for non-existent user, 403 for unauthorized, 409 for conflicts
- Integration with Deshio's ERD: Update user entity (user table with is_active flag); polymorphic relations for audit_event and logs
- Observability: Generate audit_event on deactivation; include request-id in logs; mask PII in responses
- Middleware application: Apply auth (JWT/API key), active user check (irrelevant for deactivation), RBAC & permission checks (admin role/permission for user deactivation), throttles, idempotency
- Testing: PHPUnit tests for controller logic, authorization; integration tests with database transactions
- Performance: Use ETag/caching headers if user data is fetched; queue audit logging if heavy

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC enforcement: Caller must have a role with permission to deactivate users (e.g., 'users.deactivate' ability)
- Multi-role support: Check all assigned roles/permissions for the authenticated user
- Additional checks: Ensure the target user is not the same as the acting admin to prevent self-deactivation issues; email-verified and 2FA not required for this admin action but logged
- Branch scope and tenancy: Apply if configured, ensuring deactivation is scoped appropriately

## Expected Request/Response Format Considerations

- **Request:** POST /api/users/{id}/deactivate
  - Headers: Authorization (Bearer/JWT), Content-Type: application/json, X-Request-Id
  - Body: Empty (or optional JSON {} for idempotency)
  - Path param: {id} - User ID (UUID/integer)

- **Response (Success - 200 OK):**
  ```json
  {
    ""data"": {
      ""id"": ""user-id"",
      ""email"": ""masked@example.com"",
      ""name"": ""User Name"",
      ""is_active"": false,
      ""deactivated_at"": ""2023-10-01T12:00:00Z""
    },
    ""message"": ""User deactivated successfully""
  }
  ```
  - Include ETag for caching; versioned via content-negotiation

- **Response (Error - e.g., 403 Forbidden):**
  ```json
  {
    ""type"": ""https://example.com/probs/unauthorized"",
    ""title"": ""Unauthorized"",
    ""status"": 403,
    ""detail"": ""Admin permission required to deactivate users""
  }
  ```
  - Follow RFC7807 problem+json for all errors

- Considerations: Responses in JSON; PII masking for email/name; UTC timestamps; no attachments or media in response

## Relevant Business Logic

- Deactivation transitions user state via state machine (active → inactive); prevent logins/sessions but retain data for audits/compliance
- Trigger audit_event with details (actor user_id, target user_id, timestamp, action: 'deactivate')
- Handle cascades: Invalidate active sessions; update related entities if needed (e.g., notify linked orders/customers? but minimal per design)
- Compliance: Soft delete not applied (archival); log for observability; no financial/ledger impact unless user has open transactions (check and warn)
- Edge cases: If user has admin roles, require elevated permission; integrate with email verification reset if reactivated later
- Idempotency: Allow repeated calls without error if already deactivated
- Domain guards: Apply fraud/user-specific guards if configured for deactivation

## Additional Notes

Ensure implementation aligns with Deshio's design principles: deterministic operations, consistent ledger/audit posting, and safe transitions. After implementation, update API documentation and run full test suite."
44,user,Invite User,Invite User,api/users/invite,post,Admin,Implement Invite User API Endpoint (POST /api/users/invite),"## Overview

Implement the 'Invite User' API endpoint in the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations. This endpoint allows admins to invite new users, integrating with the security and identity management features. Deshio covers ~290 REST APIs over a normalized ERD including catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include users with roles/permissions, supporting multi-role assignments, email verification, password reset, TOTP MFA, and API keys. Data is stored in UTC with soft deletes, EAV for attributes, and polymorphic relations. State machines ensure legal transitions, with conflicts returning RFC7807 problem+json. Middleware includes auth (JWT/session/API key), RBAC checks, email-verified, 2FA, and throttles.

## API Specifications

- **Category:** user
- **Title:** Invite User
- **Description:** Invite User
- **Route:** api/users/invite
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint responds to POST requests at /api/users/invite with Admin authentication
- [ ] Validates input parameters (e.g., email, role, permissions) and returns appropriate errors for invalid data
- [ ] Creates a pending user invitation, sends email notification via notification templates (email/SMS), and handles email verification flow
- [ ] Integrates with RBAC: assigns initial role/permission via ability (role↔perm) and user_role (multi-role support)
- [ ] Supports sessions, password reset initiation, and optional TOTP MFA setup post-invitation
- [ ] Logs audit_event for the invitation action, with request-id and PII masking
- [ ] Handles bulk invitations if extended, with idempotency keys
- [ ] Returns success response with invitation token or user ID, and error responses in problem+json format
- [ ] Unit and integration tests cover happy path, validation errors, unauthorized access, and edge cases (e.g., duplicate email)
- [ ] Documentation updated for API (e.g., OpenAPI spec) including request/response examples

## Technical Requirements

- Use Laravel framework: Define route in api.php, create dedicated controller (e.g., UserInvitationController) with invite method
- Implement input validation using Form Requests or Validator facade, covering required fields like email, name, initial role
- Integrate with Eloquent models: User, Role, Permission, with soft deletes and strict referential integrity
- Leverage Laravel's notification system for sending invitation emails, using templates from notification templates entity
- Apply middleware stack: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified (post-acceptance), 2FA, RBAC & permission checks (admin-only), branch scope, throttles, idempotency, input sanitizer
- Ensure deterministic behavior: Safe user creation without conflicts, consistent ledger/audit posting if applicable
- Handle attachments or notes polymorphically if invitation includes custom messages
- Support feature flags for enabling/disabling invitations or MFA requirements
- Observability: Log events to audit_event/log, expose metrics for invitation success rates, use caching/etag where appropriate
- Reporting tie-in: Track user activity for analytics like LTV/AOV if user becomes active
- Error handling: Use RFC7807 problem+json for validation/state machine conflicts, with domain guards for user-related actions

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC check: Invoker must have 'user.invite' permission, verified via role↔perm abilities and user_role assignments
- Post-invitation: New user must complete email verification and optional 2FA setup before full access
- Scope to branch/tenancy if enabled via middleware
- Provider webhook signatures not applicable, but replay defense via idempotency

## Expected Request/Response Format Considerations

- **Request:** JSON body, e.g., {""email"": ""user@example.com"", ""name"": ""John Doe"", ""role_id"": 1, ""permissions"": [1,2], ""branch_id"": 1, ""custom_message"": ""Welcome!""}. Use strict typing and sanitization.
- **Response:** 201 Created on success, e.g., {""data"": {""invitation_token"": ""abc123"", ""user_id"": 456, ""expires_at"": ""2024-01-01T00:00:00Z""}}, with Location header. 4xx for validation/auth errors, 409 for duplicates, in problem+json (e.g., {""title"": ""Validation Error"", ""detail"": ""Email already invited"", ""status"": 422}).
- Versioned via content-negotiation (e.g., Accept: application/vnd.deshio.v1+json). Cache headers for non-mutating parts if extended.
- Bulk support: Optional array of invites in body for efficiency.

## Relevant Business Logic

- Invitation creates a pending User record with status (e.g., invited→verified→active), using state machine for transitions
- Email sent via notification templates, including verification link with token for password setup
- Integrates with blacklist/tags: Check if email is blacklisted before inviting
- Supports multi-role: Assign initial roles, allow later additions via user_role junction
- On acceptance: Trigger audit_event, sync with sessions, enable API keys if requested
- Conflicts (e.g., existing user): Return error without creating duplicates, per referential links
- Ties into broader ERP: Invited users may access orders/inventory based on permissions, with branch scoping for store-specific data
- Compliance: PII masking in logs, GDPR-friendly soft deletes for inactive invitations
- Analytics: Track invitation acceptance rates for reporting on user growth, activity, and SLA"
45,user,Resend Invite,Resend Invite,api/users/{id}/resend-invite,post,Admin,Implement Resend Invite API for Users (POST /api/users/{id}/resend-invite),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint allows admins to resend an invitation email to a user, facilitating user onboarding in the security and identity module.

## API Specifications

- **Category:** user
- **Title:** Resend Invite
- **Description:** Resend Invite
- **Route:** api/users/{id}/resend-invite
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST /api/users/{id}/resend-invite endpoint in the Laravel controller
- [ ] Ensure the endpoint resends the invitation email only for users who have pending invitations
- [ ] Validate that the user ID exists and is eligible for resending invite (e.g., not already verified)
- [ ] Handle cases where the user has already been invited recently (e.g., rate limiting)
- [ ] Return success response on successful resend and appropriate error for failures
- [ ] Add unit and integration tests covering happy path, invalid ID, unauthorized access, and email send failures
- [ ] Ensure compliance with middleware stack including auth, RBAC, and audit logging
- [ ] Verify that the resend triggers an audit_event for compliance

## Technical Requirements

- Use Laravel controller (e.g., UserController) and define the route in api.php with proper middleware
- Implement input validation using Form Requests or Validator for the {id} parameter (must be a valid UUID or integer)
- Integrate with the notification system to resend the invitation email template
- Handle soft deletes: ensure the user is not soft-deleted
- Use state machines if applicable for user invitation states
- Proper error handling: return RFC7807 problem+json for conflicts (e.g., user already verified)
- Add idempotency support if multiple resends are possible
- Ensure data in UTC and PII masking in logs

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT/session/API key
- Enforce RBAC: Only users with 'admin' role or specific permission (e.g., 'users.invite-resend') can access
- Apply active user, email-verified, and 2FA checks via middleware
- Include branch scope if applicable, though user management may be global

## Expected Request/Response Format Considerations

- **Request:** POST with path parameter {id} (user ID). No request body expected, or optional empty JSON {}
- **Response:** On success, 200 OK with JSON { ""message"": ""Invite resent successfully"" }. On error, 404 if user not found, 403 if unauthorized, 409 if not eligible
- Use versioned content-negotiation and JSON limits middleware
- Include request-id in responses for observability

## Relevant Business Logic

- Resend only if the user's invitation is pending or expired (tie into email verification flow)
- Trigger notification template (email) for resend, with personalization
- Log audit_event for the resend action, including user ID and admin performer
- Prevent abuse: Implement throttle or cooldown period for resends per user
- Synchronize with user_role and permission checks to ensure only eligible admins can resend
- If MFA is enabled, ensure it doesn't interfere with initial invite resend"
46,user,List Sessions,List Sessions,api/users/{id}/sessions,get,Admin,Implement API: List User Sessions (GET /api/users/{id}/sessions),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the 'List Sessions' API endpoint in the user category. This endpoint allows admins to retrieve a list of active or historical sessions for a specific user, supporting security and identity management features including sessions, email verification, password reset, TOTP MFA + backup codes, and API keys.

Core entities include: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint fits into the security & identity domain, enabling audit and management of user sessions.

## API Specifications

- **Category:** user
- **Title:** List Sessions
- **Description:** List Sessions
- **Route:** api/users/{id}/sessions
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint returns a list of sessions for the specified user ID
- [ ] Requires admin authentication and proper RBAC permission checks
- [ ] Handles invalid user ID with appropriate error response (e.g., 404)
- [ ] Supports pagination, filtering, and sorting if applicable to sessions
- [ ] Includes audit logging for access to user sessions
- [ ] Response format adheres to JSON API standards with proper ETags and caching
- [ ] Unit and integration tests cover success, error cases, and edge scenarios
- [ ] Documentation updated with endpoint details, including sample request/response
- [ ] Middleware applied: auth (JWT/session/API key), RBAC, request-id, throttles

## Technical Requirements

- Implement in Laravel: Define route in api.php, create or extend UserController or SessionsController
- Use Eloquent models for User and Session entities, ensuring soft deletes and UTC handling
- Input validation: Validate {id} as a valid UUID or integer user ID
- Error handling: Use RFC7807 problem+json for conflicts; 401 for unauth, 403 for forbidden, 404 for not found
- Integrate with state machines if session states are managed (e.g., active/inactive)
- Ensure PII masking in logs and responses for compliance
- Add queue support if listing involves heavy computation (unlikely for sessions)

## Authentication/Authorization Requirements

- Authentication: Admin-level JWT, session, or API key
- Authorization: RBAC check for 'view user sessions' permission; multi-role support via user_role
- Middleware chain: auth → active user → email-verified → 2FA (if enabled) → RBAC & permission checks → branch scope
- Admin only: Restrict to users with admin role or specific ability (role↔perm)

## Expected Request/Response Format Considerations

- **Request:** GET /api/users/{id}/sessions?include=last_activity&filter[active]=true&page=1 (optional query params for pagination, filtering by active status, etc.)
  - No request body
  - Headers: Authorization: Bearer <token>, Accept: application/json, X-Request-ID
- **Response (200 OK):** JSON array of session objects, e.g., [{ ""id"": ""uuid"", ""user_id"": ""uuid"", ""ip_address"": ""masked"", ""user_agent"": ""string"", ""last_activity"": ""utc-timestamp"", ""is_active"": true, ""created_at"": ""utc"" }]
  - Include meta for pagination: { ""data"": [...], ""meta"": { ""current_page"": 1, ""total"": 10 } }
  - Links for related resources if using JSON API spec
  - Cache headers: ETag, Last-Modified
- **Error Responses:** 400 for invalid params, 401 Unauthorized, 403 Forbidden, 404 User not found, 500 Internal with problem+json

## Relevant Business Logic

- Sessions represent user login instances; list includes details like IP (masked for PII), user agent, timestamps
- Support for revoking sessions if needed (though not in this endpoint)
- Integrate with audit_event for logging access to this endpoint
- Ensure consistency with observability: request-id tracing, metrics on endpoint usage
- No direct impact on other domains, but ties into overall security middleware and compliance (e.g., GDPR via PII masking)
- Use polymorphic relations if sessions link to notes/attachments"
47,user,Revoke Session,Revoke Session,api/users/{id}/sessions/{session_id},delete,Admin,Implement Revoke Session API: DELETE /api/users/{id}/sessions/{session_id},"## Overview

This GitHub issue is for implementing the 'Revoke Session' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD covering domains like catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. Order domain handles states (pending→confirmed→fulfilled|cancelled), assignments, notes/attachments, promos, taxes, fraud flags. Fulfillment includes shipments, inter-store dispatches with tracking and POD. Returns manage RMAs, restocking, refunds, exchanges. Payments cover intents, captures, voids, refunds, and order synchronization. Accounting uses transaction headers and ledger entries for movements, reversals, reconciliations. Services handle service orders with lifecycle and profitability. Integrations include carriers, waybills, rates, tracking, webhooks, notifications. Security & identity: users/roles/permissions with multi-role support, sessions, email verification, password reset, TOTP MFA, API keys. Observability: audit events, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC/permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, webhook signatures, cache headers. Reporting: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price history, cycle count accuracy, promo impact, activity. State machines ensure legal transitions for orders, items, dispatches, shipments, returns, payments, cycle counts; conflicts use RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data in UTC; soft deletes; EAV for attributes; polymorphic notes/attachments; strict referential links. Design supports deterministic admin assignment, safe reservations, consistent ledger posting.

The 'Revoke Session' endpoint enables administrators to invalidate a specific user session, enhancing security by allowing forced logouts or session management in the user category.

## API Specifications

- **Category:** user
- **Title:** Revoke Session
- **Description:** Revoke Session
- **Route:** api/users/{id}/sessions/{session_id}
- **HTTP Method:** delete
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the DELETE endpoint handler in Laravel controller
- [ ] Validate path parameters (user ID and session ID) for existence and ownership
- [ ] Ensure admin-only access with proper RBAC checks
- [ ] Invalidate the specified session and update audit logs
- [ ] Return appropriate success response (e.g., 204 No Content)
- [ ] Handle errors with RFC7807 problem+json format for invalid sessions, unauthorized access, or non-existent users
- [ ] Add unit and integration tests covering success, failure, and edge cases (e.g., session already revoked, user not found)
- [ ] Integrate with middleware stack including auth, RBAC, request-id, and throttles
- [ ] Ensure soft deletes and UTC handling for session records
- [ ] Verify compatibility with session management in security & identity domain (users/roles/sessions)

## Technical Requirements

- Use Laravel framework: Define route in api.php, create or extend UserController or SessionController
- Implement in a dedicated method, e.g., revokeSession($id, $session_id)
- Leverage Eloquent models for User and Session entities with strict referential integrity
- Apply state machine if sessions have lifecycle states (e.g., active→revoked)
- Integrate with observability: Log audit_event for revocation, include request-id
- Handle polymorphic relations if sessions link to notes/attachments
- Ensure idempotency for repeated DELETE requests
- Use caching/etag if applicable for session checks
- Support versioned content-negotiation and locale/tz from middleware
- Align with overall Deshio design: Deterministic operations, safe concurrency for session invalidation

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce active user, email-verified, and 2FA checks via middleware
- RBAC: Admin role/permission must include ability to revoke user sessions (e.g., permission 'users.sessions.revoke')
- Branch scope and optional tenancy if user sessions are scoped
- Reject if caller lacks permission, returning 403 Forbidden with problem+json

## Expected Request/Response Format Considerations

- **Request:** No body required; path parameters {id} (user ID, UUID/integer) and {session_id} (session identifier, string/UUID). Use JSON API content-type if extensions added.
- **Response:** Success: 204 No Content. Errors: 400/404/403/422 with RFC7807 problem+json (e.g., {""type"":""https://example.com/probs/session-not-found"",""title"":""Session Not Found"",""status"":404,""detail"":""The specified session does not exist.""}). Include request-id header in responses.
- Validate inputs: Sanitize IDs, guard against injection; no file uploads, so no mime guard needed.
- PII masking for logs if session data includes sensitive info.

## Relevant Business Logic

- Verify the session belongs to the specified user to prevent cross-user revocation
- Upon revocation, invalidate the session token, clear any associated caches, and prevent further use (e.g., update session status to 'revoked')
- Trigger audit_event for compliance, logging admin user, target user, session_id, and timestamp in UTC
- If session is tied to active operations (e.g., ongoing orders or payments), ensure no conflicts but log for review
- Support multi-role users: Revocation applies across all roles/sessions
- Integrate with security features: Post-revocation, enforce re-login with email verification or MFA if attempted reuse
- Align with ERP flows: Useful for fraud response (e.g., revoke compromised sessions) or admin maintenance (e.g., bulk session cleanup via related APIs)
- Ensure transactional integrity: Atomic update to session record with soft delete option for archival
- Conflicts (e.g., concurrent revocation) resolved deterministically, posting to ledgers if financial implications (unlikely for sessions)"
48,category,List Categories,Paginated categories,api/categories,get,Employee,Implement GET /api/categories - List Paginated Categories,"## Overview

Deshio is a Laravel-based ERP system for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), and promotions. Other domains cover stores/branches, customers + tags/blacklist, batch-centric inventory with reservations/adjustments/cycle counts/valuation/ledgers, order/order_item states (pending→confirmed→fulfilled|cancelled) with assignment/notes/attachments/promos/taxes/fraud flags, fulfillment via shipments/inter-store dispatch with tracking/scan events/POD and transactional stock movements, returns via RMA (return/return_item) with receive/restock/scrap/refunds/exchanges, payments with intent→capture/void/refund lifecycle and order.payment_status sync, accounting via transaction headers + ledger_entry lines for movements/reversals/reconciliation/export, services/service_order with lifecycle/profitability, integrations for carriers/waybills/rates/tracking/webhooks/notifications (email/SMS), security/identity with user/role/permission/ability/user_role/sessions/email verification/password reset/TOTP MFA + backup codes/API keys, observability/compliance via audit_event/log/request-id/PII masking/health/metrics/queues/caching/etag.

Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines ensure legal transitions for orders/items/dispatch/shipments/returns/payments/cycle counts, with conflicts returning RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data in UTC; soft deletes; EAV for attributes; polymorphic notes/attachments; strict referential links. Design supports deterministic admin assignment, safe reservation/consumption, consistent ledger posting.

This issue implements the 'List Categories' API endpoint, which provides a paginated list of categories from the core catalog entities. Categories are integral to organizing products, supporting attributes, media, and hierarchical structures as per the ERD.

## API Specifications

- **Category:** category
- **Title:** List Categories
- **Description:** Paginated categories
- **Route:** api/categories
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET /api/categories endpoint to return a paginated list of categories
- [ ] Support standard pagination query parameters (e.g., page, per_page)
- [ ] Ensure response includes category details like id, name, parent_id, attributes, and timestamps
- [ ] Apply RBAC checks to restrict access to authenticated employees with appropriate permissions
- [ ] Handle errors per RFC7807 problem+json format for unauthorized access, invalid queries, or server issues
- [ ] Include unit and integration tests covering success, pagination, authentication failure, and edge cases (e.g., no categories)
- [ ] Verify soft deletes are respected (list only active categories)
- [ ] Ensure UTC handling and EAV attributes are properly serialized in responses
- [ ] Add documentation in OpenAPI/Swagger format
- [ ] Performance: Endpoint should handle up to 1000 records efficiently with caching/etag support

## Technical Requirements

- Use Laravel controller (e.g., CategoryController@list) and define route in api.php with middleware stack (auth, RBAC, etc.)
- Implement pagination using Laravel's LengthAwarePaginator or similar, defaulting to 15 items per page
- Query categories from the normalized ERD, joining relevant attributes/media if needed, respecting branch scope if applicable
- Input validation: Sanitize query params (page, per_page, optional filters like search/name/parent_id) using Laravel validation or Form Requests
- Proper error handling: 401 for unauth, 403 for forbidden, 422 for invalid params, 500 for server errors, with problem+json responses
- Response format: JSON with data array (categories), meta (pagination info: current_page, last_page, per_page, total), links (first/last/next/prev)
- Leverage state machines if category status transitions apply (e.g., active/inactive)
- Integrate with observability: Log requests with request-id, audit events for access
- Use Eloquent for ORM, ensuring strict referential integrity and polymorphic relations for notes/attachments if exposed

## Authentication/Authorization Requirements

- Requires 'Employee' authentication via JWT/session/API key
- Apply RBAC: Users must have 'category:read' permission via role/permission/ability mappings
- Enforce active user, email-verified, and 2FA if enabled
- Optional: Branch scope to limit categories to user's assigned branches/stores
- Middleware chain: auth → active user → email-verified → 2FA → RBAC/permission check → branch scope

## Expected Request/Response Format Considerations

**Request:**
GET /api/categories?page=1&per_page=15&search=electronics&parent_id=5

Headers: Accept: application/json, Authorization: Bearer <token>

**Response (200 OK):**
{
  ""data"": [
    {
      ""id"": 1,
      ""name"": ""Electronics"",
      ""slug"": ""electronics"",
      ""parent_id"": null,
      ""description"": ""Electronics category"",
      ""attributes"": { /* EAV serialized */ },
      ""created_at"": ""2023-01-01T00:00:00Z"",
      ""updated_at"": ""2023-01-01T00:00:00Z""
    }
  ],
  ""meta"": {
    ""current_page"": 1,
    ""last_page"": 10,
    ""per_page"": 15,
    ""total"": 150
  },
  ""links"": {
    ""first"": ""/api/categories?page=1"",
    ""last"": ""/api/categories?page=10"",
    ""prev"": null,
    ""next"": ""/api/categories?page=2""
  }
}

**Error Response (e.g., 403):**
{
  ""type"": ""https://tools.ietf.org/html/rfc7231#section-6.5.3"",
  ""title"": ""Forbidden"",
  ""status"": 403,
  ""detail"": ""Insufficient permissions to list categories""
}

Support content-negotiation for versioned APIs, locale/tz for any date fields, and cache headers/etag for performance.

## Relevant Business Logic

- Categories support hierarchical structures (parent_id for subcategories)
- List only non-soft-deleted (active) categories
- Optional filters: search by name/description, filter by parent_id, or attributes
- Ensure consistency with catalog domain: Categories link to products/vendors, but this endpoint focuses on category listing
- No direct stock/financial impacts, but audit access for compliance
- Align with overall design: Deterministic listing, safe queries without side effects, UTC timestamps"
49,category,Create Categorie,Create categorie,api/categories,post,Admin,Implement POST /api/categories for Creating Categories,"## Overview

This GitHub issue is for implementing the API endpoint to create a new category in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.
Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint allows admins to create categories, which are core entities in the catalog domain with support for attributes, media, and hierarchical structures.

## API Specifications

- **Category:** category
- **Title:** Create Categorie
- **Description:** Create categorie
- **Route:** api/categories
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST /api/categories endpoint in Laravel
- [ ] Validate input data for category creation (e.g., name, description, attributes, parent category if hierarchical)
- [ ] Ensure the endpoint creates a new category record with proper associations (e.g., attributes via EAV)
- [ ] Handle soft deletes and UTC storage
- [ ] Return the created category in the response with relevant fields
- [ ] Implement error handling for validation failures using RFC7807 problem+json
- [ ] Add unit and integration tests for the endpoint
- [ ] Verify middleware application (auth, RBAC, input sanitizer, etc.)
- [ ] Test for idempotency and throttling
- [ ] Document the endpoint in API specs

## Technical Requirements

- Use Laravel controller and routes to handle the POST request
- Implement input validation using Laravel's Form Requests or Validator
- Integrate with the normalized ERD for category entity, including attributes (EAV), media associations
- Apply relevant middleware: auth (JWT/API key), RBAC permission checks for admin role, branch scope if applicable, input sanitizer, domain guards
- Handle polymorphic relations for notes/attachments if supported for categories
- Ensure transactional integrity for creation, especially with referential links
- Use state machines if category has lifecycle states (though basic creation may not require)
- Log audit events for category creation
- Support caching/etag for future reads, but focus on creation
- Write comprehensive tests covering success, validation errors, unauthorized access, and edge cases (e.g., duplicate names if enforced)

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have admin role or specific permission for category creation
- Apply active user, email-verified, and 2FA checks if enabled
- Branch scope: Ensure category creation respects store/branch permissions if multi-tenant

## Expected Request/Response Format Considerations

- **Request:** JSON body with fields like { ""name"": ""string"", ""description"": ""string"", ""parent_id"": ""uuid|null"", ""attributes"": [{ ""key"": ""string"", ""value"": ""any"" }], ""is_active"": ""boolean"" }
- Validate required fields (e.g., name), sanitize inputs, limit JSON size
- **Response:** 201 Created with JSON body of the created category { ""id"": ""uuid"", ""name"": ""string"", ... }, including ETag for caching
- Error responses: 400 for validation, 401/403 for auth, 409 for conflicts (e.g., duplicate), all in RFC7807 problem+json format
- Use versioned content-negotiation and locale/tz handling

## Relevant Business Logic

- Categories support hierarchy (parent-child via parent_id)
- Integrate with attributes using EAV for flexible fields/features
- Associate media (e.g., category images) if provided in request
- Enforce referential integrity with products/vendors if linked
- Trigger audit_event for creation
- No direct stock/financial impact, but ensure consistency with catalog domain
- Support promotions/pricing overrides indirectly through category associations
- Handle soft deletes for future archival
- Align with overall design for deterministic operations and safe entity creation"
50,category,Get Categorie,Get by id,api/categories/{id},get,Employee,Implement GET /api/categories/{id} Endpoint for Category Retrieval,"## Context about Deshio ERP

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.
Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

## Overview

Implement the API endpoint to retrieve a specific category by its ID in the Deshio ERP system. This endpoint is part of the catalog domain, allowing authenticated employees to fetch category details, including attributes, media, and related entities as per the normalized ERD.

## API Specifications

- **Category:** category
- **Title:** Get Category
- **Description:** Get by id
- **Route:** api/categories/{id}
- **HTTP Method:** GET
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET endpoint to retrieve a category by ID
- [ ] Ensure the endpoint requires Employee authentication and appropriate RBAC permissions
- [ ] Return the full category object in JSON format, including attributes (EAV), media (e.g., product_image), and related entities like subcategories or vendors if applicable
- [ ] Handle cases where the category ID does not exist, returning a 404 error with RFC7807 problem+json format
- [ ] Apply middleware for auth, RBAC checks, request ID, caching/etag, and branch scope if relevant
- [ ] Ensure response data is in UTC and respects soft deletes (e.g., do not return deleted categories)
- [ ] Add comprehensive unit tests for controller logic, validation, and edge cases (e.g., invalid ID, unauthorized access)
- [ ] Write integration tests covering the full request-response cycle, including authentication
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger)
- [ ] Verify no PII exposure and apply masking if needed
- [ ] Test for performance with caching headers and etag support

## Technical Requirements

- Develop in Laravel: Create or update a CategoryController with a show() method
- Define the route in routes/api.php: Route::get('/categories/{id}', [CategoryController::class, 'show'])->middleware(['auth:employee', 'rbac:view-categories'])
- Use Eloquent ORM for the Category model, leveraging the normalized ERD for relations (e.g., hasMany attributes, media)
- Implement input validation: Ensure {id} is a valid UUID or integer via route model binding or FormRequest
- Handle errors gracefully: Use Laravel exceptions for 404 (ModelNotFoundException) and format as RFC7807 problem+json
- Integrate with state machines if category has lifecycle states (though primarily for read-only GET)
- Support versioned content-negotiation and locale/tz middleware
- Ensure transactional consistency if fetching related data (e.g., inventory ties)
- Add logging for audit_event on access, with request-id correlation
- Use queues/caching if the endpoint involves heavy computations (e.g., promo impact reporting)
- Follow design principles: Deterministic responses, strict referential links, polymorphic relations for notes/attachments

## Authentication/Authorization Requirements

- Authentication: Requires Employee via JWT, session, or API key (as per middleware plan)
- Authorization: RBAC check for 'view-categories' permission, assigned via user/role/permission model
- Additional guards: Active user, email-verified, 2FA if enabled, branch scope (e.g., category visibility per store/branch)
- Throttling and idempotency for repeated requests
- Optional tenancy isolation if multi-tenant setup is active

## Expected Request/Response Format Considerations

- **Request:** GET /api/categories/{id} with authentication headers (e.g., Authorization: Bearer <token>)
  - Path parameter: {id} - Valid category identifier (e.g., UUID or integer)
  - Query params: Optional filters like ?include=attributes,media (using Laravel resource for eager loading)
  - Headers: Accept: application/json, X-Request-ID, X-Locale, etc.

- **Response:** 
  - 200 OK: JSON object representing the category, e.g., {""data"": {""id"": ""uuid"", ""name"": ""Electronics"", ""attributes"": [...], ""media"": [...], ""parent_id"": null, ...}}
  - Use Laravel API Resources for consistent serialization
  - 401 Unauthorized: If auth fails
  - 403 Forbidden: If RBAC denies access
  - 404 Not Found: If category not found or soft-deleted
  - Error format: RFC7807 problem+json, e.g., {""title"": ""Not Found"", ""detail"": ""Category not found"", ""status"": 404}
  - Cache headers: ETag, Last-Modified for conditional GETs

## Relevant Business Logic

- Categories are core catalog entities with hierarchical structure (parent-child), attributes via EAV, and ties to products/vendors
- Fetch should include related data like pricing overrides, promotions if applicable, but avoid over-fetching (use includes)
- Respect inventory and order domains: Categories may influence product availability, reservations, or reporting (e.g., revenue by category)
- Ensure consistency with ledger postings if category changes affect financials (though GET is read-only)
- Support for bulk/search APIs in broader context, but this is single-ID retrieval
- Align with observability: Log access for audits, metrics for endpoint usage
- No state transitions needed for GET, but ensure legality via middleware guards
- Data integrity: UTC timestamps, no PII in category data, referential integrity across junctions"
51,category,Update Categorie,Update by id,api/categories/{id},put,Admin,Implement PUT /api/categories/{id} - Update Category,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the API endpoint for updating a category by ID. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), and promotions. Categories are part of the catalog domain. This endpoint allows admins to update category details, ensuring data integrity with soft deletes for archival, EAV for attributes, and strict referential links.

## API Specifications

- **Category:** category
- **Title:** Update Category
- **Description:** Update by id
- **Route:** api/categories/{id}
- **HTTP Method:** PUT
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint responds to PUT requests on api/categories/{id} with admin authentication
- [ ] Successfully updates category attributes, including name, description, parent category, attributes (EAV), and other relevant fields
- [ ] Validates input data, rejecting invalid or missing required fields (e.g., category name)
- [ ] Handles cases where category ID does not exist, returning appropriate 404 error
- [ ] Ensures referential integrity, preventing updates that would break links to products or sub-categories
- [ ] Applies middleware for TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, JWT/session/API key auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope, throttles, idempotency, input sanitizer, and domain guards
- [ ] Returns updated category in response body on success (201 or 200)
- [ ] Includes proper error handling with RFC7807 problem+json for validation errors, unauthorized access, or conflicts
- [ ] Unit and integration tests cover happy path, edge cases (e.g., updating with invalid attributes), and error scenarios
- [ ] Documentation updated with request/response examples and OpenAPI spec
- [ ] Performance considerations: efficient queries, caching/etag support

## Technical Requirements

- Use Laravel framework: Create or update CategoryController with update method
- Define route in api.php: Route::put('/categories/{id}', [CategoryController::class, 'update'])->middleware(['auth:admin', 'rbac:category.update']);
- Implement input validation using Laravel Form Requests or Validator, supporting bulk updates if applicable, with sanitizer for inputs
- Handle soft deletes: Ensure updates do not affect archived categories
- Integrate with EAV for attributes: Allow updating dynamic fields/features
- Polymorphic relations: Update notes/attachments if associated with category
- Database: UTC storage, transactions for atomic updates
- Observability: Log audit_event for category updates, include request-id, PII masking if applicable
- Queues/caching: Optional background processing for reindexing related products
- Feature flags: Support system maintenance flags for endpoint

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC check: User must have 'category.update' permission via role/permission abilities
- Additional guards: Active user, email-verified, TOTP MFA + backup codes if enabled
- Branch scope: Ensure updates respect multi-branch setup if categories are scoped
- Optional tenancy: Apply if multi-tenant configuration is active

## Expected Request/Response Format Considerations

- **Request:** JSON body with updatable fields, e.g., {""name"": ""Updated Name"", ""description"": ""New desc"", ""parent_id"": 123, ""attributes"": {""color"": ""red""}, ""is_active"": true}. Use idempotency key in header for safe retries.
- **Response (Success):** 200 OK with JSON: {""id"": 123, ""name"": ""Updated Name"", ..., ""updated_at"": ""UTC timestamp""}. Include ETag for caching.
- **Response (Error):** 4xx/5xx with RFC7807 problem+json, e.g., {""title"": ""Validation Error"", ""detail"": ""Name is required"", ""status"": 422, ""type"": ""/errors/validation""}.
- Content negotiation: Versioned API (e.g., /api/v1), locale/tz support, JSON limits enforced.
- Attachments/media: If updating includes media, validate mime types via upload guard.

## Relevant Business Logic

- Categories support hierarchical structure (parent_id), attributes via EAV, and links to products/vendors.
- Updates should trigger reindexing or notifications if impacting catalog search/autosuggest.
- No state machine for categories, but ensure legality: Prevent updates that orphan products or violate promotions/pricing overrides.
- Inventory/orders indirect impact: Updates may affect product categorization in reports/analytics (e.g., revenue by category).
- Compliance: Audit all changes, support bulk import/export consistency, backups/restore compatibility.
- Integrations: Webhooks for category updates if subscribed, notification templates for admin alerts.
- Reporting: Track price change history or activity indirectly through category updates."
52,category,Delete Categorie,Delete by id,api/categories/{id},delete,Admin,Implement DELETE /api/categories/{id} for Category Deletion,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the DELETE /api/categories/{id} endpoint. This endpoint allows admins to delete a category by ID, supporting core entities like product/category/vendor with attributes, media, barcodes, pricing, and promotions. Deshio features inventory batch-centric management with reservations, adjustments, cycle counts, valuation, and ledgers; order domain with states (pending→confirmed→fulfilled|cancelled); fulfillment via shipments and inter-store dispatches; returns via RMA; payments with intent capture/void and refunds; accounting with transaction headers and ledger entries; services with lifecycle; integrations for carriers and webhooks; security with user/role/permission RBAC, sessions, MFA; observability with audits, logs, PII masking; middleware including TLS, CORS, auth (JWT/session/API key), RBAC checks, throttles; reporting/analytics for revenue, LTV, inventory aging; state machines for transitions; bulk import/export; data in UTC with soft deletes, EAV attributes, polymorphic relations; deterministic admin assignment, safe reservations, consistent ledger posting.

The endpoint deletes a category, likely using soft deletes for archival as per Deshio's design.

## API Specifications

- **Category:** category
- **Title:** Delete Category
- **Description:** Delete by id
- **Route:** api/categories/{id}
- **HTTP Method:** DELETE
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint returns 204 No Content on successful deletion
- [ ] Endpoint returns 404 if category ID not found
- [ ] Endpoint returns 403 if user lacks admin permissions
- [ ] Soft delete the category (do not hard delete to maintain archival)
- [ ] Prevent deletion if category has associated products/subcategories (or handle cascade/soft delete appropriately based on business rules)
- [ ] Audit event logged for the deletion (per observability requirements)
- [ ] Input validation for {id} as valid UUID/integer
- [ ] Unit and integration tests cover success, failure, auth, and validation cases
- [ ] Documentation updated for API endpoint
- [ ] Conforms to RFC7807 problem+json for errors
- [ ] Integrates with state machines if category state affects deletion legality
- [ ] Handles branch scope and tenancy if applicable
- [ ] Idempotency support for repeated requests

## Technical Requirements

- Implement in Laravel controller (e.g., CategoryController@destroy)
- Define route in api.php with middleware stack: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards, cache headers
- Use Eloquent model for Category with softDeletes trait
- Input validation via FormRequest or controller validation for {id}
- Proper error handling: 404 for not found, 403 for unauthorized, 409 for conflicts (e.g., associated entities)
- Ensure referential integrity with strict links across junctions; polymorphic notes/attachments if applicable
- Post ledger entry if deletion impacts accounting (unlikely for category, but check)
- Reindex/search autosuggest if deletion affects catalog indexing
- Feature flags for enabling/disabling endpoint if needed
- System maintenance compatibility (e.g., backups/restore)

## Authentication/Authorization Requirements

- Requires Admin authentication (JWT/session/API key)
- RBAC check: user must have 'category.delete' permission or admin role via user_role (multi-role support)
- Active user, email-verified, 2FA if enabled
- Branch scope: ensure user can only delete categories in their scoped branches
- Optional tenancy isolation

## Expected Request/Response Format Considerations

- **Request:** No body; {id} in path (e.g., DELETE /api/categories/123). Headers: Authorization, Accept: application/json, Content-Type: application/json
- **Response:** 
  - Success: 204 No Content
  - Error: 4xx/5xx with JSON body per RFC7807 (e.g., {""type"": ""https://example.com/probs/not-found"", ""title"": ""Not Found"", ""status"": 404, ""detail"": ""Category not found""})
- Data in UTC; ETag/caching headers; request-id for tracing
- PII masking if category data includes sensitive info (unlikely)

## Relevant Business Logic

- Category deletion should consider dependencies: products, subcategories, attributes (EAV), media (product_image), pricing/promotions. Use soft delete to archive; potentially cascade soft deletes or prevent if hard constraints exist
- Trigger audit_event for compliance/observability
- If deletion affects inventory/catalog, propagate to ledgers, reservations, or reporting (e.g., update price change history, promo impact)
- State machine: Ensure category is in deletable state (e.g., not active with live products); return conflict if illegal transition
- Integrations: Notify webhooks if category deletion impacts external systems (e.g., carriers, notifications)
- Supports bulk operations context but this is single ID delete
- Maintains determinism for admin assignments and consistent posting on events"
53,vendor,List Vendors,Paginated vendors,api/vendors,get,Employee,Implement GET /api/vendors - List Vendors Endpoint,"## Overview

As a technical writer creating GitHub issues for API implementation in the Deshio ERP system, this issue covers the development of the 'List Vendors' API endpoint. This endpoint provides a paginated list of vendors, which are core entities in Deshio's normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.
Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint is categorized under 'vendor' and titled 'List Vendors', providing paginated access to vendor data.

## API Specifications

- **Category:** vendor
- **Title:** List Vendors
- **Description:** Paginated vendors
- **Route:** api/vendors
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint returns a paginated list of vendors with standard Laravel pagination structure (e.g., current_page, data, last_page)
- [ ] Supports query parameters for filtering, sorting, and pagination (e.g., ?page=1&per_page=20&search=query&sort=field&direction=asc)
- [ ] Includes vendor attributes, relationships (e.g., products, categories if applicable), and handles soft deletes appropriately
- [ ] Returns RFC7807 problem+json for errors (e.g., 401 Unauthorized, 403 Forbidden, 422 Validation)
- [ ] Integrates with middleware stack including auth, RBAC checks, request ID, throttling, and caching/etag
- [ ] Audit events are logged for access to the endpoint
- [ ] Response includes ETag for caching and proper cache headers
- [ ] Handles branch scope if vendors are scoped to stores/branches
- [ ] Unit and integration tests cover happy path, edge cases (e.g., no vendors, large pagination), and error scenarios
- [ ] Documentation updated with OpenAPI/Swagger specs for the endpoint
- [ ] Performance optimized for large vendor datasets (e.g., eager loading relationships)

## Technical Requirements

- Implement in Laravel using a dedicated Controller (e.g., VendorController@list) and register route in api.php
- Use Eloquent for querying the vendors table, with scope for soft deletes and UTC handling
- Apply input validation using Form Requests or Validator for query params (e.g., pagination limits, search sanitization)
- Leverage state machines if vendor states/transitions apply, though primarily a read endpoint
- Ensure transactional consistency if querying involves related ledgers or inventory ties
- Integrate with reporting/analytics if listing supports metrics like vendor activity or product counts
- Use polymorphic relations for notes/attachments on vendors if applicable
- Handle EAV attributes in response serialization (e.g., via API resources)
- Implement search/autosuggest capabilities if extended from core APIs

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- Enforce RBAC: User must have a role with permission to view vendors (e.g., 'vendor.view')
- Apply active user, email-verified, and 2FA checks via middleware
- Scope to branch/store if vendors are location-specific
- Deny access for non-employee users or insufficient permissions, returning 403

## Expected Request/Response Format Considerations

- **Request:** GET /api/vendors with optional query params:
  - page: integer (default 1)
  - per_page: integer (default 15, max 100)
  - search: string for vendor name/code search
  - sort: string (e.g., 'name', 'created_at')
  - direction: 'asc' or 'desc'
  - filters: e.g., ?status=active&category_id=1 (based on vendor attributes)
- **Response:** 200 OK with JSON:
  {
    ""current_page"": 1,
    ""data"": [
      {
        ""id"": 1,
        ""name"": ""Vendor Name"",
        ""code"": ""VEND001"",
        ""attributes"": {...}, // EAV fields
        ""products_count"": 10, // Optional aggregated
        ""created_at"": ""UTC timestamp"",
        ""updated_at"": ""UTC timestamp""
      }
    ],
    ""last_page"": 5,
    ""per_page"": 20,
    // other pagination fields
  }
- Empty list: data as empty array with pagination info
- Errors: Standard problem+json (e.g., {""type"": ""https://example.com/errors/unauthorized"", ""title"": ""Unauthorized"", ""status"": 401})
- Use API Resources for serialization, including media/images if vendors have them

## Relevant Business Logic

- Vendors are core catalog entities linked to products, categories, and potentially inventory batches
- Support for attributes (EAV), barcodes, pricing overrides, and promotions tied to vendors
- Paginated listing should respect soft deletes (exclude deleted unless ?include_deleted=1 with permission)
- Integrate with observability: Log request-id, audit access events, mask PII in vendor details (e.g., contact info)
- Ensure consistency with order/inventory domains: Vendors may influence product availability or pricing in orders
- No state transitions here, but list may include vendor status (active/inactive) driven by business rules
- Align with integrations: If vendors link to carriers or payments, include relevant flags in response
- Data in UTC; handle locale/tz via middleware for display fields if needed"
54,vendor,Create Vendor,Create vendor,api/vendors,post,Admin,Implement Create Vendor API Endpoint (POST /api/vendors),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue covers the implementation of the 'Create Vendor' API endpoint. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The 'Create Vendor' endpoint allows admins to create a new vendor entity in the catalog domain, integrating with attributes, media, and related features.

## API Specifications

- **Category:** vendor
- **Title:** Create Vendor
- **Description:** Create vendor
- **Route:** api/vendors
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint responds with 201 Created on successful vendor creation
- [ ] Validates required vendor fields (e.g., name, contact details)
- [ ] Handles optional fields like attributes, media, and address
- [ ] Returns 401 Unauthorized for non-admin users
- [ ] Returns 422 Unprocessable Entity for invalid input
- [ ] Integrates with audit logging for creation events
- [ ] Supports EAV attributes for vendor-specific fields
- [ ] Ensures data is stored in UTC with soft delete capability
- [ ] Applies middleware for auth, RBAC, input sanitization, and error handling (RFC7807 problem+json)
- [ ] Writes unit and integration tests covering success, validation errors, and auth failures
- [ ] Documents the endpoint in API specs with request/response examples

## Technical Requirements

- Implement in Laravel: Define route in api.php, create VendorController with store method
- Use Laravel validation for request input, including custom rules for vendor-specific logic
- Handle vendor creation in the Vendor model, leveraging Eloquent relationships (e.g., to attributes, media)
- Integrate with state machines if vendor has lifecycle states (pending→active)
- Ensure transactional database operations for consistency
- Add proper error handling with standardized responses
- Include middleware stack: auth (JWT/API key), RBAC (admin permission), branch scope if applicable, throttles, idempotency
- Log audit events for creation, with request-id and PII masking
- Support bulk creation if extending to imports, but focus on single create for now

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have 'create-vendor' permission via role/permission matrix
- Apply active user, email-verified, and 2FA checks if enabled
- Branch scope: Limit to user's assigned branches if multi-branch setup

## Expected Request/Response Format Considerations

- **Request:** JSON body with fields like {""name"": ""string"", ""email"": ""string"", ""phone"": ""string"", ""address"": {...}, ""attributes"": [...] } (use EAV for custom fields); multipart/form-data if including media uploads
- **Response:** 201 with JSON {""id"": integer, ""name"": ""string"", ..., ""created_at"": ""UTC timestamp"" }; include etag for caching
- **Errors:** 4xx/5xx as RFC7807 problem+json, e.g., {""type"": ""validation_error"", ""title"": ""Invalid data"", ""detail"": {...}}
- Versioned via content-negotiation; support locale/tz from headers

## Relevant Business Logic

- Vendor creation triggers ledger entry if financial attributes are set
- Link to core entities: Associate with products/categories upon creation if specified
- Ensure referential integrity: No duplicate vendors by unique fields (e.g., tax_id)
- Post-creation: Enable hooks for notifications (email/SMS) and webhooks if integrated
- Comply with domain guards: Validate against fraud/blacklist if vendor details match criteria
- Soft delete support: Mark as deleted instead of hard remove for archival"
55,vendor,Get Vendor,Get by id,api/vendors/{id},get,Employee,Implement GET /api/vendors/{id} Endpoint for Vendor Retrieval,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue covers the implementation of the 'Get Vendor' API endpoint. This endpoint retrieves vendor details by ID, supporting core entities like product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), and promotions. Vendors are integral to the catalog domain, enabling deterministic admin assignment and consistent ledger posting for stock/financial events.

Deshio ERP Context:
- Core entities: product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers + tags/blacklist.
- Inventory: batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, ledgers.
- Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
- Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
- Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
- Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
- Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
- Services: service/service_order with lifecycle and profitability.
- Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
- Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
- Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
- Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
- Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
- State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
- APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance.
- Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
- Design enables deterministic admin assignment for online orders, safe reservation/consumption, consistent ledger posting on every stock/financial event.

## API Specifications

- **Category:** vendor
- **Title:** Get Vendor
- **Description:** Get by id
- **Route:** api/vendors/{id}
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint retrieves vendor details by ID, including attributes, media, barcodes, and related pricing/promotions
- [ ] Handles soft deletes by excluding archived vendors or flagging them appropriately
- [ ] Returns 404 if vendor ID not found
- [ ] Applies RBAC permissions for employee access to vendor data
- [ ] Supports EAV attributes and polymorphic relations (e.g., notes/attachments)
- [ ] Includes audit logging for the request via audit_event
- [ ] Validates ID as a valid UUID or integer per Deshio conventions
- [ ] Responds with UTC timestamps and proper JSON structure
- [ ] Integrates with middleware stack: auth (JWT/session/API key), RBAC checks, request-id, caching/etag
- [ ] Tests cover successful retrieval, not found, unauthorized access, and edge cases like soft-deleted vendors
- [ ] Error responses follow RFC7807 problem+json for conflicts or validation issues

## Technical Requirements

- Implement in Laravel: Define route in api.php, create or extend VendorController with show() method
- Use Eloquent for Vendor model retrieval, including relationships (e.g., products, categories)
- Input validation: Ensure {id} is a valid vendor identifier using FormRequest or route model binding
- Proper error handling: 404 for non-existent ID, 403 for insufficient permissions, 401 for unauthenticated
- Authentication/authorization: Require 'Employee' role via RBAC; check permissions for vendor read access; enforce active user, email-verified, 2FA if applicable; branch scope if vendor is store-specific
- Expected request format: Path parameter {id} (e.g., GET /api/vendors/123); no body; query params optional for includes (e.g., ?include=products,attributes)
- Expected response format: JSON object with vendor data, e.g., {""id"": 123, ""name"": ""Vendor Name"", ""attributes"": {...}, ""media"": [...], ""timestamps"": {""created_at"": ""UTC"", ...}}; status 200 OK; use resource classes for transformation
- Business logic: Retrieve vendor with hydrated relations; apply PII masking if vendor data includes sensitive info; generate request-id for observability; support idempotency if queried multiple times; ensure no direct DB queries bypassing middleware
- Integration: Log to audit_event; handle soft deletes with withTrashed() if needed; respect caching/etag for performance; prepare for reporting/analytics (e.g., vendor activity tracking)
- Testing: Unit tests for controller logic, feature tests for full endpoint with auth mocks, integration tests for DB interactions and relations"
56,vendor,Update Vendor,Update by id,api/vendors/{id},put,Admin,Implement PUT /api/vendors/{id} - Update Vendor Endpoint,"## Overview

This GitHub issue is for implementing the 'Update Vendor' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs built over a normalized ERD. It covers domains including catalog (products/categories/vendors with attributes, media like product images, barcodes, pricing with overrides, promotions), stores/branches, customers with tags/blacklists, batch-centric inventory (supporting reservations, adjustments, cycle counts, valuation, ledgers), orders (order/order_item states from pending to confirmed/fulfilled/cancelled, assignment to store, notes/attachments, promos, taxes, fraud flags), fulfillment (shipments/shipment_items, inter-store dispatches with tracking/scan events/POD, transactional stock movements), returns (RMA with return/return_item, receive/restock/scrap, refunds, exchanges), payments (intent to capture/void, refund lifecycle, order payment status sync), accounting (transaction headers + ledger entries for movements, reversals, reconciliation/export), services (service/service_order lifecycle and profitability), integrations (carriers/accounts, waybills/rates/tracking, webhooks, notification templates for email/SMS), security/identity (users/roles/permissions with abilities, multi-role assignments, sessions, email verification, password reset, TOTP MFA + backup codes, API keys), observability/compliance (audit events, logs, request IDs, PII masking, health/metrics, queues, caching/ETag), middleware (TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth via JWT/session/API key, active user, email-verified, 2FA, RBAC/permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards for order/payment/dispatch/reservation/promo/override/cycle-count/fraud, upload MIME guard, provider webhook signatures + replay defense, cache headers), reporting/analytics (revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity), state machines for legal transitions (orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json), bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, strict referential links. Design ensures deterministic admin assignment for online orders, safe reservation/consumption, consistent ledger posting on stock/financial events.

The endpoint allows updating a vendor by ID, focusing on core entities like vendors with attributes (fields/features).

## API Specifications

- **Category:** vendor
- **Title:** Update Vendor
- **Description:** Update by id
- **Route:** api/vendors/{id}
- **HTTP Method:** put
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the PUT /api/vendors/{id} endpoint in the Laravel controller
- [ ] Handle vendor updates including attributes, media, barcodes, pricing overrides, and promotions if applicable
- [ ] Add comprehensive input validation for request body and path parameter (vendor ID)
- [ ] Ensure RBAC checks for Admin authentication and permissions
- [ ] Implement proper error handling, including 404 for non-existent vendors and RFC7807 problem+json for conflicts/state machine violations
- [ ] Write unit and integration tests covering success, validation failures, authorization denials, and edge cases (e.g., soft-deleted vendors)
- [ ] Verify soft deletes and referential integrity are maintained
- [ ] Test idempotency and throttling middleware integration
- [ ] Ensure audit events are logged for the update action
- [ ] Confirm response includes updated vendor data with ETag for caching

## Technical Requirements

- Use Laravel framework for controller, routes, and models (e.g., Vendor model with relationships to attributes, media, etc.)
- Define routes in api.php with proper versioning and content-negotiation
- Implement input validation using Form Requests or Validator, sanitizing inputs and guarding against MIME types if media is updated
- Handle business logic: Update vendor fields, trigger state machine if applicable, post to ledgers if financial changes, maintain referential links (e.g., to products/categories)
- Integrate middleware stack: Auth (Admin JWT/session/API key), RBAC/permission checks, branch scope, idempotency, input sanitizer, domain guards
- Use Eloquent for database operations with UTC timestamps and soft deletes
- For polymorphic relations like notes/attachments, ensure updates propagate correctly
- Add observability: Log request ID, audit events, PII masking if vendor data includes sensitive info

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have role/permission allowing vendor updates (e.g., 'vendor.update' ability)
- Check active user status, email verification, and 2FA if enabled
- Apply branch scope if vendor is branch-specific
- Optional tenancy isolation

## Expected Request/Response Format Considerations

- **Request:** JSON body with updatable vendor fields (e.g., name, attributes via EAV, contact info); path param {id} as UUID/int; headers for auth, locale/tz, idempotency key
- **Response:** 200 OK with updated vendor JSON (including relations like attributes/media if requested via includes); use ETag for caching; errors as RFC7807 problem+json (e.g., 422 validation, 403 unauthorized, 404 not found)
- Support bulk partial updates if specified; ensure deterministic behavior

## Relevant Business Logic

- Vendors are core catalog entities with attributes (field/feature), linked to products/categories
- Updates may affect related entities (e.g., pricing overrides, promotions); trigger ledger entries if financial
- Respect state machines for legality; prevent updates that violate referential integrity or soft deletes
- Ensure safe operations: Reservations/consumption if inventory-linked, consistent posting on events
- Integrate with reporting: Track changes for price history, activity analytics
- Handle attachments/media uploads with MIME guards and storage"
57,vendor,Delete Vendor,Delete by id,api/vendors/{id},delete,Admin,Implement DELETE /api/vendors/{id} for Vendor Deletion,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the 'Delete Vendor' API endpoint. This endpoint allows administrators to delete a vendor by its ID. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), and promotions. Deleting a vendor must consider dependencies such as associated products, orders, and inventory to ensure data integrity. The system uses soft deletes for archival, strict referential links across junctions, and state machines for legality of transitions. Data is stored in UTC, with EAV for attributes and polymorphic notes/attachments. Design enables deterministic admin assignment, safe reservation/consumption, and consistent ledger posting on events.

## API Specifications

- **Category:** vendor
- **Title:** Delete Vendor
- **Description:** Delete by id
- **Route:** api/vendors/{id}
- **HTTP Method:** DELETE
- **Authentication:** Admin

This endpoint is part of the broader API ecosystem supporting bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, and cache headers. Observability covers audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Reporting includes revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, and activity. Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

## Acceptance Criteria

- [ ] Endpoint responds to DELETE requests on /api/vendors/{id}
- [ ] Requires Admin authentication and RBAC permission check for vendor deletion
- [ ] Validates that the vendor ID exists and is not in use (e.g., associated with products, orders, or inventory)
- [ ] Performs soft delete on the vendor record
- [ ] Handles dependencies: prevent deletion if vendor has active associations (e.g., products, shipments, payments); suggest cleanup or return appropriate error
- [ ] Returns 204 No Content on successful deletion, or 404 if vendor not found, 403 if unauthorized, 409 if conflict (e.g., in-use)
- [ ] Logs audit_event for the deletion action
- [ ] Integrates with middleware stack: auth, RBAC, throttles, idempotency, input sanitizer
- [ ] Supports versioned content-negotiation and returns RFC7807 problem+json for errors
- [ ] Includes unit tests for success, failure (not found, unauthorized, conflict), and edge cases
- [ ] Includes integration tests verifying soft delete and referential integrity
- [ ] Documents the endpoint in API specs (e.g., OpenAPI)
- [ ] Ensures no impact on related domains: catalog, orders, inventory, logistics, payments

## Technical Requirements

- Implement in Laravel: Add route to api.php, create or update VendorController with destroy method
- Use Eloquent model for Vendor with softDeletes trait
- Input validation: Ensure {id} is a valid UUID or integer via route model binding
- Authorization: Use Gate or Policy for 'delete' permission on Vendor model, scoped to Admin role
- Business logic: Check for associations (e.g., hasMany products, orders via polymorphic or junctions); if present, return conflict error. On success, soft delete and post to audit ledger if applicable. Handle transactions for consistency.
- Error handling: Use Laravel exceptions, return JSON errors with problem+json format for conflicts/invalid states
- Request format: No body required; path param {id}
- Response format: 204 No Content on success; for errors: 4xx/5xx with JSON { ""type"": ""https://problem+json"", ""title"": ""..."", ""detail"": ""..."", ""status"": 409 } etc.
- Testing: PHPUnit tests covering controller, middleware, model events; mock RBAC and dependencies
- Observability: Add request-id tracing, log deletion events, ensure PII masking if vendor data includes sensitive info
- Integrations: Ensure compatibility with inventory batch-centric model, order states (pending→confirmed→fulfilled|cancelled), fulfillment (shipments/dispatch), returns (RMA), payments (intent→capture), accounting (ledger_entry), services, carriers, webhooks, notifications
- Security: Enforce branch scope if applicable, email-verified, 2FA for admin actions; prevent replay via idempotency keys
- Performance: Use caching/etag where possible; queues for any async post-deletion tasks (e.g., reindex)
- Compliance: Soft delete for archival; maintain referential integrity across ERD"
58,product,List Products,Paginated products,api/products,get,Employee,Implement List Products API Endpoint (GET /api/products),"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This issue is for implementing the 'List Products' API endpoint, which provides paginated access to products in the catalog domain. Products include attributes, media, barcodes, pricing, and promotions as per the core entities.

## API Specifications

- **Category:** product
- **Title:** List Products
- **Description:** Paginated products
- **Route:** api/products
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint returns paginated list of products with relevant fields (e.g., id, name, attributes, media, barcodes, pricing, promotions)
- [ ] Supports standard pagination query parameters (e.g., page, per_page)
- [ ] Includes optional filters for search, category, vendor, store/branch scope, and soft-delete handling
- [ ] Implements RBAC checks to ensure only authorized employees can access
- [ ] Returns RFC7807 problem+json for errors (e.g., unauthorized, validation failures)
- [ ] Integrates with middleware stack (auth, RBAC, branch scope, throttles, etc.)
- [ ] Audit events logged for access
- [ ] Unit and integration tests cover happy path, edge cases, and errors
- [ ] Documentation updated with OpenAPI spec

## Technical Requirements

- Use Laravel controller (e.g., ProductController@index) and define route in api.php
- Leverage Eloquent models for Product with relationships (category, vendor, attributes via EAV, media, barcodes, pricing)
- Implement pagination using LengthAwarePaginator or resource collections
- Apply query optimizations (e.g., eager loading, indexing) for performance
- Handle soft deletes by excluding archived products unless specified
- Ensure UTC handling and locale/tz middleware for any display fields
- Integrate with caching/etag for repeated requests
- Use request-id for observability and logging

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT/session/API key
- Enforce RBAC: User must have permission to view products (e.g., role↔perm via ability)
- Apply branch scope if multi-store context
- Optional: Email-verified, 2FA checks if enabled
- Reject unauthenticated/unauthorized with 401/403 and problem+json

## Expected Request/Response Format Considerations

- **Request:** GET /api/products?page=1&per_page=20&search=term&category_id=123&include=media,attributes (query params for pagination, filters, includes)
- **Response:** 200 OK with JSON array of products in paginated format (data, links, meta); e.g., {""data"": [{ ""id"": 1, ""name"": ""Product"", ""attributes"": {...}, ""media"": [...], ... }], ""links"": {...}, ""meta"": {""current_page"": 1, ... }}
- Use API resources for serialization, respecting PII masking if applicable
- Versioned content-negotiation (e.g., Accept: application/vnd.deshio.v1+json)
- Error responses: RFC7807 format, e.g., {""type"": ""https://problem.deshio.com/validation"", ""title"": ""Invalid Query"", ""detail"": ""..."", ""status"": 422}

## Relevant Business Logic

- Products are core catalog entities linked to categories, vendors, with EAV attributes, product images (media), barcodes, price overrides, and promotions
- Respect store/branch assignments for inventory visibility
- Ensure no exposure of sensitive data (e.g., fraud flags unless permitted)
- Support autosuggest/search integration if filters include query terms
- Align with state machines if product status affects visibility (e.g., active only)
- Transactional consistency for any related ledger entries, though read-only here
- Enable bulk export considerations for large paginated responses"
59,product,Create Product,Create product,api/products,post,Admin,Implement Create Product API Endpoint,"## Overview

This GitHub issue is for implementing the 'Create Product' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint allows admins to create new products, integrating with the catalog domain for attributes, media, barcodes, pricing, and promotions.

## API Specifications

- **Category:** product
- **Title:** Create Product
- **Description:** Create product
- **Route:** api/products
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST /api/products endpoint to create a new product record
- [ ] Support creation with core fields: name, category_id, vendor_id, attributes (EAV), media (product_image), barcodes, pricing (including price_override), and promotions
- [ ] Validate required fields and referential integrity (e.g., valid category and vendor)
- [ ] Handle optional fields like descriptions, specifications, and stock-related info (initial inventory batch if provided)
- [ ] Ensure creation triggers any relevant audit events and logs
- [ ] Return RFC7807 problem+json for validation errors or conflicts (e.g., duplicate barcode)
- [ ] Write unit tests for controller logic, validation, and business rules
- [ ] Write integration tests for end-to-end creation, including database interactions and middleware
- [ ] Verify soft delete support and UTC storage
- [ ] Confirm integration with state machines if applicable (e.g., initial product state)
- [ ] Test authentication and authorization: only Admin role with product creation permission
- [ ] Ensure response includes created product ID and relevant details
- [ ] Handle polymorphic attachments/notes if included in request

## Technical Requirements

- Use Laravel controller (e.g., ProductController@store) and define route in api.php with proper versioning and middleware stack (auth, RBAC, branch scope, input sanitizer, etc.)
- Implement input validation using FormRequest or Validator facade, covering all product fields, EAV attributes, media uploads (mime guard), and referential links
- Proper error handling: 201 Created on success, 422 Unprocessable Entity for validation failures, 403 Forbidden for auth issues, using RFC7807 format
- Integrate with normalized ERD: Create product record, link to category/vendor via foreign keys, store attributes in EAV tables, handle media via polymorphic relations, generate barcodes if needed, set initial pricing/promos
- Business logic: Ensure deterministic creation, safe initial stock reservation if inventory provided, post to accounting ledger if financial aspects (e.g., initial valuation), apply any domain guards (e.g., promo/override validation)
- Authentication/authorization requirements: Require JWT/session/API key auth; verify active user, email-verified, 2FA if enabled; RBAC check for Admin role with 'create-product' permission; apply branch scope if multi-tenant
- Expected request/response format considerations: Request body as JSON with fields like {""name"": ""string"", ""category_id"": int, ""vendor_id"": int, ""attributes"": {}, ""images"": [file uploads or URLs], ""barcodes"": [], ""pricing"": {}} – support multipart for media; Response: 201 with {""id"": int, ""data"": full product object, ""message"": ""Product created successfully""}; Use content-negotiation for JSON, include ETag/cache headers
- Follow middleware plan: Idempotency for duplicate requests, throttles, PII masking in logs, request-id tracing
- Ensure compliance: Audit event on creation, UTC timestamps, soft delete readiness (though not triggered on create)
- Testing: Cover edge cases like invalid references, large media uploads, EAV overflows; Use factories for test data aligned with ERD"
60,product,Get Product,Get by id,api/products/{id},get,Employee,Implement GET /api/products/{id} to Retrieve Product by ID,"## Overview

This GitHub issue is for implementing the 'Get Product' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint retrieves a product by its ID, including related attributes like categories, vendors, media, barcodes, and pricing, ensuring compliance with Deshio's normalized ERD and security middleware.

## API Specifications

- **Category:** product
- **Title:** Get Product
- **Description:** Get by id
- **Route:** api/products/{id}
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET endpoint to retrieve a product by ID
- [ ] Ensure the response includes core product details, attributes, media, barcodes, pricing, and promotions
- [ ] Validate that the product ID exists and handle soft-deleted products appropriately
- [ ] Apply RBAC checks for employee authentication and permissions
- [ ] Return RFC7807 problem+json for errors like invalid ID or unauthorized access
- [ ] Include ETag headers for caching and support idempotency
- [ ] Write unit and integration tests covering success, not found, unauthorized, and validation scenarios
- [ ] Document the endpoint in API specs with request/response examples

## Technical Requirements

- Use Laravel controller (e.g., ProductController@show) and define the route in api.php
- Implement input validation for the {id} parameter (must be a valid UUID or integer)
- Query the product model with eager loading for relations (category, vendor, images, barcodes, prices)
- Handle soft deletes by excluding archived products unless specified
- Integrate with middleware stack: auth (JWT/session/API key), RBAC & permission checks, branch scope, throttles, input sanitizer, cache headers
- Use EAV for dynamic attributes and polymorphic relations for notes/attachments if applicable
- Ensure data is returned in UTC and respects locale/tz from middleware
- Proper error handling with logging (request-id, audit_event) and PII masking

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- Enforce RBAC: User must have a role with permission to view products (e.g., 'product.view')
- Apply branch scope if the product is store-specific
- Optional: Check active user, email-verified, and 2FA status via middleware
- Reject unauthorized requests with 401/403 and problem+json response

## Expected Request/Response Format Considerations

- **Request:** GET /api/products/{id} (path param {id} is required, e.g., UUID)
  No query params needed for basic retrieval; consider optional ?include=relations for eager loading
- **Response (200 OK):** JSON object with product data:
  {
    ""data"": {
      ""id"": ""uuid"",
      ""name"": ""string"",
      ""category"": { ... },
      ""vendor"": { ... },
      ""attributes"": [ ... ] // EAV fields
      ""media"": [ { ""type"": ""product_image"", ... } ],
      ""barcodes"": [ ... ],
      ""pricing"": { ""base_price"": ..., ""overrides"": [ ... ] },
      ""promotions"": [ ... ],
      ""created_at"": ""utc-timestamp"",
      // Soft delete: ""deleted_at"": null or timestamp
    },
    ""meta"": { ""etag"": ""..."" } // For caching
  }
- **Errors:** 404 for not found, 401/403 for auth issues, 422 for invalid ID format
- Use versioned content-negotiation (e.g., Accept: application/vnd.deshio.v1+json)
- Limit response size with JSON limits middleware

## Relevant Business Logic

- Products are core catalog entities linked to categories, vendors, and inventory batches
- Include related data like media (product_image), barcodes, pricing (with overrides), and promotions
- Respect inventory context: If batch-centric, note batch availability but do not fetch full inventory
- Ensure referential integrity with strict links to junctions (e.g., product_category, product_vendor)
- No state machine transitions involved; this is a read-only retrieval
- If product is blacklisted or fraud-flagged (via tags), include flags in response for compliance
- Support for feature flags: Endpoint behavior may vary based on system flags
- Audit the request: Log audit_event for product views by employees"
61,product,Update Product,Update by id,api/products/{id},put,Admin,Implement Update Product API Endpoint (PUT /api/products/{id}),"## Overview

This issue covers the implementation of the 'Update Product' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD. Core entities include products/categories/vendors with attributes (fields/features), media (product_images), barcodes, pricing (price_overrides), and promotions. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The product domain integrates with orders, fulfillment, returns, payments, accounting, services, integrations, security, observability, reporting, and more. State machines ensure legal transitions, conflicts return RFC7807 problem+json. APIs support bulk operations, search, attachments, reindexing, backups, feature flags, and maintenance. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential integrity. Design enables deterministic admin assignment, safe reservations, and consistent ledger posting.

The endpoint allows updating a product by ID, targeting admin users for modifications to product details like attributes, media, barcodes, and pricing.

## API Specifications

- **Category:** product
- **Title:** Update Product
- **Description:** Update by id
- **Route:** api/products/{id}
- **HTTP Method:** put
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint responds to PUT requests on /api/products/{id} with admin authentication
- [ ] Successfully updates product fields such as attributes, media, barcodes, pricing, and promotions
- [ ] Validates input data, rejecting invalid updates (e.g., missing required fields, invalid references)
- [ ] Handles soft deletes and referential integrity checks
- [ ] Returns RFC7807 problem+json for errors (e.g., product not found, unauthorized)
- [ ] Integrates with state machines if applicable (e.g., no illegal transitions)
- [ ] Supports EAV attributes and polymorphic relations (notes/attachments)
- [ ] Includes proper middleware: auth (JWT/session/API key), RBAC & permission checks, input sanitizer, etc.
- [ ] Writes unit/integration tests covering success, validation errors, auth failures, and edge cases
- [ ] Documents request/response schemas in OpenAPI/Swagger
- [ ] Ensures idempotency and request-id tracing

## Technical Requirements

- Implement in Laravel: Define route in api.php, create/update ProductController method
- Use Eloquent models for Product entity, handling relations (e.g., categories, vendors, images, barcodes)
- Apply Request validation class with rules for updatable fields (e.g., name, description, attributes as EAV)
- Handle file uploads for media (product_images) with mime guards
- Update related ledgers if pricing changes affect inventory/valuation
- Use transactions for atomic updates across related tables (e.g., price_overrides, promotions)
- Cache invalidation for product searches/autosuggest if updated
- Error handling: 404 for non-existent ID, 403 for insufficient permissions, 422 for validation
- Logging: Audit events for product updates, PII masking if applicable
- Performance: Eager load relations, use etags/caching headers

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC check: User must have 'update-product' permission via role/permission abilities
- Active user and email-verified middleware
- Optional 2FA/TOTP if enabled
- Branch scope if product is store-specific
- Idempotency key support to prevent duplicate updates

## Expected Request/Response Format Considerations

- **Request:** JSON body with partial updates (e.g., {""name"": ""Updated Name"", ""attributes"": {""color"": ""red""}, ""price"": 29.99}). Support multipart for media uploads. Use PUT for full/partial update semantics.
- **Response:** 200 OK with updated product JSON (including relations if requested via ?include=category,vendor). Include etag for caching. Errors as problem+json (e.g., {""type"": ""https://example.com/probs/validation"", ""title"": ""Invalid Data"", ""detail"": ""..."", ""status"": 422}).
- Versioned via content-negotiation (e.g., Accept: application/vnd.deshio.v1+json)
- Locale/tz from headers for any date fields

## Relevant Business Logic

- Updates must respect product states (e.g., cannot update active products in certain order contexts without reservations)
- Pricing updates trigger price change history logging and potential promo impacts
- Attribute updates (EAV) allow dynamic fields/features without schema changes
- Media updates: Handle product_image uploads, deletions, with referential links
- Barcodes/pricing/promotions: Validate against vendors/categories, apply overrides
- Integrations: Notify webhooks if update affects inventory/orders (e.g., low stock alerts)
- Compliance: Soft delete prevention for archival; audit trails for all changes
- Conflicts: Use state machines to block illegal updates (e.g., via domain guards for reservations/promo/override)
- Reporting: Ensure updates reflect in analytics (e.g., price history, inventory aging)"
62,product,Delete Product,Delete by id,api/products/{id},delete,Admin,Implement DELETE /api/products/{id} Endpoint for Admin,"## Overview

This GitHub issue tracks the implementation of the 'Delete Product' API endpoint in the Deshio ERP system. This endpoint allows authorized Admin users to delete a product by its ID. Deletion should follow the system's soft delete policy for archival purposes, ensuring referential integrity across related entities like inventory, orders, and media. The implementation must adhere to Deshio's REST API standards, including state machines, middleware, and error handling as per the system's design.

## System Context

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.
Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

## API Specifications

- **Category:** product
- **Title:** Delete Product
- **Description:** Delete by id
- **Route:** api/products/{id}
- **HTTP Method:** delete
- **Authentication:** Admin

## Authentication/Authorization Requirements

- Requires Admin role via RBAC (user/role/permission with ability checks).
- Apply middleware stack: auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, throttles, idempotency, input sanitizer.
- Ensure the user has permission to delete products (e.g., 'product.delete' permission).
- Return 403 Forbidden if unauthorized.

## Expected Request/Response Format Considerations

- **Request:** DELETE /api/products/{id} (path parameter 'id' as UUID or integer; no request body).
- **Response:** 
  - Success: 204 No Content (soft delete performed).
  - Not Found: 404 Not Found (with RFC7807 problem+json if product ID does not exist).
  - Unauthorized: 401 Unauthorized.
  - Forbidden: 403 Forbidden.
  - Validation Error: 422 Unprocessable Entity (e.g., invalid ID format).
- Use versioned content-negotiation, cache headers, and request-id.
- All data in UTC; responses in JSON.

## Relevant Business Logic

- Implement soft delete on the Product model to maintain archival (use Laravel's SoftDeletes trait).
- Before deletion, validate that the product is not in use (e.g., no active orders, inventory batches, or shipments referencing it; use strict referential links).
- If deletion is blocked (e.g., due to dependencies), return 409 Conflict with details.
- Trigger audit_event for the deletion action.
- Handle cascades: Remove or soft-delete related media (product_image), attributes, barcodes, pricing overrides, and promotions.
- Ensure transactional integrity; rollback if ledger posting or stock movements fail.
- No impact on state machines unless product is tied to ongoing orders/fulfillments.
- Post-deletion, update related reporting/analytics (e.g., inventory aging, price history).

## Acceptance Criteria

- [ ] Endpoint responds to DELETE /api/products/{id} with proper HTTP status codes.
- [ ] Authentication and authorization enforced for Admin users only.
- [ ] Soft delete implemented on Product entity with cascade handling for related data (media, attributes, etc.).
- [ ] Validation for product ID (must exist and be deletable; no active dependencies).
- [ ] Error responses follow RFC7807 problem+json format for conflicts, not found, etc.
- [ ] Middleware applied: auth, RBAC, throttling, idempotency, etc.
- [ ] Audit event logged on successful deletion.
- [ ] No data loss or referential integrity violations.
- [ ] Integration with broader system (e.g., no impact on orders/inventory if soft-deleted).
- [ ] Handles edge cases: non-existent ID, unauthorized access, concurrent requests.

## Technical Requirements

- Use Laravel controller (e.g., ProductController@destroy) and define route in api.php.
- Input validation: Ensure {id} is valid (e.g., UUID/integer) using FormRequest or validator.
- Implement proper error handling with exceptions (e.g., ModelNotFoundException for 404).
- Add unit tests for controller logic, authorization, and validation.
- Add feature tests for full endpoint flow, including middleware and responses.
- Ensure compatibility with EAV attributes, polymorphic relations, and soft deletes.
- Integrate with observability: log requests, add metrics for deletion events.
- Follow Deshio standards: UTC timestamps, PII masking if applicable, queueable if needed for post-deletion tasks."
63,field,List Fields,Paginated fields,api/fields,get,Employee,Implement List Fields API Endpoint (GET /api/fields),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the 'List Fields' API endpoint. This endpoint provides paginated access to fields, which represent attributes (fields/features) for core entities like products, categories, and vendors. Deshio supports EAV for attributes, polymorphic notes/attachments, strict referential links, and state machines for legality transitions. Data is stored in UTC with soft deletes for archival. Middleware includes TLS/HSTS, CORS, auth (JWT/session/API key), RBAC & permission checks, branch scope, throttles, idempotency, input sanitizer, and more. This endpoint falls under the 'field' category and enables listing of these configurable attributes.

## API Specifications

- **Route:** api/fields
- **Method:** get
- **Authentication:** Employee
- **Category:** field
- **Description:** Paginated fields

## Acceptance Criteria

- [ ] Endpoint returns paginated list of fields with standard pagination metadata (e.g., current_page, last_page, per_page, total)
- [ ] Supports query parameters for filtering, sorting, and searching fields (e.g., ?search=term&sort=created_at&direction=desc&per_page=25)
- [ ] Handles authentication for Employee users via RBAC, ensuring only authorized roles/permissions can access
- [ ] Returns appropriate HTTP status codes: 200 for success, 401/403 for auth issues, 422 for validation errors
- [ ] Implements proper error handling with RFC7807 problem+json for conflicts or invalid states
- [ ] Includes unit/integration tests covering happy path, edge cases, pagination, auth failures, and error scenarios
- [ ] Documents the endpoint in API specs (e.g., OpenAPI/Swagger) with request/response examples
- [ ] Ensures response includes relevant field details like id, name, type, entity_type (product/category/vendor), is_required, options (for select types), created_at, updated_at
- [ ] Applies middleware stack: RequestId, JSON limits, versioned content-negotiation, locale/tz, auth, active user, email-verified, 2FA, RBAC, branch scope, throttles, idempotency, input sanitizer
- [ ] Supports bulk operations considerations if extensible, but focuses on list for now

## Technical Requirements

- Use Laravel controller (e.g., FieldController@index) and define route in api.php with appropriate middleware
- Implement pagination using Laravel's LengthAwarePaginator or resource collection
- Leverage Eloquent models for Field entity, with relationships to entities (e.g., belongsTo Product/Category/Vendor if applicable)
- Apply query scopes for soft deletes, UTC handling, and any branch scoping
- Use Laravel's validation for query params (e.g., Request validation rules for search, sort, per_page)
- Handle business logic: Fields as EAV attributes; ensure list respects permissions via RBAC (user/role/permission with ability checks)
- Integrate with observability: audit_event logging for access, request-id tracing, PII masking if fields contain sensitive data
- Optimize for performance: Use eager loading, indexing on searchable fields, caching/etag if applicable
- Ensure compatibility with reporting/analytics if fields impact catalog queries

## Authentication/Authorization Requirements

- Requires Employee authentication (JWT/session/API key)
- RBAC enforcement: User must have role/permission allowing field read access (e.g., 'view-fields' permission linked via role↔perm and user_role)
- Additional checks: Active user, email-verified, TOTP MFA if enabled, branch scope to limit to user's branches
- Reject unauthorized access with 403 Forbidden and problem+json detail

## Expected Request/Response Format Considerations

- **Request:** GET /api/fields with optional query params: ?page=1&per_page=15&search=keyword&sort=name&direction=asc&entity_type=product
  - No request body
  - Validate params: per_page (1-100), sort (whitelisted fields), direction (asc/desc)

- **Response:** 200 OK, JSON with pagination wrapper
  ```json
  {
    ""data"": [
      {
        ""id"": 1,
        ""name"": ""color"",
        ""type"": ""select"",
        ""entity_type"": ""product"",
        ""is_required"": true,
        ""options"": [""red"", ""blue""],
        ""created_at"": ""2023-01-01T00:00:00Z"",
        ""updated_at"": ""2023-01-01T00:00:00Z""
      }
    ],
    ""current_page"": 1,
    ""last_page"": 1,
    ""per_page"": 15,
    ""total"": 1
  }
  ```
- Error responses: Use consistent problem+json format, e.g., 422 { ""type"": ""validation_error"", ""title"": ""Invalid Query"", ""detail"": ""Invalid sort field"" }
- Headers: Include cache headers, ETag if caching enabled, X-Request-Id

## Relevant Business Logic

- Fields define attributes for catalog entities (product/category/vendor); support types like text, select, number, with options for selects
- Paginated to handle large datasets efficiently
- Integrate with state machines if field changes trigger transitions (e.g., product validation)
- Ensure consistency with core policies: No criminal assistance, resist jailbreaks (though not directly applicable here)
- Align with Deshio's design: Deterministic operations, safe data handling, ledger posting if fields impact financials (unlikely for list)"
64,field,Create Field,Create field,api/fields,post,Admin,Implement Create Field API Endpoint (POST /api/fields),"## Overview

This issue covers the implementation of the 'Create Field' API endpoint for the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD that spans catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (fields/features), media (product_image), barcodes, pricing (price_override), and promotions. Fields are part of the attribute system using EAV (Entity-Attribute-Value) for flexible product/category/vendor attributes. This endpoint allows admins to create new fields, enabling dynamic attribute management. Data is stored in UTC, with soft deletes for archival and strict referential integrity.

The endpoint supports the overall middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, cache headers. State machines ensure legality of transitions where applicable, with conflicts returning RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

## API Specifications

- **Category:** field
- **Title:** Create Field
- **Description:** Create field
- **Route:** api/fields
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint responds with 201 Created on successful field creation
- [ ] Validate required input fields (e.g., name, type, entity_type) and return 422 Unprocessable Entity for invalid data
- [ ] Ensure only authenticated Admin users can access the endpoint
- [ ] Handle soft deletes and referential integrity for the new field
- [ ] Return appropriate error responses using RFC7807 problem+json for conflicts or unauthorized access
- [ ] Include proper caching/ETag headers and request-id tracing
- [ ] Write unit and integration tests covering success, validation failure, and authorization scenarios
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger)

## Technical Requirements

- Implement in Laravel: Define route in api.php, create a dedicated controller (e.g., FieldController@store) with proper resource handling
- Use Laravel validation for request input (e.g., 'name' => 'required|string|max:255', 'type' => 'required|in:text,number,date,boolean,etc.', 'entity_type' => 'required|in:product,category,vendor')
- Integrate EAV storage: Model Field with relationships to entities; use polymorphic or junction tables for attribute linking
- Apply middleware stack: auth, rbac (admin permission check), input sanitizer, idempotency (if applicable for creates)
- Error handling: Use try-catch for database exceptions, return standardized JSON errors with PII masking
- Logging: Record audit_event for field creation, include request-id
- Performance: Use queues if creation involves heavy processing (e.g., reindexing); add metrics for observability

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC check: User must have 'create-field' permission tied to admin role
- Enforce active user, email-verified, and 2FA (if enabled)
- Branch scope: Fields may be global or scoped; validate based on user permissions
- Optional tenancy isolation if multi-tenant mode is active

## Expected Request/Response Format Considerations

- **Request Body (JSON):** {
  ""name"": ""string (required, unique per entity_type)"",
  ""type"": ""string (required, e.g., 'text', 'number', 'date', 'boolean', 'select')"",
  ""entity_type"": ""string (required, e.g., 'product', 'category', 'vendor')"",
  ""description"": ""string (optional)"",
  ""is_required"": ""boolean (optional, default false)"",
  ""default_value"": ""mixed (optional, based on type)"",
  ""options"": ""array (optional, for select/multiselect types)""
}
- **Success Response (201):** {
  ""data"": {
    ""id"": ""uuid/int"",
    ""name"": ""string"",
    ""type"": ""string"",
    ... (full field object)
  },
  ""message"": ""Field created successfully""
}
- **Error Response (e.g., 422):** {
  ""type"": ""https://tools.ietf.org/html/rfc7231#section-6.5.1"",
  ""title"": ""Validation Error"",
  ""detail"": ""The given data was invalid."",
  ""errors"": { ... }
}
- Support content-negotiation for JSON; use ETag for conditional requests

## Relevant Business Logic

- Fields enable dynamic attributes for core entities (product/category/vendor); creation should trigger any necessary reindexing or cache invalidation for search/autosuggest
- Ensure field names are unique per entity_type to avoid conflicts in EAV storage
- Integrate with promotions/pricing if field affects overrides (e.g., custom price fields)
- Post-creation, fields can be used in bulk import/export and reporting (e.g., analytics on attribute-based revenue)
- Maintain audit trail: Log creation event with user_id, timestamp (UTC), and changes
- Conflicts (e.g., duplicate name) should prevent creation and notify via problem+json; no state machine needed for simple create, but ensure transactional DB operations"
65,field,Get Field,Get by id,api/fields/{id},get,Employee,Implement GET /api/fields/{id} for Field Retrieval,"## Overview

This GitHub issue is for implementing the 'Get Field' API endpoint in the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs over a normalized ERD. The ERD covers domains including catalog (products/categories/vendors with attributes like fields/features, media such as product images, barcodes, pricing with overrides, promotions), stores/branches, customers with tags/blacklists, inventory (batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, ledgers), orders (order/order_item states from pending to confirmed/fulfilled/cancelled, assignment to store, notes/attachments, promos, taxes, fraud flags), fulfillment (shipments/shipment_items, inter-store dispatch with tracking/scan events/POD, transactional stock movements), returns (RMA with return/return_items, receive/restock/scrap, refunds, exchanges), payments (intent to capture/void, refund lifecycle, order payment status sync), accounting (transaction headers + ledger entries for movements, reversals, reconciliation/export), services (service/service_order lifecycle and profitability), integrations (carriers/accounts, waybills/rates/tracking, webhooks, notification templates for email/SMS), security/identity (user/role/permission with abilities and multi-roles, sessions, email verification, password reset, TOTP MFA + backup codes, API keys), observability/compliance (audit events, logs, request-id, PII masking, health/metrics, queues, caching/etag), middleware (TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth via JWT/session/API key, active user, email-verified, 2FA, RBAC/permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards for order/payment/dispatch/reservation/promo/override/cycle-count/fraud, upload mime guard, provider webhook signatures + replay defense, cache headers), reporting/analytics (revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity), state machines for legal transitions (orders, items, dispatch, shipments, returns, payments, cycle counts with RFC7807 problem+json on conflicts), bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, strict referential links. Design supports deterministic admin assignment, safe reservation/consumption, consistent ledger posting.

The endpoint retrieves a specific field (attribute for entities like products/categories/vendors) by its ID, ensuring proper authentication, authorization, and integration with the system's RBAC and observability features.

## API Specifications

- **Category:** field
- **Title:** Get Field
- **Description:** Get by id
- **Route:** api/fields/{id}
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET /api/fields/{id} endpoint to retrieve a field by ID
- [ ] Ensure the endpoint requires Employee authentication and appropriate RBAC permissions
- [ ] Validate the {id} path parameter as a valid integer/UUID and handle invalid cases with proper errors
- [ ] Return the field details if found, or a 404 Not Found response if not
- [ ] Include audit logging for the request via audit_event
- [ ] Apply middleware stack: auth (JWT/session/API key), active user, email-verified, 2FA, RBAC/permission checks, branch scope, throttles, input sanitizer, RequestId, etc.
- [ ] Handle soft deletes: do not return deleted fields
- [ ] Support EAV attributes if the field is part of an EAV structure
- [ ] Write unit/integration tests covering success, not found, unauthorized, invalid ID, and permission denied scenarios
- [ ] Ensure response includes caching/etag headers and request-id
- [ ] Verify integration with state machines if field updates affect entity states (e.g., product attributes)
- [ ] Test for PII masking if field contains sensitive data

## Technical Requirements

- Use Laravel framework: Define route in api.php, create/implement FieldController with show() method
- Leverage Eloquent model for Field entity, assuming relations to parent entities (e.g., product/category/vendor)
- Implement input validation using Form Requests or controller validation for {id} (e.g., required|integer|exists:fields,id)
- Handle exceptions with proper error responses in RFC7807 problem+json format for conflicts/invalid states
- Integrate with observability: Log requests, emit metrics, use queues if needed for background tasks
- Ensure data in UTC, polymorphic relations if fields have notes/attachments
- Add API documentation (e.g., OpenAPI/Swagger annotations)
- Consider bulk/search extensions if this endpoint evolves, but focus on single retrieval
- Use feature flags for optional behaviors like tenancy

## Authentication/Authorization Requirements

- Requires Employee authentication (via JWT, session, or API key)
- Enforce RBAC: User must have role/permission allowing field read access (e.g., via ability checks on user_role and role↔perm)
- Apply branch scope if fields are scoped to stores/branches
- Optional: Enforce email verification, 2FA (TOTP + backups), active user status
- On failure, return 401 Unauthorized or 403 Forbidden with problem+json details

## Expected Request/Response Format Considerations

- **Request:** GET /api/fields/{id} with path parameter {id} (e.g., integer ID). No body. Headers: Authorization (Bearer/JWT), Accept: application/json, X-Request-Id, etc.
- **Response (200 OK):** JSON object representing the field, e.g., {""id"": 1, ""name"": ""color"", ""type"": ""string"", ""entity_type"": ""product"", ""value"": ""red"", ""created_at"": ""UTC timestamp"", ...} including relations if applicable (e.g., media, parent entity links). Use resource classes for transformation.
- **Error Responses:** 400 Bad Request (invalid ID), 401 Unauthorized, 403 Forbidden, 404 Not Found, 429 Too Many Requests. All in problem+json: {""type"": ""RFC7807 URI"", ""title"": ""Error title"", ""status"": 404, ""detail"": ""Field not found"", ""instance"": ""/api/fields/999""}.
- Versioned via content-negotiation (e.g., Accept: application/vnd.deshio.v1+json)
- Locale/tz from headers for any formatted fields

## Relevant Business Logic

- Fields are core attributes (field/feature) for catalog entities (product/category/vendor), stored in EAV for flexibility.
- Retrieval should respect referential integrity and soft deletes.
- If field is part of pricing/promos/attributes, ensure no exposure of sensitive data without permissions.
- Trigger audit_event on successful retrieval for compliance.
- Integrate with domain guards: Prevent access if field relates to fraud-flagged or restricted entities.
- Support for attachments/polymorphic notes if fields have them.
- Ensure consistency with inventory/orders if field affects stock/pricing (e.g., via reservations or ledger postings)."
66,field,Update Field,Update by id,api/fields/{id},put,Admin,Implement Update Field API Endpoint (PUT /api/fields/{id}),"## Overview

This GitHub issue covers the implementation of the 'Update Field' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD that includes catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain handles order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, and fraud flags. Fulfillment involves shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns manage RMA (return/return_item), receive/restock/scrap, refunds, and exchanges (exchange_order). Payments cover intent→payment capture/void; refund lifecycle; and order.payment_status synchronization. Accounting includes transaction headers + ledger_entry lines for all movements; reversals; and reconciliation/export. Services handle service/service_order with lifecycle and profitability. Integrations include carriers & accounts, waybills/rates/tracking; webhooks with deliveries; and notification templates (email/SMS). Security & identity features user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; and API keys. Observability & compliance involve audit_event, log, request-id, PII masking, health/metrics, queues, and caching/etag. Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, and cache headers. Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, and activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, and cycle counts; conflicts return RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; and strict referential links across all junctions. The design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint specifically allows updating a field (attribute/feature) by ID, which is part of the catalog management for entities like products, categories, and vendors.

## API Specifications

- **Category:** field
- **Title:** Update Field
- **Description:** Update by id
- **Route:** api/fields/{id}
- **Method:** put
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the PUT /api/fields/{id} endpoint to update field details
- [ ] Ensure the endpoint requires Admin authentication and handles unauthorized access appropriately
- [ ] Validate input data, including the field ID and update payload, with proper error responses for invalid inputs
- [ ] Update the field entity in the database, respecting soft deletes and EAV structure for attributes
- [ ] Return the updated field data in the response or a success message
- [ ] Handle cases where the field ID does not exist (e.g., 404 Not Found)
- [ ] Integrate with state machines if field updates affect entity legality or transitions
- [ ] Add comprehensive unit and integration tests for success, failure, validation, and authorization scenarios
- [ ] Ensure compliance with middleware: auth, RBAC, input sanitizer, and error handling per RFC7807
- [ ] Document the endpoint in API specs, including request/response examples
- [ ] Verify audit logging for field updates

## Technical Requirements

- Use Laravel framework: Define the route in api.php, create or update a FieldsController with an update method
- Implement input validation using Laravel's Form Requests or Validator, covering required fields like name, type, entity_type (e.g., product/category/vendor), and optional attributes
- Handle database updates via Eloquent models for the Field entity, ensuring referential integrity with related entities (e.g., product/category/vendor)
- Apply soft deletes if the field supports archival; use EAV for dynamic attributes
- Integrate with polymorphic relations for notes/attachments if applicable to fields
- Use UTC for all timestamps; ensure data normalization per ERD
- Add proper error handling: Return JSON errors in RFC7807 problem+json format for conflicts or invalid states
- Consider caching/etag for field data if frequently accessed
- Implement idempotency if updates should be safe to retry

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: Only users with 'admin' role or specific 'field.update' permission can access
- Include middleware stack: auth, active user, email-verified, 2FA (if enabled), RBAC & permission checks, branch scope (if multi-tenant)
- Reject unauthorized requests with 401/403 responses

## Expected Request/Response Format Considerations

- **Request:** JSON body with partial updates, e.g., {""name"": ""Updated Name"", ""type"": ""string"", ""entity_type"": ""product"", ""options"": {...}}
  - Use PUT for full/partial updates; validate against field schema (e.g., type constraints)
  - Path parameter: {id} must be a valid UUID or integer for the field
- **Response:** 
  - Success (200 OK): JSON of updated field, e.g., {""id"": 1, ""name"": ""Updated Name"", ...} or {""message"": ""Field updated successfully""}
  - Errors: 400 Bad Request for validation failures, 404 for non-existent ID, 403 for unauthorized, 422 Unprocessable Entity for business rule violations
- Content negotiation: Versioned API (e.g., /v1/fields/{id}), JSON only, with cache headers
- Request ID for tracing; PII masking if field contains sensitive data

## Relevant Business Logic

- Fields represent attributes/features for core entities (product/category/vendor); updates should not break existing data integrity or referential links
- If the field is in use (e.g., assigned to products), validate changes to prevent data loss; potentially trigger reindex or notifications
- Ensure updates align with state machines: e.g., if field change affects order/promo legality, enforce transitions
- Post-update, potentially sync to ledgers if pricing-related, or trigger webhooks for integrations
- Support bulk considerations if this ties into import/export APIs; handle concurrency with locks for shared fields
- Maintain audit_event logs for all changes, including who updated and when"
67,field,Delete Field,Delete by id,api/fields/{id},delete,Admin,Implement Delete Field API Endpoint (DELETE /api/fields/{id}),"## Overview

This GitHub issue is for implementing the Delete Field API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The Delete Field endpoint allows administrators to delete a specific field (attribute/feature) by its ID, supporting the catalog management in Deshio ERP. Fields are part of the EAV model for product/category/vendor attributes. Use soft deletes for archival purposes.

## API Specifications

- **Category:** field
- **Title:** Delete Field
- **Description:** Delete by id
- **Route:** api/fields/{id}
- **HTTP Method:** delete
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the DELETE endpoint to soft-delete a field by ID
- [ ] Ensure the endpoint returns 204 No Content on successful deletion
- [ ] Handle 404 Not Found if the field ID does not exist
- [ ] Validate that the field is not in use (e.g., referenced in products/categories) and return appropriate error if it is, using RFC7807 problem+json
- [ ] Add unit and integration tests for success, not found, and validation error scenarios
- [ ] Verify audit logging for the deletion event
- [ ] Ensure soft delete is used, preserving data for archival
- [ ] Test RBAC: only Admin users can access
- [ ] Confirm middleware application: auth, RBAC checks, input sanitizer, etc.
- [ ] Document the endpoint in API specs

## Technical Requirements

- Use Laravel controller (e.g., FieldController@destroy) and define route in api.php
- Implement soft deletes on the Field model (use HasSoftDeletes trait)
- Input validation: Ensure {id} is a valid UUID or integer; no request body expected
- Proper error handling: Use Laravel exceptions for 404, validation errors; return RFC7807 for business rule violations (e.g., field in use)
- Integrate with state machines if applicable (though delete may not transition states)
- Ensure transactional integrity if deletion affects related EAV data
- Add observability: Log request-id, audit_event for deletion
- Follow Deshio standards: UTC timestamps, EAV handling, polymorphic relations if needed

## Authentication/Authorization Requirements

- Require Admin authentication via JWT/session/API key
- Apply RBAC: User must have 'delete-field' permission or equivalent Admin role
- Enforce active user, email-verified, 2FA if enabled
- Include branch scope if fields are scoped (though likely global for catalog)
- Use middleware stack: auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope

## Expected Request/Response Format Considerations

- **Request:** No body; path parameter {id} (e.g., DELETE /api/fields/123)
- **Response:** 
  - Success: 204 No Content
  - Error: 401 Unauthorized (auth failure), 403 Forbidden (insufficient perms), 404 Not Found (id invalid/missing), 422 Unprocessable Entity (validation), or RFC7807 problem+json for business errors (e.g., ""Field cannot be deleted as it is referenced by active products"")
- Versioned content-negotiation: Support API versioning
- Cache headers: No caching for DELETE
- Idempotency: Support if re-DELETE on same ID

## Relevant Business Logic

- Fields represent attributes/features in the EAV model for core entities (product/category/vendor)
- Deletion should check referential integrity: Prevent hard delete if field is used in existing records; use soft delete to archive
- Trigger audit_event for compliance
- If deletion cascades or affects pricing/promotions/barcodes, ensure ledger posting or reversals if financial impact
- Align with design principles: Deterministic operations, safe data handling, consistent posting on events"
68,feature,Attach Feature,Set a field value for product,api/products/{id}/features,post,Admin,Implement API: POST /api/products/{id}/features - Attach Feature,"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint implements the 'Attach Feature' functionality, which sets a field value for a product within the catalog domain, utilizing the EAV (Entity-Attribute-Value) model for product attributes (fields/features).

## API Specifications

- **Category:** feature
- **Title:** Attach Feature
- **Description:** Set a field value for product
- **Route:** api/products/{id}/features
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint handles POST requests to attach a feature (set field value) for a specified product ID
- [ ] Validates that the product exists and is not soft-deleted
- [ ] Ensures the feature/field is valid within the product's category or vendor attributes
- [ ] Supports EAV storage for dynamic attributes
- [ ] Returns appropriate success response with updated feature data
- [ ] Handles errors per RFC7807 problem+json for invalid inputs, unauthorized access, or conflicts
- [ ] Integrates with audit logging for the feature attachment event
- [ ] Includes unit and integration tests covering happy path, validation failures, and authorization
- [ ] Endpoint is versioned and follows content-negotiation
- [ ] Applies middleware for auth, RBAC, input sanitization, and idempotency

## Technical Requirements

- Implement in Laravel: Define route in api.php, create or update ProductsController with attachFeature method
- Use Eloquent models for Product and Feature/Attribute (EAV junction)
- Input validation: Request body should include 'field_id' (or similar), 'value', and optional metadata; use FormRequest for validation rules (e.g., field exists, value type matches field type)
- Business logic: Attach feature via polymorphic or junction table; trigger state machine if applicable; post to audit_event and potentially update related entities like pricing or promotions if feature impacts them
- Error handling: 404 for non-existent product, 403 for insufficient permissions, 422 for validation errors, 409 for conflicts (e.g., duplicate feature)
- Observability: Log request-id, audit the change, invalidate relevant caches (e.g., product search index)
- Follow Deshio standards: UTC timestamps, soft deletes, referential integrity

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC check: User must have 'admin' role or specific permission (e.g., 'products.features.attach') via ability (role↔perm)
- Additional checks: Active user, email-verified, 2FA if enabled, branch scope if applicable
- Middleware stack: auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope

## Expected Request/Response Format Considerations

- **Request:** JSON body, e.g., {""field_id"": 123, ""value"": ""some_value"", ""metadata"": {}} ; {id} path param as UUID/int for product
- **Response:** 201 Created with JSON body containing updated product features or success message, e.g., {""success"": true, ""product_id"": 123, ""attached_feature"": {...}} ; Use ETag for caching if applicable
- Headers: Accept application/json+problem for errors; Cache-Control headers
- Versioning: /api/v1/products/{id}/features

## Relevant Business Logic

- Features are part of product attributes (field/feature) in the catalog domain
- Supports dynamic EAV for extensibility without schema changes
- Ensure transactional integrity: Rollback if attachment fails due to constraints
- Integrate with reporting: Track feature changes for analytics like price change history if relevant
- Conflicts: Use state machines for legality; return problem+json for invalid transitions
- Post-attachment: Potentially trigger reindex for search/autosuggest, or notify via webhooks if feature impacts promotions/inventory"
69,feature,Remove Feature,Remove product feature,api/products/{id}/features/{feature_id},delete,Admin,Implement DELETE /api/products/{id}/features/{feature_id} to Remove Product Feature,"## Overview

This GitHub issue is for implementing the 'Remove Feature' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD covering catalog (including products/categories/vendors with attributes like fields/features), orders, inventory, logistics, payments, RBAC, and audits. Core entities include products with features (attributes), media (e.g., product_image), barcodes, pricing (price_override), and promotions. The endpoint allows admins to remove a specific feature from a product, ensuring data integrity with soft deletes for archival, EAV for attributes, and strict referential links. State machines drive legality of transitions, with conflicts returning RFC7807 problem+json. Data is stored in UTC, supporting observability (audit_event, logs), security (RBAC, permissions), and middleware (auth, validation, throttling).

## API Specifications

- **Category:** feature
- **Title:** Remove Feature
- **Description:** Remove product feature
- **Route:** api/products/{id}/features/{feature_id}
- **HTTP Method:** DELETE
- **Authentication:** Admin

This endpoint targets the catalog domain, specifically product features, which are part of the EAV (Entity-Attribute-Value) model for product attributes.

## Acceptance Criteria

- [ ] Endpoint successfully removes the specified feature from the product when the admin has appropriate permissions
- [ ] Returns 204 No Content on successful deletion
- [ ] Validates that the product ID and feature ID exist and are associated
- [ ] Handles cases where the feature does not exist (404 Not Found)
- [ ] Enforces RBAC: only admins with permission to modify product features can access
- [ ] Logs audit events for the deletion action
- [ ] Implements soft delete to preserve archival data
- [ ] Includes unit and integration tests covering success, failure, and edge cases (e.g., invalid IDs, unauthorized access)
- [ ] Ensures idempotency for repeated DELETE requests
- [ ] Adheres to middleware: auth (JWT/API key), RBAC checks, input sanitizer, and error responses in problem+json format
- [ ] No impact on related entities like pricing overrides or promotions that reference features

## Technical Requirements

- Implement in Laravel: Define the route in api.php, create or update a ProductsController (or FeaturesController) with a destroy method for features
- Use Eloquent models: Product and Feature (or Attribute) with relationships (e.g., product->features())
- Input validation: Ensure {id} and {feature_id} are valid UUIDs or integers; use FormRequest or route model binding
- Authorization: Use Laravel's Gate or Policy for 'delete' permission on ProductFeature, scoped to admin role via RBAC (user/role/permission with ability mappings)
- Business logic: Check for dependencies (e.g., if feature is used in active promotions or inventory batches, prevent deletion or handle gracefully); trigger state machine if applicable for feature lifecycle; post to audit_event and ledger if financial impact
- Error handling: Return RFC7807 problem+json for validation errors, unauthorized (401/403), not found (404); use domain guards for catalog modifications
- Response format: No body for 204; errors include title, detail, type, and status per RFC7807
- Request format: No body required for DELETE; use query params if needed for versioning or idempotency key
- Integrations: Ensure compatibility with caching/etag, queues for async tasks (e.g., reindexing search/autosuggest), and observability (request-id, metrics)
- Testing: Cover auth scenarios, including session/JWT/API key; test with soft deletes and polymorphic relations (e.g., notes/attachments on features)
- Deployment considerations: Versioned API (content-negotiation), locale/tz handling, PII masking if features contain sensitive data

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC enforcement: User must have role with permission for 'product-feature-delete' (multi-role support via user_role)
- Additional checks: Active user, email-verified, optional 2FA (TOTP + backup codes), branch scope if multi-store context
- Middleware stack: TLS/HSTS, CORS, RequestId, auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope, throttles, idempotency

## Expected Request/Response Format Considerations

- **Request:** DELETE /api/products/{id}/features/{feature_id} (path params only; optional headers: Authorization, X-Idempotency-Key, Accept: application/json)
- **Success Response (204):** Empty body, with cache headers
- **Error Responses:** JSON (problem+json) e.g., 400 for invalid input, 401 Unauthorized, 403 Forbidden, 404 Not Found, 422 Unprocessable Entity
- Example Error: {""type"":""https://example.com/probs/validation"",""title"":""Invalid Input"",""status"":422,""detail"":""Feature not associated with product""}
- Versioning: Use URL prefix or header for API version; support bulk operations if extended later

## Relevant Business Logic

- Features are part of product attributes in the catalog domain; removal should not cascade to related entities like order_items or inventory unless explicitly linked
- Ensure deterministic behavior: If feature is in use (e.g., in promotions, pricing overrides, or reports), return conflict error or log warning
- Transactional: Wrap in DB transaction to maintain referential integrity; post ledger_entry if valuation affected
- Compliance: Mask PII in features; trigger notifications (email/SMS via templates) if removal impacts users; support feature flags for endpoint enablement
- Analytics: Update reporting (e.g., price change history, promo impact) post-deletion; enable reindex for search/autosuggest
- Edge cases: Handle concurrent modifications (optimistic locking via EAV), inter-store implications if features are store-specific, and reversals via audit trails"
70,product,Bulk Import Products,CSV/Excel import,api/products/import,post,Admin,Implement Bulk Import Products API Endpoint,"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint enables bulk import of products via CSV or Excel files, supporting the creation or update of product entities including attributes, media, barcodes, pricing, and promotions within the Deshio ERP catalog domain.

## API Specifications

- **Category:** product
- **Title:** Bulk Import Products
- **Description:** CSV/Excel import
- **Route:** api/products/import
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint accepts multipart/form-data with CSV or Excel file upload
- [ ] Validates file format (CSV/Excel only) and mime types via upload mime guard
- [ ] Parses file and maps columns to product fields (e.g., name, category, vendor, attributes, barcodes, pricing, promotions)
- [ ] Handles creation of new products and updates to existing ones based on unique identifiers (e.g., SKU)
- [ ] Supports batch processing with transactional integrity for stock movements and ledger postings if inventory is affected
- [ ] Returns detailed response with success count, failure count, and error details for invalid rows
- [ ] Integrates with state machines for any product state transitions
- [ ] Applies RBAC permissions for admin users only
- [ ] Logs audit events for import actions
- [ ] Handles errors per RFC7807 problem+json format
- [ ] Includes unit and integration tests covering valid/invalid files, large batches, and edge cases
- [ ] Ensures data in UTC, soft deletes if applicable, and referential integrity

## Technical Requirements

- Implement in Laravel controller (e.g., ProductController@bulkImport) and register route in api.php
- Use Laravel's file upload handling with validation rules for file size, type (CSV, XLS, XLSX)
- Leverage packages like Maatwebsite/Excel or similar for parsing Excel/CSV
- Integrate with Eloquent models for Product, Category, Vendor, Attribute, Media, Barcode, PriceOverride, Promotion
- Apply middleware stack: auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks (admin role required), branch scope, throttles, idempotency, input sanitizer, upload mime guard
- Use queues for large imports to avoid timeouts, with progress tracking if feasible
- Ensure idempotency for retry-safe imports using request-id
- Handle polymorphic relations for notes/attachments if added during import
- Post ledger entries for any financial implications (e.g., pricing changes)
- Cache headers and etag for responses if applicable
- Observability: log request-id, audit_event for import start/complete, metrics for import duration/success rate

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have role with permissions for product import (e.g., 'product.create', 'product.update' in bulk)
- Include active user check, email verification, and optional 2FA
- Branch scope: Limit import to user's accessible branches/stores
- Optional tenancy isolation if multi-tenant mode enabled

## Expected Request/Response Format Considerations

- **Request:** multipart/form-data with 'file' key for CSV/Excel; optional 'options' JSON for import settings (e.g., {""update_existing"": true, ""validate_only"": false})
- CSV/Excel columns: Standard template with headers like sku, name, category_id, vendor_id, attributes (JSON/EAV), barcode, price, promotion_code, etc.
- **Response:** JSON object with structure: {""success"": true, ""imported"": 100, ""failed"": 5, ""errors"": [{""row"": 1, ""message"": ""Invalid category""}], ""warnings"": []}
- Errors: RFC7807 problem+json, e.g., {""type"": ""https://example.com/probs/invalid-file"", ""title"": ""Invalid file format"", ""status"": 422}
- Success: 200 OK with summary; 201 Created if new records dominant
- Rate limiting and idempotency key in headers

## Relevant Business Logic

- Map imported data to core entities: Link products to categories/vendors; parse attributes via EAV; upload media if referenced (handle asynchronously)
- Validate barcodes uniqueness, pricing overrides, promotion applicability
- Trigger inventory reservations/adjustments if initial stock provided
- Ensure referential integrity: Existing categories/vendors must exist or create if allowed
- Handle promotions/taxes/fraud flags if specified
- For batch-centric inventory, create initial batches on import
- Integrate with reporting: Update price change history, inventory aging
- Conflicts (e.g., invalid state transitions) return problem+json
- Post accounting entries for any valuation impacts
- Support bulk operations as per Deshio's API patterns, including search/autosuggest for validation"
71,product,Bulk Export Products,Export CSV/Excel,api/products/export,get,Admin,Implement Bulk Export Products API (GET /api/products/export),"## Overview

This GitHub issue covers the implementation of the Bulk Export Products API endpoint in the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD. The endpoint enables administrators to export product data in CSV or Excel format, supporting core entities like product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), and promotions. Inventory is batch-centric with optional per-unit items, but this export focuses on catalog data. The design ensures deterministic handling, data stored in UTC, soft deletes for archival, EAV for attributes, polymorphic notes/attachments, and strict referential links. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. State machines drive legality of transitions, with conflicts returning RFC7807 problem+json. Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Order domain, fulfillment, returns, payments, accounting, services, and integrations are part of the broader system but not directly relevant to this product export endpoint.

## API Specifications

- **Category:** product
- **Title:** Bulk Export Products
- **Description:** Export CSV/Excel
- **Route:** api/products/export
- **HTTP Method:** GET
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET /api/products/export endpoint to handle bulk product exports
- [ ] Support export formats: CSV and Excel (via query parameter, e.g., ?format=csv|excel)
- [ ] Include comprehensive product data: name, description, attributes (EAV), categories, vendors, media (product_image), barcodes, pricing (including price_override), promotions
- [ ] Handle optional query parameters for filtering (e.g., ?category_id=123&active=true), pagination limits, and sorting
- [ ] Ensure exports respect soft deletes (option to include archived products via ?include_deleted=true)
- [ ] Apply branch scope if products are scoped (from middleware)
- [ ] Return file download with appropriate Content-Type (application/csv or application/vnd.openxmlformats-officedocument.spreadsheetml.sheet) and Content-Disposition: attachment
- [ ] Implement proper error handling with RFC7807 problem+json for invalid requests, auth failures, or export errors
- [ ] Add unit/integration tests for endpoint functionality, authentication, authorization, various formats, and edge cases (e.g., no products, large datasets)
- [ ] Ensure performance for bulk exports (e.g., streaming for large datasets to avoid memory issues)
- [ ] Log audit events for export actions (audit_event table)
- [ ] Mask PII in exports if applicable (e.g., via observability compliance)

## Technical Requirements

- Use Laravel controller (e.g., ProductController@export) and define route in api.php with middleware stack: auth, RBAC checks, branch scope
- Leverage Laravel's query builder/Eloquent for fetching products and related entities (joins for category/vendor, eager loading for media)
- Integrate with export libraries like Maatwebsite/Laravel-Excel for Excel/CSV generation, supporting headers and data mapping
- Handle UTC timestamps in exported data
- Implement idempotency if exports can be large/repeated (via middleware)
- Add input validation/sanitization for query params (e.g., format validation, filter guards)
- Use queues for very large exports if needed (from observability: queues)
- Ensure compatibility with caching/etag and versioned content-negotiation
- Follow ERD normalization: fetch from products table, junctions for categories/vendors/promotions, EAV for attributes
- Test with feature flags for export options if applicable

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key (middleware: auth, active user, email-verified, 2FA)
- Enforce RBAC: User must have 'product.export' permission (via role/permission/ability checks)
- Apply branch scope middleware to limit exports to user's accessible branches/stores
- Reject unauthorized access with 403 Forbidden (problem+json)
- Include request-id in responses/logs for tracing

## Expected Request/Response Format Considerations

- **Request:** GET /api/products/export?format=csv&category_id=123&limit=1000&include_deleted=false&sort=created_at_desc
  - No request body (GET method)
  - Query params validated: format (enum: csv, excel), filters (integers/booleans), sanitized via middleware
- **Success Response:** HTTP 200 with file attachment
  - Content-Type: application/csv or application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
  - Content-Disposition: attachment; filename=""products_export_{timestamp}.{csv|xlsx}""
  - Body: Binary file with columns for product_id, name, sku, category_name, vendor_name, attributes_json, barcode, price, promo_applied, images_urls, created_at (UTC), etc.
- **Error Response:** HTTP 4xx/5xx with application/problem+json (RFC7807)
  - e.g., 400 Bad Request for invalid format: {""type"":""https://example.com/probs/invalid-format"",""title"":""Invalid export format"",""status"":400,""detail"":""Format must be csv or excel""}
  - 401 Unauthorized, 403 Forbidden for auth/RBAC issues
  - 500 Internal Server Error for export failures
- Consider large payloads: Stream response to handle bulk data without buffering entire file in memory

## Relevant Business Logic

- Export must include all product-related data from core entities: attributes (via EAV), media references (not embedded binaries, use URLs), barcodes (multiple per product), pricing with overrides, and active promotions
- Respect system states: Only export confirmed/active products unless specified; integrate with state machines if transitions affect visibility (e.g., pending products)
- Ensure transactional consistency: No partial exports; if query spans relations, use atomic fetches
- Business rules: Products may be global or scoped to stores/branches; apply filters accordingly
- Compliance: Mask sensitive data (e.g., PII in attributes), log exports for audits, support deterministic admin assignment if products are assigned
- Integrations: Exports can feed into reporting/analytics (e.g., price change history, promo impact) or external systems via webhooks if extended
- Edge cases: Empty export (return empty file), no permissions (403), invalid filters (400), large datasets (timeout handling via throttles/queues)"
72,product,Archive Product,Soft-archive product,api/products/{id}/archive,post,Admin,Implement Archive Product API Endpoint (POST /api/products/{id}/archive),"## Overview

This GitHub issue is for implementing the 'Archive Product' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint allows soft-archiving a product, marking it as inactive without permanent deletion, which aligns with the system's soft deletes for archival purposes. This should prevent the product from appearing in active catalogs, searches, or new orders while preserving historical data, inventory, and related records.

## API Specifications

- **Category:** product
- **Title:** Archive Product
- **Description:** Soft-archive product
- **Route:** api/products/{id}/archive
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the endpoint in the Laravel controller to handle soft-archiving of a product by ID
- [ ] Ensure the product is marked as archived (e.g., set `is_active` or `deleted_at` flag) without deleting related entities like inventory batches, media, or historical orders
- [ ] Validate that the product exists and is not already archived
- [ ] Add input validation for the product ID (must be a valid UUID or integer)
- [ ] Handle errors with RFC7807 problem+json format for conflicts (e.g., product in active order or reservation)
- [ ] Write unit tests for successful archiving, validation failures, and error cases
- [ ] Write integration tests to verify impact on related domains (e.g., product no longer appears in active searches)
- [ ] Ensure audit_event is logged for the archiving action
- [ ] Confirm soft-archive respects state machines and domain guards (e.g., no archiving if product has open reservations or cycle counts)
- [ ] Test middleware stack including auth, RBAC, and idempotency

## Technical Requirements

- Use Laravel framework: Define the route in `routes/api.php` with proper versioning and content-negotiation
- Implement in a dedicated ProductController method (e.g., `archive($id)`)
- Leverage Eloquent for soft deletes on the Product model (extend with `SoftDeletes` trait if not already)
- Integrate with observability: Generate request-id, log the event, and trigger audit_event
- Handle transactions to ensure atomicity, especially for ledger postings if archiving impacts valuation
- Use queues for any asynchronous tasks like updating caches or notifications
- Apply caching/etag headers and consider branch scope if multi-tenant
- Input sanitizer and JSON limits via middleware

## Authentication/Authorization Requirements

- Requires Admin authentication: Use JWT/session/API key middleware
- Enforce RBAC: User must have a role with permission to archive products (e.g., 'product.archive' ability)
- Additional checks: Active user, email-verified, 2FA if enabled, and branch scope if applicable
- Optional tenancy isolation
- Throttling and idempotency keys to prevent duplicate archiving

## Expected Request/Response Format Considerations

- **Request:** POST /api/products/{id}/archive
  - Path param: {id} - Product identifier (UUID/integer)
  - Body: Empty JSON {} (or optional reason note as polymorphic attachment)
  - Headers: Authorization (Bearer/JWT), Content-Type: application/json, X-Request-Id, X-Idempotency-Key

- **Response:** 
  - Success (200 OK): JSON with archived product details or success message, e.g., {""message"": ""Product archived successfully"", ""data"": {""id"": ""uuid"", ""archived_at"": ""UTC timestamp""}}
  - Error (4xx/5xx): RFC7807 problem+json, e.g., {""type"": ""https://example.com/probs/product-not-found"", ""title"": ""Product not found"", ""status"": 404}

- All data in UTC; use versioned content-negotiation (e.g., Accept: application/vnd.deshio.v1+json)
- PII masking if any user-related data is involved indirectly

## Relevant Business Logic

- Soft-archiving should cascade checks: Prevent if product is in pending/confirmed orders, has reservations, or active promotions
- Update related entities: Invalidate caches for product searches/autosuggest; flag inventory as inactive but preserve batches/ledgers
- Trigger events: Post to accounting ledger if valuation changes; notify via webhooks if integrated; log for compliance/audits
- Align with state machines: Archiving is a legal transition only if product state allows (e.g., not 'fulfilling')
- Ensure referential integrity: Maintain links to categories, vendors, media, barcodes, pricing; no deletion of junctions
- Post-archiving: Product should be excluded from reporting/analytics for active metrics (e.g., revenue by active products) but included in historical views
- Reversibility: Consider unarchive endpoint in future, but focus on safe archival here"
73,product,Restore Product,Restore archived product,api/products/{id}/restore,post,Admin,Implement Restore Product API Endpoint (POST /api/products/{id}/restore),"## Overview

Deshio is a Laravel-based ERP system for retail/omni-channel operations, featuring approximately 290 REST APIs built over a normalized ERD. It covers domains including catalog (products/categories/vendors with attributes, media, barcodes, pricing, promotions), orders, inventory (batch-centric with reservations, adjustments, cycle counts, valuation, ledgers), logistics (shipments, dispatches, tracking), payments, RBAC, audits, services, integrations (carriers, webhooks, notifications), security (users/roles/permissions, JWT/session/API key auth, MFA), observability (audits, logs, PII masking, metrics), middleware (TLS, CORS, auth, RBAC, throttles, idempotency, sanitizers), reporting/analytics (revenue, LTV, inventory aging, etc.), and utilities (bulk import/export, search, attachments, state machines for transitions, RFC7807 errors, UTC storage, soft deletes, EAV attributes, polymorphic relations).

This issue is for implementing the 'Restore Product' API endpoint in the product category. It allows an admin to restore an archived (soft-deleted) product, enabling its reactivation in the catalog while ensuring referential integrity, audit logging, and compliance with business rules like deterministic assignments and consistent ledger postings.

## API Specifications

- **Category:** product
- **Title:** Restore Product
- **Description:** Restore archived product
- **Route:** api/products/{id}/restore
- **HTTP Method:** POST
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint restores a soft-deleted product by ID, making it active again in the catalog
- [ ] Validates that the product exists and is soft-deleted; returns 404 if not found or not deleted
- [ ] Ensures only admins with appropriate RBAC permissions can access the endpoint
- [ ] Logs an audit event for the restoration action, including user ID, timestamp, and request ID
- [ ] Handles concurrent requests with idempotency to prevent duplicate restores
- [ ] Returns the restored product details in the response or a success message
- [ ] Integrates with state machines if applicable for product lifecycle transitions
- [ ] Includes unit/integration tests covering success, failure (e.g., unauthorized, invalid ID), and edge cases (e.g., related entities like inventory batches)
- [ ] Documents the endpoint in API specs with examples

## Technical Requirements

- Implement in Laravel: Define route in api.php, create/update ProductController with restore method
- Use Eloquent model for Product with soft deletes enabled; call $product->restore() on the found model
- Apply middleware stack: auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks (admin role/permission for product restore), branch scope, throttles, idempotency, input sanitizer
- Input validation: Ensure {id} is a valid UUID/integer; no request body expected, but validate if present
- Error handling: Use RFC7807 problem+json for conflicts (e.g., product not soft-deleted); 403 for unauthorized, 422 for validation errors
- Response: 200 OK with restored product JSON (including attributes, media, pricing); or 204 No Content; set cache headers and ETag
- Business logic: Trigger any dependent updates (e.g., reindex search, notify via webhooks if configured, post to audit ledger); ensure UTC handling and referential links (e.g., to categories/vendors) are preserved; support EAV attributes and polymorphic notes/attachments
- Testing: PHPUnit tests for controller, validation, auth; feature tests simulating admin requests; mock RBAC and audit services
- Observability: Generate request-id, log events, mask PII in responses if applicable

## Authentication/Authorization Requirements

- Requires admin authentication via JWT, session, or API key
- RBAC enforcement: User must have 'product.restore' permission linked to their role(s); multi-role support via user_role junction
- Additional checks: Email verification, active status, optional 2FA/MFA, branch scoping to prevent cross-tenant access
- Reject with 401/403 if unauthorized; include security headers (TLS/HSTS, CORS)

## Expected Request/Response Format Considerations

- **Request:** POST /api/products/{id}/restore
  - Headers: Authorization (Bearer/JWT), Content-Type: application/json, X-Request-ID (for idempotency/tracing)
  - Body: Empty (no parameters expected; optional idempotency key if implemented)
  - Versioned via content-negotiation (e.g., Accept: application/vnd.deshio.v1+json)
  - Locale/TZ via headers for any i18n

- **Success Response (200 OK):**
  ```json
  {
    ""data"": {
      ""id"": ""uuid"",
      ""name"": ""Product Name"",
      ""category_id"": ""uuid"",
      ""attributes"": {...},
      ""pricing"": {...},
      ""deleted_at"": null,
      // other fields from ERD
    },
    ""meta"": {
      ""request_id"": ""uuid"",
      ""timestamp"": ""2023-01-01T00:00:00Z""
    }
  }
  ```

- **Error Response (e.g., 404/403):** RFC7807 format
  ```json
  {
    ""type"": ""https://tools.ietf.org/html/rfc7231#section-6.5.4"",
    ""title"": ""Not Found"",
    ""status"": 404,
    ""detail"": ""Product not found or not archived"",
    ""request_id"": ""uuid""
  }
  ```

- Considerations: JSON limits, upload mime guard (N/A here), domain guards for product overrides; soft-delete restoration should not trigger financial ledgers unless specified

## Relevant Business Logic

- Products use soft deletes for archival; restoration undeletes the record, reactivating it in catalog, inventory (re-enabling batches/reservations), and related domains (e.g., orders/promos)
- Ensure no conflicts with active entities (e.g., duplicate barcodes); use state machines for legality if product has lifecycle states
- Post-restoration: Update search indexes, clear caches, potentially trigger notifications (email/SMS via templates) or webhooks
- Maintain consistency: All movements (e.g., inventory adjustments) post to ledgers; audit every event with user attribution
- Compliance: PII masking in logs/responses; support feature flags for endpoint behavior; enable bulk operations if extended later"
74,store,List Stores,Paginated stores,api/stores,get,Employee,Implement List Stores API Endpoint (GET /api/stores),"## Overview

Deshio is a Laravel-based ERP system for retail/omni-channel operations, featuring approximately 290 REST APIs built over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes (fields/features), media (product images), barcodes, pricing (price overrides), promotions; stores/branches; customers with tags/blacklists.

Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain handles order/order_item states (pending → confirmed → fulfilled|cancelled), assignment to stores, notes/attachments, promotions, taxes, and fraud flags.

Fulfillment involves shipments (shipment/shipment_item) and inter-store dispatches (dispatch + tracking, scan events, POD) with transactional stock movements. Returns are managed via RMA (return/return_item), including receive/restock/scrap, refunds, and exchanges (exchange_order).

Payments follow an intent → payment capture/void lifecycle, with refund lifecycles and order.payment_status synchronization. Accounting uses transaction headers + ledger_entry lines for all movements, supporting reversals, reconciliation, and exports.

Services include service/service_order with lifecycles and profitability. Integrations cover carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity features user/role/permission with abilities (role ↔ perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance includes audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This issue focuses on implementing the 'List Stores' API endpoint, which provides a paginated list of stores/branches. Stores are core entities representing physical or logical branches in the ERP system, integral to inventory management, order assignment, fulfillment, and reporting.

## API Specifications

- **Category:** store
- **Title:** List Stores
- **Description:** Paginated stores
- **Route:** api/stores
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET /api/stores endpoint to return a paginated list of stores
- [ ] Support standard pagination parameters (e.g., page, per_page) with default values
- [ ] Include relevant store fields such as id, name, address, branch scope, and associations (e.g., inventory levels, assigned orders)
- [ ] Apply RBAC permissions to ensure only authenticated employees with appropriate roles can access
- [ ] Handle soft deletes by excluding archived stores unless explicitly requested
- [ ] Return RFC7807 problem+json for errors (e.g., unauthorized access, invalid pagination)
- [ ] Add unit and integration tests covering success, pagination, authentication failure, and error cases
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger)
- [ ] Ensure response includes ETag for caching and request-id for observability
- [ ] Verify middleware application: auth, RBAC checks, branch scope, throttles, input sanitizer

## Technical Requirements

- Use Laravel framework: Define route in api.php, create or extend StoresController with index() method
- Implement Eloquent query for Store model with pagination (e.g., Store::paginate($perPage))
- Apply scopes/filters for branch scope and active stores only (considering soft deletes)
- Input validation: Validate query params like page (integer >0), per_page (1-100), optional filters (e.g., search, status)
- Error handling: Use Laravel exceptions for 401 (unauthorized), 403 (forbidden), 422 (validation), 500 (server errors); format as problem+json
- Response formatting: JSON with pagination metadata (e.g., { data: [...], links: {...}, meta: { current_page, ... } })
- Logging: Record audit_event for access, include request-id
- Performance: Use eager loading for associations if needed, add indexes on filter fields
- Integration: Ensure compatibility with reporting (e.g., stores in revenue queries) and state machines (no direct transitions here)

## Authentication/Authorization Requirements

- Authentication: Required via Employee (JWT/session/API key)
- Authorization: RBAC check for permissions related to store access (e.g., role: employee, perm: view-stores)
- Additional checks: Active user, email-verified, 2FA if enabled; branch scope to limit to user's assigned stores
- Middleware stack: auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope

## Expected Request/Response Format Considerations

- **Request:** GET /api/stores?page=1&per_page=20&search=term&status=active
  - Query params: page (int, default 1), per_page (int, default 15, max 100), optional filters (search string, status enum)
  - Headers: Authorization (Bearer/JWT), Accept (application/json), X-Request-ID

- **Response (200 OK):** 
  {
    ""data"": [
      {
        ""id"": 1,
        ""name"": ""Main Branch"",
        ""address"": {...},
        ""branch_code"": ""BR001"",
        ""is_active"": true,
        ""created_at"": ""2023-01-01T00:00:00Z"",
        // other fields, associations if loaded
      }
    ],
    ""links"": {
      ""first"": ""/api/stores?page=1"",
      ""last"": ""/api/stores?page=10"",
      ""prev"": null,
      ""next"": ""/api/stores?page=2""
    },
    ""meta"": {
      ""current_page"": 1,
      ""from"": 1,
      ""last_page"": 10,
      ""per_page"": 20,
      ""to"": 20,
      ""total"": 200
    }
  }
  - Headers: ETag, Cache-Control, X-Request-ID

- **Error Response (e.g., 401):** 
  {
    ""title"": ""Unauthorized"",
    ""detail"": ""Authentication required"",
    ""status"": 401,
    ""type"": ""https://tools.ietf.org/html/rfc7235#section-3.1""
  }

- Content negotiation: JSON only, versioned if applicable (e.g., /api/v1/stores)
- Data in UTC, PII masking if addresses contain sensitive info

## Relevant Business Logic

- Stores represent branches critical for order assignment, inventory reservations, dispatch routing, and reporting segmentation (e.g., revenue by store)
- Pagination ensures scalability for large numbers of stores
- Filters allow searching by name/code or status (active/inactive)
- Respect soft deletes: Do not include deleted stores in lists
- Branch scope: Limit results to stores accessible by the authenticated employee's role/permissions
- No state machine transitions involved; this is a read-only list operation
- Ensure consistency with ledger postings (e.g., store-specific inventory movements) but no direct impact here
- Observability: Log access for audits, track metrics like response time for store listings"
75,store,Create Store,Create store,api/stores,post,Admin,Implement Create Store API Endpoint (POST /api/stores),"## Overview

This issue covers the implementation of the 'Create Store' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD that includes catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain handles states from pending to confirmed/fulfilled/cancelled, with assignments, notes, promos, taxes, and fraud flags. Fulfillment involves shipments, inter-store dispatches with tracking and POD. Returns use RMA with restock/refunds/exchanges. Payments include intents, captures, voids, refunds, and order synchronization. Accounting tracks transactions, ledgers, reversals, and reconciliations. Services manage service orders and profitability. Integrations cover carriers, waybills, rates, tracking, webhooks, and notifications. Security includes users/roles/permissions, sessions, email verification, password reset, TOTP MFA, API keys. Observability features audit events, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC/permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures, cache headers. Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines ensure legal transitions for orders, items, dispatch, shipments, returns, payments, cycle counts, with RFC7807 problem+json for conflicts. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data uses UTC storage, soft deletes, EAV for attributes, polymorphic notes/attachments, strict referential links. Design supports deterministic admin assignment, safe reservations/consumption, consistent ledger posting.

The endpoint allows admins to create new store/branch entities, integral to inventory, order assignment, and multi-location operations.

## API Specifications

- **Category:** store
- **Title:** Create Store
- **Description:** Create store
- **Route:** api/stores
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint responds to POST /api/stores with valid admin authentication
- [ ] Successfully creates a new store entity with provided data
- [ ] Validates input fields (e.g., store name, address, branch details) and returns appropriate errors for invalid data
- [ ] Handles business rules like unique store identifiers, branch scoping, and referential integrity to other entities (e.g., inventory ledgers)
- [ ] Returns 201 Created with the new store resource on success
- [ ] Implements proper error handling per RFC7807 for validation failures, unauthorized access, or conflicts
- [ ] Includes audit logging for the creation event
- [ ] Unit and integration tests cover happy path, edge cases (e.g., duplicate stores), and authorization
- [ ] Documentation updated for the endpoint, including request/response schemas
- [ ] Endpoint respects middleware stack: auth, RBAC, branch scope, input sanitizer, throttles, idempotency

## Technical Requirements

- Implement in Laravel: Define route in api.php, create or extend StoresController with createStore method
- Use Eloquent model for Store entity, ensuring soft deletes and UTC timestamps
- Input validation via FormRequest or Validator, covering required fields (e.g., name, address, timezone) and optional (e.g., contact info, inventory settings)
- Handle transactions for atomic creation, including any initial ledger setup or default branch assignments
- Integrate state machine if applicable for store lifecycle (e.g., pending→active)
- Support polymorphic attachments/notes if store creation allows initial uploads
- Ensure compatibility with reporting (e.g., store-specific metrics) and integrations (e.g., carrier accounts per store)
- Add caching/etag support if store data is frequently read
- Follow Deshio conventions: JSON responses, problem+json errors, request-id tracing

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT/session/API key
- Enforce RBAC: User must have 'create-store' permission via role/permission abilities
- Apply branch scope if multi-tenancy is active (optional)
- Check active user, email-verified, and 2FA if enabled
- Reject unauthorized requests with 401/403, including detailed problem+json

## Expected Request/Response Format Considerations

- **Request Body:** JSON payload with store details, e.g., {""name"": ""string"", ""address"": {""street"": ""string"", ...}, ""timezone"": ""UTC"", ""attributes"": EAV pairs}
- Validation: Required fields, string lengths, valid timezone, unique name/code per branch scope
- **Response:** 201 Created with JSON representation of created store, including id, timestamps, relations (e.g., initial inventory batches if applicable)
- Errors: 400 for validation (problem+json with field pointers), 409 for conflicts (e.g., duplicate), 422 for unprocessable entity
- Headers: Location for new resource, ETag if caching, X-Request-Id
- Support bulk? No, single creation; consider idempotency key for retries

## Relevant Business Logic

- Store creation triggers initial setup: Default inventory ledger, branch assignments, potential fraud flag defaults
- Ensure referential integrity: Link to existing vendors/categories if specified, but defer complex relations
- Post-creation: Auto-generate API keys if needed, notify via webhooks/email templates, audit event for compliance
- Conflicts: Use state machines to prevent invalid states; domain guards for inventory/reservation implications
- Integrations: Prepare for carrier account linking, dispatch routing to new store
- Analytics: Creation impacts reporting (e.g., new store in revenue by store queries)
- Soft delete support: Mark inactive rather than hard delete for archival"
76,store,Get Store,Get by id,api/stores/{id},get,Employee,Implement GET /api/stores/{id} Endpoint for Store Retrieval,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the 'Get Store' API endpoint. This endpoint retrieves store details by ID, supporting core entities like stores/branches in the inventory and order domains.

Deshio Core Context:
- Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
- Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
- Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
- Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
- Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
- Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
- Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
- Services: service/service_order with lifecycle and profitability.
- Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
- Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
- Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
- Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
- Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
- State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
- APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
- Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
- Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint falls under the 'store' category and is essential for retrieving store/branch information, which is linked to orders, inventory, and fulfillment processes.

## API Specifications

- **Category:** store
- **Title:** Get Store
- **Description:** Get by id
- **Route:** api/stores/{id}
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET /api/stores/{id} endpoint in the Laravel controller
- [ ] Validate the {id} parameter as a valid store ID (e.g., numeric or UUID)
- [ ] Return the store details if found and authorized, or appropriate error if not
- [ ] Handle soft deletes by excluding deleted stores or including archival flag if applicable
- [ ] Ensure response includes relevant store attributes, such as branch details, linked to inventory and orders
- [ ] Write unit and integration tests for successful retrieval, not found, unauthorized access, and invalid ID
- [ ] Verify endpoint adheres to middleware chain: auth, RBAC, branch scope
- [ ] Test response format complies with JSON API standards, including ETag for caching
- [ ] Confirm audit_event logging for the request
- [ ] Ensure no PII exposure without masking

## Technical Requirements

- Use Laravel controller and routes: Define the route in api.php with resource or explicit GET mapping
- Input validation: Use FormRequest or validator for {id} (required, exists in stores table)
- Proper error handling: Return 404 for not found, 403 for unauthorized, 400 for invalid ID; use RFC7807 problem+json for conflicts
- Integrate with Eloquent model for Store entity, including relationships (e.g., to branches, inventory ledgers)
- Apply caching with ETag and cache headers if store data is stable
- Support versioned content-negotiation and locale/tz from middleware
- Include request-id and log entry for observability
- Use queues if any background processing is needed (unlikely for GET)
- Ensure transactional consistency if querying linked data

## Authentication/Authorization Requirements

- Authentication: Required via Employee (JWT/session/API key)
- Authorization: RBAC check for employee role/permission to view stores; apply branch scope to ensure user can only access assigned stores
- Additional checks: Active user, email-verified, 2FA if enabled; permission via ability (role↔perm)
- Middleware: auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope

## Expected Request/Response Format Considerations

- **Request:** Path parameter {id} (e.g., GET /api/stores/123); no body; query params optional for includes (e.g., ?include=branch,inventory_summary)
- **Response:** 200 OK with JSON object for store: {
  ""data"": {
    ""id"": 123,
    ""name"": ""Store Name"",
    ""attributes"": { ... store fields like address, status, created_at (UTC) },
    ""relationships"": { ""branch"": {...}, ""orders"": [...] } // if included
  }
}; Include ETag header; 404 if not found
- Error responses: problem+json format, e.g., {
  ""title"": ""Not Found"",
  ""status"": 404,
  ""detail"": ""Store not found""
}
- Support content-negotiation for JSON; limit response size per JSON limits middleware

## Relevant Business Logic

- Stores/branches are core to order assignment, inventory management, and fulfillment (e.g., inter-store dispatch)
- Retrieve includes related data like linked inventory batches, order counts, or shipment history if specified
- Respect soft deletes: Do not return deleted stores unless archival access permitted
- Ensure data in UTC; apply locale/tz for any display fields
- No state machine transitions involved (read-only); but check store status (active/inactive) for visibility
- Integrate with reporting: This endpoint supports analytics like revenue by store
- Domain guards: Apply branch scope to prevent cross-store data leaks; idempotency not applicable for GET"
77,store,Update Store,Update by id,api/stores/{id},put,Admin,Implement Update Store API Endpoint (PUT /api/stores/{id}),"## Overview

This GitHub issue is for implementing the 'Update Store' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint allows updating a store by its ID, as part of the store category in Deshio's REST APIs. It supports branch management in a multi-store retail environment, ensuring updates align with inventory, orders, and logistics dependencies.

## API Specifications

- **Category:** store
- **Title:** Update Store
- **Description:** Update by id
- **Route:** api/stores/{id}
- **HTTP Method:** put
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the PUT /api/stores/{id} endpoint in the Laravel controller
- [ ] Add request validation for store update fields, including required attributes like name, address, and any store-specific configurations
- [ ] Ensure updates trigger relevant audit events and ledger postings if financial impacts occur
- [ ] Write unit and integration tests for successful updates, validation errors, unauthorized access, and not-found scenarios
- [ ] Verify response includes updated store data with HTTP 200 status
- [ ] Test integration with middleware for RBAC, branch scope, and idempotency
- [ ] Confirm error responses follow RFC7807 problem+json format for conflicts or invalid states
- [ ] Ensure soft deletes and referential integrity are maintained during updates

## Technical Requirements

- Use Laravel framework for controller, routes, and Eloquent models
- Implement in the StoresController or equivalent, with route registration in api.php
- Apply input validation using Form Requests or Validator facade, supporting EAV attributes for store features
- Handle soft deletes: prevent updates on deleted stores, or restore if needed
- Integrate with state machines if store status transitions are involved (e.g., active/inactive)
- Use UTC for timestamps; include polymorphic notes/attachments if update involves them
- Add observability: log request-id, audit_event for changes, and metrics for endpoint performance
- Support caching/etag for responses; queues for any async post-update tasks like notifications
- Ensure transactional consistency for stock movements or order assignments linked to the store

## Authentication/Authorization Requirements

- Require Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have 'update-store' permission via role/permission abilities
- Apply middleware stack: auth, active user, email-verified, 2FA, RBAC checks, branch scope (ensure user can access the specific store/branch)
- Optional tenancy isolation if multi-tenant mode is enabled
- Throttle requests and support idempotency keys to prevent duplicate updates

## Expected Request/Response Format Considerations

- **Request:** JSON body with partial updates (e.g., {""name"": ""Updated Store"", ""address"": {""street"": ""New St""}, ""attributes"": {EAV fields}}). Use PUT for full/partial updates per REST conventions. Validate MIME types for any attachments.
- **Response:** HTTP 200 OK with JSON of updated store object, including id, name, branch details, linked entities (e.g., inventory summaries if relevant), and etag for caching. Include links for related resources like orders or shipments.
- **Errors:** 401 Unauthorized, 403 Forbidden (RBAC/scope), 404 Not Found, 422 Unprocessable Entity (validation), 409 Conflict (state machine violations). All errors in RFC7807 problem+json format with title, detail, and instance.
- Support content-negotiation for versioned API responses; locale/tz from headers.

## Relevant Business Logic

- Updates must respect store's role in omni-channel retail: e.g., propagate changes to assigned orders, inventory reservations, or dispatch routes.
- Validate against domain guards: Ensure no conflicts with active reservations, ongoing shipments, or financial ledgers.
- If update affects pricing/promotions or inventory valuation, trigger reindex or ledger postings.
- Support multi-branch: Updates scoped to specific store/branch, with referential links to vendors, products, customers.
- Handle fraud flags or blacklist integrations if store update involves customer-facing changes.
- Ensure consistency with reporting: Updates should reflect in analytics like revenue by store or inventory aging.
- Post-update: Invalidate caches, send webhooks/notifications if configured (e.g., email/SMS for store admins)."
78,store,Delete Store,Delete by id,api/stores/{id},delete,Admin,Implement Delete Store API Endpoint (DELETE /api/stores/{id}),"## Overview

Implement the Delete Store API endpoint for the Deshio ERP system. This endpoint allows administrators to delete a store by its ID. Given Deshio's Laravel-based architecture with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this implementation must adhere to core entities like stores/branches, ensure safe handling of dependencies (e.g., inventory, orders), and use soft deletes for archival purposes. Core entities include: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

## API Specifications

- **Category:** store
- **Title:** Delete Store
- **Description:** Delete by id
- **Route:** api/stores/{id}
- **HTTP Method:** DELETE
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint deletes the store by ID using soft delete to maintain archival integrity
- [ ] Validates that the store exists before attempting deletion
- [ ] Handles dependencies: prevent hard delete if store has active orders, inventory, shipments, or dispatches; log warnings or return appropriate errors
- [ ] Ensures deletion triggers audit events, ledger entries for any related movements, and invalidates caches
- [ ] Returns 204 No Content on successful deletion
- [ ] Returns 404 if store not found
- [ ] Returns 403 if user lacks admin permissions
- [ ] Implements RBAC checks for admin role
- [ ] Includes middleware for auth, throttling, idempotency, and request sanitization
- [ ] Writes unit and integration tests covering success, failure, and edge cases (e.g., store with linked entities)
- [ ] Documents the endpoint in API specs with examples
- [ ] Ensures compliance with RFC7807 for error responses

## Technical Requirements

- Use Laravel controller (e.g., StoreController@destroy) and define route in api.php
- Implement input validation for {id} as a required UUID or integer
- Apply soft deletes via Eloquent's SoftDeletes trait on the Store model
- Integrate with state machines if deletion affects order/store assignments
- Handle business logic: check for referential integrity (e.g., orders assigned to store, inventory batches); if constraints exist, return problem+json with details
- Use transactions for atomicity in any related ledger postings or audit events
- Add observability: log deletion events with request-id, audit_event entry, and metrics
- Support versioned content-negotiation and cache headers (e.g., no-cache for mutations)
- Ensure PII masking if store data includes sensitive info

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: user must have admin role/permission for store deletion
- Apply middleware stack: auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope
- Admin users only; deny access for non-admin roles

## Expected Request/Response Format Considerations

- **Request:** No body required; path parameter {id} (e.g., DELETE /api/stores/123)
- Headers: Authorization (Bearer token), Accept: application/json, Content-Type: application/json
- **Success Response (204 No Content):** Empty body
- **Error Responses:**
  - 400 Bad Request: Invalid ID format (problem+json)
  - 403 Forbidden: Insufficient permissions (problem+json)
  - 404 Not Found: Store does not exist (problem+json)
  - 409 Conflict: Store has dependencies preventing deletion (problem+json with details)
  - 422 Unprocessable Entity: Validation failures
- All responses in JSON; use UTC timestamps; include request-id header

## Relevant Business Logic

- Deletion should not orphan related entities; use soft deletes to archive store while preserving links to orders, inventory, shipments, etc.
- Trigger ledger entries for any financial impacts (e.g., reverse pending transactions tied to store)
- Update reporting/analytics caches (e.g., revenue by store) post-deletion
- Ensure safe handling of inter-store dispatches or branch scopes affected by deletion
- Comply with domain guards for order/payment/dispatch/reservation/promo/override/cycle-count/fraud if store deletion impacts them
- Integrate with notifications if configured (e.g., email admins on store deletion)"
79,store,Set Online Status,Toggle online store,api/stores/{id}/online,post,Admin,Implement API: Set Online Status for Stores (POST /api/stores/{id}/online),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue covers the implementation of the 'Set Online Status' API endpoint. This endpoint allows admins to toggle the online status of a specific store/branch, which impacts order assignment, reservations, and other operations like deterministic admin assignment for online orders. Core entities involved include stores/branches, with considerations for branch scope, state machines for legality of transitions, and middleware like auth (JWT/session/API key), RBAC & permission checks, and branch scope.

The Deshio system features a normalized ERD with entities like product/category/vendor, inventory (batch-centric with reservations/adjustments), orders (with states pending→confirmed→fulfilled|cancelled), fulfillment (shipments/dispatches), returns (RMA), payments, accounting (ledgers), services, integrations (carriers/webhooks), security (RBAC/TOTP), observability (audits/logs), reporting/analytics, bulk operations, and more. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic relations, and strict referential integrity. Middleware includes TLS/HSTS, CORS, RequestId, auth, RBAC, throttles, idempotency, input sanitizer, and domain guards.

This toggle enables/disables the store for online operations, ensuring safe reservation/consumption and consistent ledger posting on events.

## API Specifications

- **Category:** store
- **Title:** Set Online Status
- **Description:** Toggle online store
- **Route:** api/stores/{id}/online
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST endpoint at api/stores/{id}/online to toggle the online status of the specified store
- [ ] Require admin-level authentication and authorization via RBAC (user must have admin role/permission)
- [ ] Validate that the store ID exists and belongs to the authenticated user's branch scope
- [ ] Toggle the online status field on the Store model (e.g., from true to false or vice versa)
- [ ] Handle cases where the store is not found (return 404 with RFC7807 problem+json)
- [ ] Enforce business rules: prevent toggling if it would violate order/fulfillment states or reservations; use state machines for legality
- [ ] Return a success response (200 OK) with the updated store details in JSON
- [ ] Implement proper error handling for unauthorized access (403), invalid input (422), and conflicts (409 if applicable)
- [ ] Add unit tests for controller logic, integration tests for endpoint behavior, and cover edge cases like soft-deleted stores
- [ ] Ensure the endpoint respects middleware: auth, RBAC checks, branch scope, throttles, idempotency, input sanitizer, and cache headers
- [ ] Log audit_event for the toggle action with request-id and PII masking if applicable
- [ ] Verify compatibility with versioned content-negotiation, locale/tz, and JSON limits

## Technical Requirements

- Use Laravel framework: Define the route in routes/api.php with middleware groups (auth:api, admin scope, etc.)
- Create or update a StoreController with a method (e.g., toggleOnline) to handle the request
- Leverage Eloquent Store model: Update the 'online' boolean field, ensuring soft deletes are handled (restore if needed, but toggle only active stores)
- Input validation: Use FormRequest or validate() for {id} as required UUID/integer; no request body expected for toggle, but confirm if status override is needed
- Business logic: Integrate with state machines to check/allow transitions; trigger any related events (e.g., notifications via templates, inventory reservations check); ensure transactional updates for consistency with ledgers/stock movements
- Authentication/authorization: Use JWT/session/API key; check user_role for admin ability (role↔perm); apply branch scope to ensure user can only toggle stores in their scope; optional tenancy if multi-tenant
- Expected request format: POST /api/stores/{id}/online with empty body or optional JSON { ""online"": boolean } if explicit set is preferred over toggle; headers include Authorization, Accept: application/json, Content-Type: application/json
- Expected response format: 200 OK with JSON { ""data"": { ""id"": uuid, ""name"": string, ""online"": boolean, ...store details } }; errors as RFC7807 problem+json (e.g., { ""title"": ""Not Found"", ""status"": 404, ""detail"": ""Store not found"" })
- Error handling: Use exceptions for 404 (ModelNotFound), 403 (Unauthorized), 422 (Validation); domain guards for order/payment/reservation conflicts if toggling affects them
- Testing: PHPUnit tests for validation, auth, toggle logic, responses; mock RBAC and state machines; ensure EAV attributes and polymorphic relations (notes/attachments) are not affected
- Observability: Add request-id tracing, audit logging, metrics for endpoint usage; consider queues/caching/etag for performance
- Integrations: If toggle impacts promotions, inventory aging, or reporting (e.g., low stock alerts), ensure reindex or webhook triggers if needed
- Security: Apply upload mime guard if attachments involved (unlikely); provider webhook signatures not applicable here
- Reporting: Update any analytics like store online status in revenue/orders reports

This implementation must align with Deshio's design principles: deterministic assignments, safe stock handling, and full audit trail."
80,store,Set Warehouse Flag,Toggle warehouse,api/stores/{id}/warehouse,post,Admin,Implement Set Warehouse Flag API Endpoint for Stores,"## Overview

This GitHub issue is for implementing the ""Set Warehouse Flag"" API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs built over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits.

Core entities include: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.

Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.

Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.

Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).

Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.

Services: service/service_order with lifecycle and profitability.

Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.

Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint specifically allows administrators to toggle the warehouse flag on a store, enabling or disabling its role in inventory management, reservations, and fulfillment processes.

## API Specifications

- **Category:** store
- **Title:** Set Warehouse Flag
- **Description:** Toggle warehouse
- **Route:** api/stores/{id}/warehouse
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST endpoint at api/stores/{id}/warehouse to toggle the warehouse flag on the specified store
- [ ] Ensure the endpoint requires Admin authentication and authorization via RBAC
- [ ] Validate the store ID exists and is accessible (considering branch scope)
- [ ] Toggle the warehouse flag (e.g., boolean field on store model) and persist the change
- [ ] Handle successful toggle by returning the updated store resource or a success response
- [ ] Implement proper error handling for invalid store ID (404), unauthorized access (403), and other conflicts using RFC7807 problem+json
- [ ] Add unit and integration tests covering happy path, authorization failures, and validation errors
- [ ] Ensure the endpoint integrates with middleware stack including auth, RBAC checks, branch scope, and audit logging
- [ ] Verify that toggling affects related business logic, such as inventory reservations or fulfillment eligibility for the store
- [ ] Document the endpoint in API specs with request/response examples

## Technical Requirements

- Use Laravel framework: Define the route in routes/api.php with appropriate middleware
- Create or update a StoreController method (e.g., toggleWarehouse) to handle the logic
- Use Eloquent for store model interaction; update the 'is_warehouse' or similar boolean field
- Apply input validation (though likely no body, validate {id} as UUID/integer)
- Integrate with state machines if warehouse flag affects order/shipment transitions
- Ensure transactional updates to maintain data consistency (e.g., DB transaction for flag toggle and any ledger entries)
- Add audit_event logging for the toggle action
- Support soft deletes: Ensure the store is not soft-deleted
- Use UTC for any timestamps; apply caching/etag if store data is cached
- Follow REST conventions: Idempotency via POST if needed, but toggle implies state change

## Authentication/Authorization Requirements

- Require JWT/session/API key authentication
- Enforce Admin role via RBAC: Check user has 'admin' role or specific permission (e.g., 'stores.update-warehouse')
- Apply active user, email-verified, and 2FA checks if enabled
- Include branch scope to ensure the user can access/modify the target store's branch
- Return 401 for unauthenticated, 403 for unauthorized

## Expected Request/Response Format Considerations

- **Request:** POST api/stores/{id}/warehouse
  - Path param: {id} - Store ID (UUID or integer)
  - Body: Empty (toggle action) or optional JSON { ""warehouse"": true/false } for explicit set
  - Headers: Authorization (Bearer/JWT), Accept: application/json, Content-Type: application/json

- **Response:** 
  - Success (200): JSON of updated store resource, e.g., { ""data"": { ""id"": ""uuid"", ""name"": ""Store Name"", ""is_warehouse"": true, ... } }
  - Error (4xx/5xx): RFC7807 problem+json, e.g., { ""title"": ""Not Found"", ""detail"": ""Store not found"", ""status"": 404, ""type"": ""https://example.com/errors/not-found"" }

- Versioned via content-negotiation (e.g., /v1/); support JSON limits and sanitizer

## Relevant Business Logic

- Toggling the warehouse flag designates the store as a warehouse for inventory purposes, impacting batch-centric inventory, reservations, adjustments, and fulfillment (e.g., enabling inter-store dispatches or stock movements)
- Validate that the store can be toggled (e.g., no active orders/shipments blocking the change if applicable; use state machines for legality)
- On toggle to true: Potentially initialize warehouse-specific ledgers or reservations; trigger notifications if configured
- On toggle to false: Ensure no pending inventory dependencies; prevent if reservations exist (domain guard)
- Post any stock/financial events to accounting ledgers consistently
- Integrate with reporting: Update analytics for inventory aging/low stock by store
- Ensure idempotency and replay defense via request-id
- Audit the action with user/store IDs and timestamps"
81,customer,List Customers,Paginated customers,api/customers,get,Employee,Implement List Customers API Endpoint (GET /api/customers),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the 'List Customers' API endpoint. This endpoint provides a paginated list of customers, supporting core entities like customers with tags and blacklist. Deshio handles data in UTC, soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential links. State machines ensure legality of transitions, with conflicts returning RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

## API Specifications

- **Category:** customer
- **Title:** List Customers
- **Description:** Paginated customers
- **Route:** api/customers
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint returns paginated list of customers with standard Laravel pagination metadata (e.g., current_page, last_page, per_page, total)
- [ ] Supports query parameters for pagination (page, per_page), optional search/filtering by name/email/tags/blacklist
- [ ] Requires Employee authentication and appropriate RBAC permissions (e.g., view customers)
- [ ] Handles soft deletes by excluding deleted customers unless explicitly requested
- [ ] Returns RFC7807 problem+json for errors (e.g., unauthorized, validation failures)
- [ ] Includes PII masking for sensitive customer data in logs/audits
- [ ] Integrates with middleware stack: auth, RBAC checks, request-id, throttling, input sanitization
- [ ] Unit and integration tests cover successful pagination, auth failures, invalid params, and edge cases (e.g., empty list, large datasets)
- [ ] Documentation updated with OpenAPI spec for request/response schemas
- [ ] Performance optimized with Eloquent eager loading for relations (e.g., tags, orders summary if applicable)

## Technical Requirements

- Use Laravel controller (e.g., CustomerController@list) and define route in api.php with proper middleware group
- Leverage Eloquent Customer model with relationships to tags, blacklist, and other entities (e.g., orders, addresses)
- Implement pagination using Laravel's LengthAwarePaginator or simplePaginate for efficiency
- Input validation via FormRequest or controller validation for query params (e.g., page as integer, per_page 1-100)
- Proper error handling: 401 for unauth, 403 for forbidden (RBAC), 422 for invalid params, 500 for server errors
- Response format: JSON with data array of customer objects (id, name, email, phone, tags, blacklist status, created_at, updated_at, etc.), wrapped in pagination envelope
- Ensure UTC timestamps and locale/tz awareness via middleware
- Audit logging for API calls via audit_event model
- Caching considerations: Use etag or query caching for repeated lists if applicable
- Integration with observability: Metrics for endpoint usage, queue if async processing needed

## Authentication/Authorization Requirements

- Authentication: Employee via JWT, session, or API key
- Authorization: RBAC check for user role/permission (e.g., 'view-customers' ability via role↔perm mapping)
- Additional checks: Active user, email-verified, 2FA if enabled, branch scope (filter customers by branch if multi-branch)
- Security: Input sanitizer, domain guards for customer data access, PII masking in responses/logs

## Expected Request/Response Format Considerations

- **Request:** GET /api/customers?page=1&per_page=20&search=john&tag=loyal&blacklisted=false
  - Query params: page (int, default 1), per_page (int, default 15, max 100), search (string for name/email), tag (string filter), blacklisted (bool)
  - Headers: Accept: application/json, Authorization: Bearer <token>

- **Response (200 OK):** 
  {
    ""data"": [
      {
        ""id"": 1,
        ""name"": ""John Doe"",
        ""email"": ""john@example.com"",
        ""phone"": ""+1234567890"",
        ""tags"": [""loyal"", ""vip""],
        ""blacklisted"": false,
        ""created_at"": ""2023-01-01T00:00:00Z"",
        ""updated_at"": ""2023-01-02T00:00:00Z""
      }
    ],
    ""current_page"": 1,
    ""last_page"": 10,
    ""per_page"": 20,
    ""total"": 200
  }

- **Error Response (e.g., 401):** RFC7807 format, e.g., {""title"": ""Unauthorized"", ""status"": 401, ""detail"": ""Invalid credentials""}
- Versioned via content-negotiation (e.g., Accept: application/vnd.deshio.v1+json)

## Relevant Business Logic

- Customers entity includes attributes via EAV, media/attachments (polymorphic), tags for segmentation, blacklist for restrictions
- List should respect soft deletes (exclude by default), filter by tags/blacklist for targeted views (e.g., marketing, fraud)
- Supports reservations/adjustments in broader context but for list, focus on basic retrieval
- Integrates with order domain (e.g., optional summary of order count/LTV in response if permissioned)
- Ensures deterministic access: No direct stock/financial exposure, but links to orders/payments for reporting (LTV/AOV, return rates)
- Compliance: GDPR-like PII handling, audit trails for views, no sensitive data (e.g., mask full addresses unless authorized)
- Scalability: Batch-centric considerations if linking to inventory/orders, but keep lightweight for listing"
82,customer,Create Customer,Create customer,api/customers,post,Admin,Implement POST /api/customers - Create Customer Endpoint,"## Overview

This GitHub issue is for implementing the 'Create Customer' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint allows admins to create new customers, supporting tags and blacklist features.

## API Specifications

- **Category:** customer
- **Title:** Create Customer
- **Description:** Create customer
- **Route:** api/customers
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint responds with 201 Created on successful customer creation
- [ ] Validates required customer fields (e.g., name, email) and optional fields (e.g., tags, blacklist status)
- [ ] Handles duplicate email/phone with 409 Conflict or appropriate error
- [ ] Integrates with RBAC to ensure only Admin role can access
- [ ] Logs audit events for creation
- [ ] Supports PII masking in logs
- [ ] Returns RFC7807 problem+json for validation or authorization errors
- [ ] Includes unit and integration tests covering success, validation failures, and unauthorized access
- [ ] Adheres to middleware stack: auth, RBAC checks, input sanitization, throttles, idempotency

## Technical Requirements

- Implement in Laravel: Create a controller method in CustomerController (or similar) handling POST /api/customers
- Define routes in api.php with admin middleware
- Use Laravel validation for request input (e.g., Request $request->validate([...]))
- Interact with Customer model: Use Eloquent to create new customer record with UTC timestamps
- Handle soft deletes if applicable (though create is new record)
- Ensure referential integrity for related entities (e.g., tags)
- Add proper error handling: Exceptions for conflicts, wrap in try-catch, return JSON errors
- Consider caching/etag if relevant for customer lists post-creation
- Integrate with queues if email verification is triggered on create

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT/session/API key
- RBAC check: User must have 'create-customer' permission or equivalent in admin role
- Enforce active user, email-verified, and 2FA if enabled
- Branch scope if multi-tenant (optional)
- Unauthorized requests return 401/403 with problem+json

## Expected Request/Response Format Considerations

- **Request Body (JSON):** Expect fields like {""name"": ""string"", ""email"": ""string"", ""phone"": ""string"", ""tags"": [""array""], ""blacklist"": boolean, ""attributes"": EAV object}
- Validate MIME types, JSON limits via middleware
- Sanitize inputs to prevent injection
- **Response (201 Created):** {""id"": integer, ""name"": ""string"", ""email"": ""string"", ""created_at"": ""UTC datetime"", ""tags"": [""array""], ...} with etag header
- **Error Responses:** 400 for validation (problem+json with details), 401/403 for auth, 409 for duplicates
- Use content-negotiation for versioned API

## Relevant Business Logic

- Create customer with optional tags and blacklist flag
- Trigger email verification if email provided
- Post to audit_event log with request-id
- Ensure no ledger postings needed for customer create (unlike stock/financial events)
- Support polymorphic attachments/notes if added during create
- Align with state machines if customer has lifecycle states (e.g., pending verification)
- Handle idempotency: Use key to prevent duplicate creates"
83,customer,Get Customer,Get by id,api/customers/{id},get,Employee,Implement GET /api/customers/{id} - Get Customer by ID,"## Overview

This GitHub issue is for implementing the 'Get Customer' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint retrieves a specific customer by their ID, including associated data like tags and blacklist status, ensuring compliance with PII masking and RBAC.

## API Specifications

- **Category:** customer
- **Title:** Get Customer
- **Description:** Get by id
- **Route:** api/customers/{id}
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET /api/customers/{id} endpoint in Laravel controller
- [ ] Validate the {id} parameter as a valid customer ID (e.g., UUID or integer)
- [ ] Return the customer details if found and authorized, including tags and blacklist info
- [ ] Handle 404 if customer not found
- [ ] Handle 403 if employee lacks permission
- [ ] Apply PII masking for sensitive fields in response
- [ ] Write unit tests for successful retrieval, not found, and unauthorized cases
- [ ] Write integration tests covering middleware (auth, RBAC, request-id)
- [ ] Ensure response uses versioned content-negotiation and cache headers
- [ ] Log audit_event for access
- [ ] Test with soft-deleted customers (should not return unless specified)

## Technical Requirements

- Use Laravel controller and routes: Define in api.php routes file with prefix 'api'
- Input validation: Use FormRequest or validator for {id} (required, exists in customers table)
- Proper error handling: Return RFC7807 problem+json for validation errors, 404, 403
- Query optimization: Eager load relations like tags, orders summary if applicable; use soft deletes
- Response formatting: JSON with customer fields (id, name, email, phone, tags, blacklist status, created_at, updated_at); respect locale/tz
- Middleware stack: Apply auth (JWT/session/API key), active user, RBAC & permission checks (employee role with customer:read permission), branch scope if applicable, throttles, idempotency, input sanitizer
- Database: Query from customers table in UTC; handle EAV attributes if customer has custom fields
- Observability: Include request-id, log access, audit_event with PII masking

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- RBAC: Employee must have 'customer:read' permission via role/permission mapping
- Additional checks: Active user, email-verified, 2FA if enabled; branch scope for store-specific customers
- Security: TLS/HSTS, CORS, domain guards for customer access

## Expected Request/Response Format Considerations

- **Request:** GET /api/customers/{id} (path param {id}); optional query params for includes (e.g., ?include=tags,orders) if expanding scope
- **Headers:** Accept: application/vnd.deshio.v1+json; Authorization: Bearer <token>
- **Response (200 OK):** {
  ""data"": {
    ""id"": ""uuid"",
    ""name"": ""string"",
    ""email"": ""string (masked if PII)"",
    ""tags"": [""array""],
    ""blacklisted"": true/false,
    ""created_at"": ""UTC datetime"",
    ""updated_at"": ""UTC datetime""
  }
}
- **Error Responses:** 400 (validation), 401 (unauth), 403 (forbidden), 404 (not found), with problem+json
- Content negotiation: Versioned API, etag for caching

## Relevant Business Logic

- Customers are core entities with tags for segmentation and blacklist for restrictions (e.g., fraud flag integration)
- Retrieval should not expose soft-deleted customers; use withTrashed() only if admin permission
- Integrate with orders domain: Optionally include order summary if requested, respecting state machines
- Compliance: Mask PII in logs/responses; ensure referential integrity with related entities (e.g., no direct access to payments without permission)
- State: Customer data is static post-creation, but tags/blacklist can change; reflect latest via fresh query
- Edge cases: Handle multi-role employees, tenancy if enabled, idempotency for repeated calls"
84,customer,Update Customer,Update by id,api/customers/{id},put,Admin,Implement Update Customer API (PUT /api/customers/{id}),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs over a normalized ERD, this issue covers implementing the Update Customer API endpoint. Deshio manages core entities including product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment handles shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns cover RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments include intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting features transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services include service/service_order with lifecycle and profitability. Integrations encompass carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint allows updating a customer by ID, supporting modifications to customer details, tags, and blacklist status within the customer entity.

## API Specifications

- **Category:** customer
- **Title:** Update Customer
- **Description:** Update by id
- **Route:** api/customers/{id}
- **HTTP Method:** put
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the PUT /api/customers/{id} endpoint in the Laravel controller
- [ ] Validate input data for customer updates, including required fields like name, email, and optional fields like address, tags, and blacklist status
- [ ] Ensure the endpoint updates the customer record while maintaining referential integrity with related entities (e.g., orders, tags)
- [ ] Handle soft deletes appropriately if the customer is archived
- [ ] Add unit and integration tests covering successful updates, validation errors, and unauthorized access
- [ ] Verify that updates trigger audit events and logs as per observability requirements
- [ ] Confirm response follows RFC7807 for any errors (e.g., customer not found, permission denied)
- [ ] Test middleware application: auth, RBAC, input sanitizer, throttles, etc.
- [ ] Ensure PII masking in logs for sensitive customer data

## Technical Requirements

- Use Laravel framework for controller, routes, and models
- Define routes in api.php with proper versioning and content-negotiation
- Implement in CustomerController with update method
- Use Eloquent model for Customer with relationships to tags, blacklist, orders, etc.
- Apply input validation using Form Requests or Validator facade, supporting EAV attributes if applicable
- Integrate with state machines if update affects customer status (e.g., verification)
- Handle transactions for atomic updates, especially if linked to payments or orders
- Include proper error handling with JSON responses and HTTP status codes (200 OK for success, 404 for not found, 422 for validation errors, 403 for unauthorized)
- Add caching/etag support if applicable for customer data reads post-update
- Ensure queueing for any post-update notifications (e.g., email verification updates)

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: Only users with roles/permissions allowing customer updates (e.g., 'customers.update' permission)
- Apply active user, email-verified, and 2FA checks via middleware
- Scope to branch if multi-branch updates are restricted
- Use idempotency keys to prevent duplicate updates

## Expected Request/Response Format Considerations

- **Request:** JSON body with partial updates (e.g., {""name"": ""Updated Name"", ""email"": ""new@example.com"", ""tags"": [""vip""], ""blacklisted"": false}). Use PUT for full/partial update semantics. Include {id} in URL path.
- **Response:** On success, return 200 OK with updated customer JSON (e.g., {""id"": 1, ""name"": ""Updated Name"", ...}), excluding sensitive PII unless authorized. For errors, return RFC7807 problem+json (e.g., {""title"": ""Validation Error"", ""detail"": ""Invalid email"", ""status"": 422}).
- Support content-negotiation for JSON; validate MIME types.
- All timestamps in UTC; use ETag for conditional updates if caching enabled.

## Relevant Business Logic

- Updates must respect customer entity constraints: unique email, valid address formats, tag associations via junctions.
- If blacklisting, trigger fraud flags or order restrictions.
- Post-update, synchronize with related domains (e.g., invalidate order caches, post ledger entries if financial impact).
- Ensure compliance: audit all changes, mask PII in responses/logs, support GDPR-like deletions via soft deletes.
- Handle conflicts with concurrent updates using optimistic locking or transactions.
- Integrate with reporting: updates may affect LTV/AOV calculations or activity analytics."
85,customer,Delete Customer,Delete by id,api/customers/{id},delete,Admin,Implement DELETE /api/customers/{id} for Deleting Customers,"## Overview

This GitHub issue is for implementing the Delete Customer API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. Order domain includes states (pending→confirmed→fulfilled|cancelled), assignment, notes, promos, taxes, fraud flags. Fulfillment covers shipments, inter-store dispatch with tracking and POD. Returns handle RMA, restock, refunds, exchanges. Payments manage intents, captures, voids, refunds, and order synchronization. Accounting includes transaction headers, ledger entries, reversals, reconciliation. Services cover service orders with lifecycle and profitability. Integrations include carriers, waybills, tracking, webhooks, notifications. Security & identity: user/role/permission with abilities, sessions, email verification, password reset, TOTP MFA, API keys. Observability: audit_event, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive transitions for orders, dispatches, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links. Design enables deterministic admin assignment, safe reservation/consumption, consistent ledger posting.

The endpoint allows authenticated admins to delete a customer by ID, using soft deletes for archival purposes to maintain referential integrity with related entities like orders or tags.

## API Specifications

- **Category:** customer
- **Title:** Delete Customer
- **Description:** Delete by id
- **Route:** api/customers/{id}
- **HTTP Method:** delete
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the DELETE endpoint at /api/customers/{id} that soft-deletes the customer record
- [ ] Require admin authentication and RBAC permission checks for the operation
- [ ] Validate that the {id} is a valid UUID or integer identifier for the customer
- [ ] Return 204 No Content on successful deletion
- [ ] Return 404 Not Found if the customer ID does not exist
- [ ] Return 403 Forbidden if the user lacks admin permissions
- [ ] Handle soft deletes to preserve archival data and referential integrity (e.g., do not cascade delete related orders or inventory)
- [ ] Log an audit_event for the deletion action with request-id and user details
- [ ] Ensure PII masking in logs for customer data
- [ ] Add unit and integration tests covering success, error cases, and permissions
- [ ] Document the endpoint in API specs with examples
- [ ] Apply relevant middleware: auth (JWT/API key), RBAC checks, input sanitizer, throttles, idempotency

## Technical Requirements

- Use Laravel framework: Define route in routes/api.php with 'api' middleware group
- Create or update CustomerController with a destroy method handling the deletion
- Leverage Eloquent Customer model with SoftDeletes trait enabled for archival
- Implement input validation using FormRequest or controller validation for {id} (e.g., exists in customers table)
- Use state machine if applicable for customer lifecycle transitions (e.g., from active to deleted)
- Ensure transactional integrity: Wrap deletion in a database transaction to handle any ledger postings or audit events
- Error handling: Use RFC7807 problem+json for validation errors, unauthorized access, or conflicts (e.g., if customer has open orders preventing hard delete)
- Response format: No body for 204; JSON errors with title, detail, status per RFC7807
- Request format: No body required; {id} as path parameter
- Integration: Trigger any webhooks or notifications if configured for customer events; update caches/etags if customer data is cached
- Observability: Include request-id in responses/logs; queue any async tasks (e.g., audit logging)
- Security: Enforce branch scope if multi-tenant; domain guards for customer-related operations

## Authentication/Authorization Requirements

- Authentication: JWT, session, or API key via middleware
- Authorization: Admin role with specific permission (e.g., 'delete-customers') via RBAC & ability checks
- Additional: Active user, email-verified, 2FA if enabled; branch scope to ensure admin can only delete customers assigned to their scope

## Expected Request/Response Format Considerations

- **Request:** DELETE /api/customers/{id} (e.g., DELETE /api/customers/123)
  - Headers: Authorization: Bearer {token}, Accept: application/json, Content-Type: application/json
  - No body
- **Success Response (204):** No content
- **Error Response (e.g., 404):** 
  ```json
  {
    ""type"": ""https://example.com/probs/not-found"",
    ""title"": ""Customer not found"",
    ""status"": 404,
    ""detail"": ""The specified customer ID does not exist""
  }
  ```
- Versioning: Support via content-negotiation (e.g., Accept: application/vnd.deshio.v1+json)
- Locale/TZ: Inherit from request headers; data in UTC

## Relevant Business Logic

- Soft delete the customer to maintain history and links to orders, payments, tags, blacklist
- Prevent deletion if business rules apply (e.g., open orders or unpaid invoices – raise conflict error)
- Post to audit ledger for compliance; no financial ledger impact unless tied to payments
- Cascade effects: Update any related entities' references (e.g., anonymize in reports) but do not delete
- Idempotency: Support retry via key if provided in header
- Conflicts: Use state machine to validate deletion legality; return problem+json for invalid transitions"
86,customer,Merge Customers,Merge duplicate customers,api/customers/merge,post,Admin,Implement Merge Customers API Endpoint (POST /api/customers/merge),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the 'Merge Customers' API endpoint. This endpoint allows merging duplicate customer records to maintain data integrity.

Core entities include: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.

Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.

Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.

Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).

Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.

Services: service/service_order with lifecycle and profitability.

Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.

Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint falls under the 'customer' category and enables merging duplicate customers while preserving related data like orders, tags, and blacklist status.

## API Specifications

- **Category:** customer
- **Title:** Merge Customers
- **Description:** Merge duplicate customers
- **Route:** api/customers/merge
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST /api/customers/merge endpoint in the Laravel controller
- [ ] Validate input to ensure primary and secondary customer IDs are provided and valid
- [ ] Handle merging logic: designate one customer as primary, transfer relevant data (e.g., addresses, orders, tags, blacklist status) from duplicates, and soft-delete or archive duplicates
- [ ] Ensure referential integrity for related entities like orders and payments
- [ ] Add audit events for the merge operation
- [ ] Return RFC7807 problem+json for conflicts or invalid states
- [ ] Write unit and integration tests covering success, failure, and edge cases (e.g., self-merge, non-existent IDs)
- [ ] Document the endpoint in API specs with request/response examples
- [ ] Apply middleware: auth (Admin), RBAC checks, input sanitizer, idempotency
- [ ] Ensure PII masking in logs for customer data

## Technical Requirements

- Use Laravel controller and define route in api.php with 'admin' middleware group
- Implement input validation using Form Requests: require array of customer IDs, specify primary ID
- Business logic: Query customers, check for duplicates, merge attributes (EAV), reassign polymorphic relations (notes/attachments), update junctions (tags/blacklist), log audit_event
- Handle transactions to ensure atomicity: use DB::transaction() for merging and soft deletes
- Response: JSON with success message and merged customer ID, or error details
- Error handling: 422 for validation errors, 403 for unauthorized, 409 for conflicts (e.g., active orders preventing merge)
- Integration: Ensure compatibility with state machines if customer state affects orders/returns
- Observability: Add request-id tracing, log merge events with PII masking
- Testing: Cover RBAC (only Admin), branch scope if applicable, and performance for large merges

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT/session/API key
- RBAC check: User must have 'admin' role or specific 'merge-customers' permission
- Middleware: active user, email-verified, 2FA if enabled, branch scope (if multi-branch merge)
- Reject if not authenticated or insufficient permissions with 401/403

## Expected Request/Response Format Considerations

- **Request Body (JSON):** {""primary_id"": 123, ""duplicate_ids"": [456, 789]}, with optional ""merge_options"": {""preserve_emails"": true, ""handle_orders"": ""reassign""}
- **Success Response (200):** {""message"": ""Customers merged successfully"", ""merged_customer_id"": 123, ""affected_count"": 2}
- **Error Response (e.g., 422):** RFC7807 format, e.g., {""title"": ""Validation Error"", ""detail"": ""Duplicate ID cannot be primary"", ""status"": 422, ""problems"": [...]}
- Use versioned content-negotiation, JSON limits, and cache headers
- Idempotency: Support idempotency keys to prevent duplicate merges

## Relevant Business Logic

- Merging duplicates consolidates customer data to avoid fragmentation in reporting (e.g., LTV/AOV, order history)
- Preserve critical data: Reassign orders/payments to primary, merge tags/blacklist, handle multiple emails/phones by prioritizing or concatenating
- Prevent merges if: active fraud flags, unresolved RMAs, or payment intents in progress
- Post-merge: Trigger webhooks if configured, update analytics caches, ensure ledger consistency if financial ties
- Soft-delete duplicates for archival, maintain audit trail for compliance
- Align with UTC storage, strict referential links, and domain guards for customer-related operations"
87,batch,List Batches,Paginated batches,api/batches,get,Employee,Implement GET /api/batches - List Paginated Batches,"## Overview

This GitHub issue is for implementing the 'List Batches' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.

Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.

Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.

Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.

Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).

Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.

Services: service/service_order with lifecycle and profitability.

Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.

Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint provides a paginated list of batches, which are central to the inventory management in Deshio's batch-centric system.

## API Specifications

- **Category:** batch
- **Title:** List Batches
- **Description:** Paginated batches
- **Route:** api/batches
- **HTTP Method:** GET
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET /api/batches endpoint to return a paginated list of batches
- [ ] Support standard pagination parameters (e.g., page, per_page) with default values
- [ ] Allow optional query parameters for filtering (e.g., by product, store, status) and sorting
- [ ] Ensure responses include relevant batch details such as ID, product association, quantity, expiry, location, and status
- [ ] Handle authentication for Employee users only, enforcing RBAC permissions
- [ ] Return proper HTTP status codes: 200 for success, 401 for unauthorized, 403 for forbidden, 422 for validation errors
- [ ] Implement error handling with RFC7807 problem+json for conflicts or invalid states
- [ ] Add unit and integration tests covering happy path, edge cases, pagination, and authorization
- [ ] Ensure middleware chain includes auth, RBAC checks, branch scope, throttles, and input sanitization
- [ ] Verify data is returned in UTC, respecting soft deletes and EAV attributes
- [ ] Test for performance with large datasets, using efficient queries and caching where applicable
- [ ] Document the endpoint in API docs with examples

## Technical Requirements

- Use Laravel controller (e.g., BatchController@index) and define the route in api.php
- Leverage Eloquent models for Batch entity, with relationships to Product, Store, InventoryLedger, etc.
- Implement pagination using Laravel's LengthAwarePaginator or simplePaginate for efficiency
- Apply query scopes for filtering/sorting based on inventory business logic (e.g., active batches, low stock)
- Integrate with state machines if batch states affect visibility (e.g., reserved, adjusted)
- Use Request validation with FormRequest class for query parameters
- Handle soft deletes by excluding deleted records unless specified
- Ensure transactional consistency for any related ledger postings or reservations
- Add audit_event logging for endpoint access
- Support search/autosuggest if extended, but focus on basic listing
- Optimize for observability: include request-id, metrics, and caching/etag headers

## Authentication/Authorization Requirements

- Require Employee authentication via JWT, session, or API key
- Enforce RBAC: User must have 'employee' role with permissions for viewing batches (e.g., inventory.view)
- Apply branch scope: Limit results to user's assigned branches/stores
- Include middleware for active user, email-verified, 2FA if enabled, and permission checks
- Reject requests without proper auth with 401; insufficient perms with 403

## Expected Request/Response Format Considerations

- **Request:** GET /api/batches?page=1&per_page=20&filter[product_id]=123&sort=created_at.desc
  - Query params: page (int, default 1), per_page (int, default 15, max 100), filter[] (array for product_id, store_id, status), sort (string)
  - No request body

- **Response (200 OK):** JSON with pagination metadata and data array
  {
    ""data"": [
      {
        ""id"": 1,
        ""product_id"": 123,
        ""batch_number"": ""BATCH001"",
        ""quantity"": 100,
        ""reserved"": 20,
        ""expiry_date"": ""2024-12-31T00:00:00Z"",
        ""location"": ""Warehouse A"",
        ""status"": ""active"",
        ""created_at"": ""2023-01-01T00:00:00Z""
      }
    ],
    ""meta"": {
      ""current_page"": 1,
      ""last_page"": 10,
      ""per_page"": 20,
      ""total"": 200
    }
  }

- **Error Response (e.g., 422):** RFC7807 problem+json
  {
    ""title"": ""Validation Error"",
    ""detail"": ""Invalid filter parameter"",
    ""status"": 422,
    ""problems"": [...]
  }

- Content negotiation: JSON only, versioned if applicable, with cache headers

## Relevant Business Logic

- Batches are core to inventory: each represents a group of items with shared attributes like expiry, vendor lot
- Listing should reflect current state: available quantity = total - reserved - adjustments
- Support for reservations (e.g., tied to orders), cycle counts, and valuation methods
- Ensure consistency with ledgers: any batch movement posts to accounting
- Filter by store/branch for multi-location support
- Handle optional per-unit items within batches
- Conflicts (e.g., invalid state transitions) use state machines and return problem+json
- Integrate with broader domains: batches link to orders, shipments, returns for stock movements
- Data in UTC; use polymorphic relations for notes/attachments on batches if needed"
88,batch,Create Batche,Create batche,api/batches,post,Admin,Implement Create Batch API Endpoint (POST /api/batches),"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint is for creating a batch in the inventory system, which is batch-centric. It allows admins to create new batches, potentially including details like product association, quantity, expiry, and other batch-specific attributes to support inventory management, reservations, adjustments, valuation, and ledgers.

## API Specifications

- **Category:** batch
- **Title:** Create Batch
- **Description:** Create batch
- **Route:** api/batches
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST /api/batches endpoint in the Laravel controller
- [ ] Validate incoming request data for required batch fields (e.g., product_id, quantity, batch_number, expiry_date)
- [ ] Ensure creation triggers any necessary ledger entries or stock movements as per business logic
- [ ] Handle errors with RFC7807 problem+json format for validation failures or state conflicts
- [ ] Add unit and integration tests covering successful creation, validation errors, and authorization failures
- [ ] Verify response includes the created batch details with proper HTTP status (201 Created)
- [ ] Integrate with middleware for auth, RBAC, request ID, and idempotency
- [ ] Ensure data is stored in UTC and supports soft deletes if applicable

## Technical Requirements

- Use Laravel framework: Define route in api.php, create or update BatchController with store method
- Implement input validation using Form Requests or Validator, including rules for batch attributes linked to products, stores, and inventory entities
- Handle database transactions to ensure atomicity, especially for stock reservations or ledger postings
- Integrate with state machines if batch creation involves transitions (e.g., from draft to active)
- Apply middleware stack: auth (JWT/API key), RBAC permission checks for admin role, branch scope, throttles, input sanitizer, and domain guards for inventory/reservation
- Use Eloquent models for Batch entity, with relationships to Product, InventoryLedger, etc.
- Support polymorphic attachments or notes if batches can have them
- Ensure observability: Log audit events, use request-id, and mask PII if applicable
- For bulk or related operations, consider extensibility but focus on single batch creation

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have admin role with permissions for batch creation (e.g., 'batch.create')
- Check active user status, email verification, and optional 2FA
- Apply branch scope to ensure creation is limited to authorized stores/branches
- Use multi-role support if needed for granular permissions

## Expected Request/Response Format Considerations

- **Request:** JSON body with fields like {""product_id"": 1, ""batch_number"": ""BATCH001"", ""quantity"": 100, ""expiry_date"": ""2024-12-31"", ""store_id"": 1, ...} – validate against ERD for referential integrity
- **Response:** On success, 201 Created with JSON {""id"": 1, ""batch_number"": ""BATCH001"", ""product"": {...}, ""created_at"": ""UTC timestamp"", ...}; On error, 4xx/5xx with RFC7807 problem+json (e.g., {""type"": ""validation_error"", ""title"": ""Invalid data"", ""detail"": ""Quantity must be positive""})
- Use versioned content-negotiation, JSON limits, and cache headers
- Consider idempotency keys in request headers to prevent duplicate creations

## Relevant Business Logic

- Batches are core to inventory: Creation should initialize batch for reservations, adjustments, cycle counts, and valuation
- Link to products/vendors with attributes; support barcodes and pricing overrides if applicable
- Trigger ledger_entry for initial stock movement; ensure transactional consistency with shipments/dispatches/returns
- Validate against store/branch assignment and prevent conflicts with existing reservations or low stock
- Use state machines for batch lifecycle (e.g., active→expired→scrapped); return conflicts if invalid state
- Integrate with reporting for inventory aging and low stock alerts post-creation
- Support EAV for custom batch attributes and polymorphic relations for notes/attachments"
89,batch,Get Batche,Get by id,api/batches/{id},get,Employee,Implement GET /api/batches/{id} to Retrieve Batch by ID,"## Overview

This GitHub issue covers the implementation of the 'Get Batch' API endpoint in the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD. The endpoint retrieves a specific batch by its ID, central to the inventory domain which is batch-centric with optional per-unit items. Batches support reservations, adjustments, cycle counts, valuation, and ledgers. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers + tags/blacklist. Inventory features transactional stock movements, while orders, fulfillment (shipments/dispatches), returns (RMA), payments, accounting (transaction headers + ledger entries), services, integrations (carriers/webhooks), security (RBAC/user roles/permissions/sessions/MFA/API keys), observability (audits/logs/PII masking), middleware (TLS/CORS/auth/RBAC/throttles/idempotency), reporting/analytics (revenue/inventory aging/promo impact), state machines for transitions, bulk operations, and data in UTC with soft deletes/EAV/polymorphic relations. Design ensures deterministic admin assignment, safe reservations, and consistent ledger posting.

## API Specifications

- **Category:** batch
- **Title:** Get Batch
- **Description:** Get by id
- **Route:** api/batches/{id}
- **HTTP Method:** GET
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET endpoint to fetch a batch by ID
- [ ] Validate the {id} parameter (e.g., integer or UUID, required)
- [ ] Return 200 OK with batch details if found and authorized
- [ ] Return 404 Not Found if batch does not exist or is soft-deleted
- [ ] Return 403 Forbidden if user lacks permission or branch scope
- [ ] Handle authentication failures with 401 Unauthorized
- [ ] Include related data (e.g., products, stock levels, reservations) in response
- [ ] Ensure response complies with JSON API standards, caching/ETag headers
- [ ] Write unit tests for controller logic and integration tests for full flow
- [ ] Add API documentation (e.g., OpenAPI spec)
- [ ] Verify middleware application (auth, RBAC, branch scope, throttles)

## Technical Requirements

- Use Laravel framework: Define route in api.php routes file with resource controller
- Create or extend BatchController with show() method using Eloquent model (Batch::with relations like products, inventory_ledgers)
- Implement input validation using Form Requests or controller validation (e.g., $request->route('id') must be valid ID)
- Handle soft deletes: Query with()->withTrashed() if needed, but exclude deleted by default
- Proper error handling: Use RFC7807 problem+json for errors (e.g., validation failures, conflicts); log with request-id
- Database: Normalized ERD with UTC storage, strict referential integrity; EAV for batch attributes
- Performance: Eager load relations to avoid N+1; consider caching for frequent reads
- Testing: PHPUnit tests covering happy path, edge cases (non-existent ID, unauthorized), and state machine legality if transitions involved
- Compliance: PII masking if batch data includes sensitive info; queueable if heavy computation

## Authentication/Authorization Requirements

- Authentication: Employee via JWT, session, or API key; apply middleware stack (RequestId, auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope)
- Authorization: RBAC with user/role/permission; check ability (e.g., 'view-batch') via policies/gates; multi-role support; optional tenancy; branch scope to restrict to user's branches/stores
- Security: TLS/HSTS, CORS, JSON limits, input sanitizer, domain guards (e.g., reservation/inventory checks if batch involves active reservations)

## Expected Request/Response Format Considerations

- **Request:** GET /api/batches/{id} (path param {id}: batch identifier, e.g., UUID or integer); no body; query params optional (e.g., ?include=products,reservations for relations)
- **Response:** 
  - 200 OK: JSON object with batch data, e.g., {""data"": {""id"": ""uuid"", ""batch_number"": ""BN123"", ""expiry_date"": ""2024-12-31T00:00:00Z"", ""stock_quantity"": 100, ""attributes"": {...}, ""relations"": {...}}}
  - Include metadata (e.g., timestamps in UTC, etag for caching)
  - 4xx/5xx: problem+json, e.g., {""type"": ""https://tools.ietf.org/html/rfc7231#section-6.5.4"", ""title"": ""Not Found"", ""status"": 404, ""detail"": ""Batch not found""}
- Versioned: Use content-negotiation for API version; locale/tz handling
- Bulk/related: Support autosuggest/search if extended, but focus on single ID retrieval

## Relevant Business Logic

- Batches are core to inventory: Track batch-specific stock, reservations, adjustments, cycle counts, valuation/ledgers; optional per-unit items
- On retrieval: Ensure batch state allows view (e.g., via state machine if active/expired/archived); include transactional movements history if audited
- Conflicts: If batch involved in ongoing order/shipment/return/dispatch, flag or include status (e.g., reserved quantity); prevent access if fraud flag or blacklist
- Integrations: If batch linked to promotions/pricing/attributes/media/barcodes, eager load; support ledger posting consistency on events
- Observability: Log audit_event for access; metrics for retrieval latency/SLA; handle idempotency if retried
- Edge cases: Handle archived/soft-deleted batches; branch/store assignment; promo/override impacts on batch pricing; inventory aging/low stock indicators in response"
90,batch,Update Batche,Update by id,api/batches/{id},put,Admin,Implement Update Batch API Endpoint (PUT /api/batches/{id}),"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This issue is for implementing the Update Batch API endpoint in the batch category. It allows updating a batch by its ID, which is critical for inventory management in a batch-centric system supporting reservations, adjustments, cycle counts, valuation, and ledgers.

## API Specifications

- **Category:** batch
- **Title:** Update Batch
- **Description:** Update by id
- **Route:** api/batches/{id}
- **HTTP Method:** PUT
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint updates a batch record by ID when valid data is provided
- [ ] Returns 200 OK with updated batch details on success
- [ ] Validates input and returns 422 Unprocessable Entity for invalid data
- [ ] Handles 404 Not Found if batch ID does not exist
- [ ] Ensures updates trigger appropriate ledger postings for stock/financial events
- [ ] Respects soft deletes and archival policies
- [ ] Integrates with state machines for legal transitions if applicable to batch states
- [ ] Includes audit events for the update action
- [ ] Unit and integration tests cover happy path, validation errors, and edge cases (e.g., concurrent updates)
- [ ] Documentation updated in API specs with request/response examples
- [ ] Middleware applied: auth, RBAC, branch scope, idempotency, input sanitizer, domain guards for inventory/reservation/cycle-count

## Technical Requirements

- Implement in Laravel: Define route in api.php, create/update BatchController method
- Use Eloquent model for Batch entity, ensuring relationships to products, inventory ledgers, reservations, etc.
- Input validation using Form Requests or Validator: Require ID as path param, allow updatable fields like batch attributes, expiry, quantity adjustments (with business rules)
- Proper error handling: Use RFC7807 problem+json for conflicts/invalids; log errors with request-id
- Database: All operations in UTC; handle transactions for atomic updates (e.g., stock movements via ledgers)
- Observability: Generate audit_event, log the update; mask PII if applicable
- Caching: Invalidate relevant caches/etags post-update
- Queues: If update triggers async tasks (e.g., notifications, reindex), enqueue them

## Authentication/Authorization Requirements

- Requires Admin authentication (JWT/session/API key)
- RBAC check: User must have permission to update batches (e.g., inventory.update ability)
- Active user, email-verified, 2FA if enabled
- Branch scope: Ensure user can only update batches in their scoped branches/stores
- Optional tenancy if multi-tenant setup

## Expected Request/Response Format Considerations

- **Request:** JSON body with updatable batch fields (e.g., {""name"": ""Updated Batch"", ""expiry_date"": ""2024-12-31"", ""quantity"": 100}); path param {id} as UUID/int
- **Response:** 200 OK with JSON of updated batch (include related data like current stock, ledger summary); use content-negotiation for versioned responses
- Error Responses: 401 Unauthorized, 403 Forbidden (RBAC/scope), 404 Not Found, 422 Validation Errors (with field details), 429 Throttle if exceeded
- Headers: Include Request-Id, cache headers; support idempotency via key in request

## Relevant Business Logic

- Batch updates must ensure consistency in inventory: Adjust reservations if quantity changes; post ledger_entry for movements
- Validate against state machines: Prevent illegal updates (e.g., can't update fulfilled batch without reversal)
- Handle EAV attributes if batch has custom fields
- Integrate with promotions/pricing if batch affects product pricing
- Trigger webhooks/notifications if update impacts orders/shipments
- Ensure referential integrity: Updates shouldn't break links to orders, shipments, returns, or cycle counts
- For batch-centric inventory: Support optional per-unit items; valuation updates if cost/price changes"
91,batch,Delete Batche,Delete by id,api/batches/{id},delete,Admin,Implement DELETE /api/batches/{id} for Batch Deletion,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD, implement the Delete Batch API endpoint. This endpoint allows administrators to delete a specific batch by its ID, handling inventory management where inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. Core entities include product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers + tags/blacklist. Order domain involves states, assignments, notes, promos, taxes, fraud flags. Fulfillment includes shipments, inter-store dispatch with tracking and POD. Returns handle RMA, restock, refunds, exchanges. Payments manage intents, captures, voids, refunds. Accounting tracks transactions, ledgers, reversals. Services include service orders. Integrations cover carriers, webhooks, notifications. Security features user/role/permission with RBAC, sessions, MFA, API keys. Observability includes audits, logs, PII masking, health/metrics. Middleware encompasses TLS, CORS, auth (JWT/session/API key), RBAC checks, branch scope, throttles, idempotency, sanitizers, domain guards. Reporting covers revenue, LTV/AOV, returns, inventory aging, etc. State machines ensure legal transitions for orders, dispatches, etc., with RFC7807 errors. APIs support bulk operations, search, attachments, reindex, backups. Data in UTC, soft deletes, EAV attributes, polymorphic relations. Design ensures deterministic assignments, safe reservations, consistent ledger posting.

This endpoint falls under the batch category, titled 'Delete Batche' (likely 'Batch'), described as 'Delete by id'.

## API Specifications

- **Category:** batch
- **Title:** Delete Batche
- **Description:** Delete by id
- **Route:** api/batches/{id}
- **HTTP Method:** delete
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint deletes the specified batch by ID when authenticated as Admin
- [ ] Returns 204 No Content on successful deletion
- [ ] Handles non-existent batch ID with 404 error in RFC7807 problem+json format
- [ ] Enforces RBAC: only Admin roles can access
- [ ] Validates {id} as a valid UUID or integer batch identifier
- [ ] Prevents deletion if batch is in use (e.g., linked to reservations, shipments, orders, or active inventory movements) with appropriate 409 Conflict error
- [ ] Implements soft delete for archival compliance
- [ ] Logs audit_event for the deletion action
- [ ] Integrates with state machine to ensure legal transition (e.g., batch not in fulfilled/shipped state)
- [ ] Includes request-id in responses for observability
- [ ] Applies middleware: auth, active user, RBAC, branch scope, throttles, idempotency, input sanitizer
- [ ] Writes unit/integration tests covering success, errors, auth failures, and business constraints
- [ ] Documents endpoint in API specs with examples
- [ ] Ensures no PII exposure and proper error masking

## Technical Requirements

- Use Laravel controller (e.g., BatchController@destroy) and register route in api.php with {id} parameter
- Implement input validation using Form Requests or Validator: ensure {id} exists and is owned by the scoped branch/store
- Handle business logic: Check batch state via state machine; verify no active links to orders, shipments, returns, reservations, or ledgers; if constraints met, perform soft delete and post reversal ledger entries if needed; trigger any webhooks or notifications for batch deletion
- Authentication/authorization: Require JWT/session/API key; enforce Admin role via user_role and ability checks; optional 2FA and email verification
- Expected request format: No body required; {id} in path (e.g., DELETE /api/batches/123)
- Expected response formats: 204 on success (empty body); Errors as JSON with problem+json (title, detail, status, type per RFC7807), e.g., 404 for not found, 403 for unauthorized, 409 for conflicts
- Error handling: Use try-catch for exceptions; return consistent errors for invalid ID, permission denied, concurrent modifications (idempotency key if applicable)
- Database: Use Eloquent model for Batch with softDeletes trait; ensure referential integrity with polymorphic relations, junctions; UTC timestamps
- Testing: PHPUnit tests for controller, validation, auth; feature tests simulating requests; mock state machine and RBAC
- Observability: Generate audit_event, log with request-id; cache headers if applicable; queue any async tasks like ledger posting
- Security: Sanitize inputs, guard against injection; domain guards for inventory/reservation conflicts; TLS enforcement
- Integration: Ensure deletion cascades or updates related entities (e.g., inventory ledgers) transactionally; support feature flags for endpoint
- Additional: Versioned API (e.g., v1/batches); content-negotiation for JSON; locale/tz handling if needed"
92,batch,Split Batch,Split a batch into multiples,api/batches/{id}/split,post,Admin,Implement Split Batch API Endpoint (POST /api/batches/{id}/split),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations, implement the 'Split Batch' API endpoint. Deshio features ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers.

This endpoint allows splitting an existing batch into multiple sub-batches, enabling granular inventory management. It ensures transactional stock movements, ledger updates, and state machine compliance for inventory adjustments. Use state machines to drive legality of transitions; conflicts return RFC7807 problem+json. Data is stored in UTC with soft deletes; strict referential links across junctions. Design enables deterministic admin assignment and safe reservation/consumption.

## API Specifications

- **Category:** batch
- **Title:** Split Batch
- **Description:** Split a batch into multiples
- **Route:** api/batches/{id}/split
- **HTTP Method:** POST
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint handles successful batch splitting and returns appropriate response
- [ ] Validation ensures the batch exists, is splittable (e.g., sufficient quantity, no reservations blocking split), and input quantities sum correctly
- [ ] Business logic updates inventory ledgers, creates new batch records, and handles stock movements transactionally
- [ ] Error handling for invalid inputs, non-existent batch, or unauthorized access using RFC7807 problem+json
- [ ] Unit and integration tests cover happy path, edge cases (e.g., zero quantity split, over-split), and failures
- [ ] Documentation updated with request/response examples and OpenAPI spec
- [ ] Middleware applied: auth (JWT/session/API key), RBAC & permission checks, branch scope, input sanitizer, domain guards (reservation/inventory)
- [ ] Observability: audit_event logged, request-id traced, PII masking if applicable

## Technical Requirements

- Implement in Laravel: Add route to api.php, create or update BatchController with splitBatch method
- Use Eloquent models for Batch, InventoryLedger, etc.; leverage soft deletes and polymorphic relations for notes/attachments if needed
- Input validation with Laravel Form Requests: require batch ID, array of split quantities (e.g., [{quantity: 10}, {quantity: 20}]), optional notes
- Transactional operations: Use DB::transaction to ensure atomicity for creating new batches, adjusting original batch quantity, posting ledger entries
- Integrate with state machines for inventory transitions (e.g., adjustment state)
- Support bulk operations if scalable; enable idempotency via header
- Caching/etag for batch reads; queues for any async ledger posting if heavy
- Reporting impact: Update inventory aging/low stock queries post-split

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC check: User must have 'batch.split' permission (via role↔perm and user_role multi-role)
- Active user, email-verified, optional 2FA (TOTP + backup codes)
- Branch scope: Ensure split is within user's scoped branches/stores
- Middleware stack: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth, active user, email-verified, 2FA, RBAC, branch scope, throttles, idempotency, input sanitizer, domain guards

## Expected Request/Response Format Considerations

- **Request:** JSON body with { ""splits"": [{ ""quantity"": integer, ""notes"": string (optional) }], ""reason"": string (optional for audit) }. Path param {id} as batch UUID/int. Headers: Authorization, X-Request-ID, Content-Type: application/json
- **Response:** 201 Created with JSON array of new batch objects (including IDs, quantities, updated timestamps); or 200 OK if including original updated batch. Include Link headers for related resources (e.g., ledger entries). Errors: 400 Bad Request (validation), 403 Forbidden (auth), 404 Not Found (batch), 422 Unprocessable (business rules)
- Use JSON:API or consistent hypermedia; etag for concurrency control on batch updates

## Relevant Business Logic

- Verify batch exists, is not soft-deleted, has sufficient unreserved quantity for splits
- Original batch quantity reduced by sum of splits; create new Batch records with linked product/vendor, copied attributes/barcodes/pricing where applicable
- Post ledger entries for adjustment (debit/credit movements); support valuation methods (e.g., FIFO/LIFO)
- Trigger reservations/consumption checks; update cycle count accuracy if applicable
- Handle promotions/overrides: Propagate if relevant to sub-batches
- Audit: Log audit_event for split action, with user_id, before/after states
- Integrations: If batch tied to orders/shipments, ensure no conflicts; notify via webhooks if configured (e.g., inventory change delivery)
- Edge cases: Splits summing to original quantity; zero-quantity invalid; partial reservations block full split
- Compliance: Ensure reversals possible via adjustments; exportable for accounting reconciliation"
93,batch,Merge Batches,Merge batches of same product,api/batches/merge,post,Admin,Implement Merge Batches API Endpoint (POST /api/batches/merge),"## Overview

This GitHub issue is for implementing the 'Merge Batches' API endpoint in the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations. Deshio features ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, and promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers.

The endpoint enables merging batches of the same product, which is essential for efficient inventory management in a batch-centric system. This involves combining quantities, updating stock ledgers transactionally, handling any reservations or adjustments, and ensuring referential integrity across related entities like shipments, dispatches, and RMAs. All data is stored in UTC, with soft deletes for archival, EAV for attributes, polymorphic notes/attachments, and strict referential links. State machines drive legality of transitions, with conflicts returning RFC7807 problem+json. Middleware includes auth (JWT/session/API key), RBAC & permission checks, branch scope, throttles, idempotency, input sanitizer, and domain guards for inventory/reservation/cycle-count events.

## API Specifications

- **Category:** batch
- **Title:** Merge Batches
- **Description:** Merge batches of same product
- **Route:** api/batches/merge
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST /api/batches/merge endpoint in a Laravel controller
- [ ] Validate input data, including batch IDs, product ID consistency, and quantities
- [ ] Ensure merging only occurs for batches of the same product and store/branch
- [ ] Handle transactional stock movements, ledger postings, and reversals if needed
- [ ] Integrate with inventory reservations, adjustments, and cycle counts to prevent conflicts
- [ ] Add RBAC checks for admin authentication and permissions
- [ ] Implement proper error handling with RFC7807 problem+json for invalid states or conflicts
- [ ] Write unit and integration tests covering success, failure, and edge cases (e.g., reserved batches, insufficient quantities)
- [ ] Document the endpoint in API specs with request/response examples
- [ ] Ensure compatibility with bulk operations, search/autosuggest, and reporting (e.g., inventory aging, low stock)
- [ ] Verify soft deletes and audit events are logged for the merge operation

## Technical Requirements

- Use Laravel framework: Define route in api.php, create a dedicated controller (e.g., BatchController@merge) with dependency injection for services/repositories.
- Input validation: Use FormRequest for validation. Expected request format (JSON body):
  {
    ""product_id"": ""uuid-or-id"",
    ""target_batch_id"": ""uuid-or-id"",
    ""source_batch_ids"": [""uuid-or-id"", ""uuid-or-id""],
    ""reason"": ""string (optional, for notes/audit)""
  }
  Validate that all batches belong to the same product, are not soft-deleted, and have compatible attributes (e.g., expiry, lot numbers).
- Business logic: 
  - Verify batches are mergeable (same product, no active reservations/shipments/dispatches blocking merge).
  - Transfer quantities from source batches to target batch, update valuation/ledgers transactionally.
  - Handle polymorphic attachments/notes if applicable.
  - Post ledger entries for the movement (accounting: transaction headers + ledger_entry lines).
  - Trigger any related events (e.g., reindex inventory, update cycle count accuracy, notify via webhooks if integrated).
  - Use state machines to validate transition legality; soft-delete or mark source batches as merged.
- Expected response format: 
  - Success (200): {""message"": ""Batches merged successfully"", ""merged_batch"": {batch details}, ""affected_batches"": [ids]}
  - Error (e.g., 400/409): RFC7807 problem+json, e.g., {""type"": ""https://example.com/probs/invalid-merge"", ""title"": ""Merge not allowed"", ""detail"": ""Batch has active reservation""}
- Observability: Log audit_event, request-id, PII masking; add metrics for merge operations; support caching/etag.
- Integrations: Ensure consistency with fulfillment (shipments/dispatch), returns (RMA), and reporting (revenue/units by product, inventory aging).

## Authentication/Authorization Requirements

- Require Admin authentication via JWT, session, or API key.
- Enforce RBAC: User must have 'admin' role or specific permission (e.g., 'batch.merge') via user_role and ability (role↔perm).
- Apply middleware: active user, email-verified, 2FA (if enabled), branch scope (merge within user's scoped branches), throttles, idempotency (for retry safety), and domain guards for inventory/reservation/cycle-count/fraud.
- Optional: Tenancy if multi-tenant setup.
- Security: TLS/HSTS, CORS, JSON limits, versioned content-negotiation, locale/tz, upload mime guard (if attachments involved), input sanitizer.

## Expected Request/Response Format Considerations

- Request: JSON body as outlined; support idempotency key for safe retries.
- Response: Always JSON; use HTTP status codes appropriately (200 success, 201 for creation if new batch implied, 400/422 validation errors, 403 unauthorized, 409 conflict for state machine violations).
- Bulk considerations: Allow merging multiple source batches; return summary of changes.
- Error responses: Standardized problem+json with titles/details for compliance and debugging.
- Edge cases: Handle zero-quantity batches, cross-store merges (if allowed), promotions/pricing impacts, and integration with carriers/webhooks for notifications."
94,batch,Reprice Batch,Update sell price for batch,api/batches/{id}/reprice,post,Admin,Implement POST /api/batches/{id}/reprice for Batch Repricing,"## Overview

This GitHub issue covers the implementation of the Reprice Batch API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes, media, barcodes, and pricing (including price_override). Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers.

The Reprice Batch endpoint allows administrators to update the sell price for a specific batch, which is central to inventory management. This fits into the broader pricing and inventory domains, enabling deterministic pricing updates while maintaining consistency with ledgers, valuations, and reporting (e.g., price change history, inventory aging). State machines ensure legality of transitions, with conflicts returning RFC7807 problem+json. Data is stored in UTC, with soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential links.

## API Specifications

- **Category:** batch
- **Title:** Reprice Batch
- **Description:** Update sell price for batch
- **Route:** api/batches/{id}/reprice
- **Method:** POST
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the endpoint in a Laravel controller (e.g., BatchController) with proper routing in api.php
- [ ] Add input validation for the batch ID and new sell price (e.g., required, numeric, positive)
- [ ] Ensure the endpoint updates the batch's sell price field and handles price_override if applicable
- [ ] Verify authentication and authorization for Admin users only, including RBAC permission checks
- [ ] Handle errors appropriately, returning RFC7807 problem+json for validation failures, unauthorized access, or batch not found
- [ ] Trigger relevant business logic, such as audit_event logging, ledger_entry for price changes, and updates to valuation/ledgers
- [ ] Include middleware stack: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, throttles, idempotency, input sanitizer, domain guards (e.g., reservation/promo/override), cache headers
- [ ] Write unit tests for controller logic, validation, and error cases
- [ ] Write integration tests for full request/response flow, including authentication and database updates
- [ ] Ensure compatibility with bulk operations, search/autosuggest, and reporting (e.g., price change history, inventory valuation)
- [ ] Confirm soft deletes and referential integrity are respected (e.g., no updates on deleted batches)

## Technical Requirements

- Use Laravel framework: Define route in routes/api.php with resource prefix; create or extend BatchController with reprice method
- Implement input validation using FormRequest classes (e.g., RepriceBatchRequest) for new_price field
- Update batch model: Modify sell_price attribute, potentially via price_override; use Eloquent for database interactions
- Integrate with state machines for any transition legality (e.g., if batch state affects repricing)
- Handle business events: Post to accounting ledger for price movements/reversals; log audit_event; update related inventory valuations and ledgers transactionally
- Apply observability: Include request-id, PII masking, health/metrics; use queues/caching/etag where applicable
- Ensure deterministic behavior for admin assignments and safe reservation/consumption impacts
- Support integrations: If repricing affects orders/promos, synchronize with order.payment_status or promo impact reporting

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have role/permission linked to batch repricing (e.g., ability role↔perm for inventory/pricing updates)
- Middleware checks: Active user, email-verified, TOTP MFA + backup codes if enabled; branch scope for multi-store access
- Security: Input sanitizer, domain guards for override/fraud, throttles, idempotency keys to prevent duplicates

## Expected Request/Response Format Considerations

- **Request:** JSON body with { ""new_price"": numeric_value } (e.g., {""new_price"": 29.99}); batch ID as URL parameter {id}
- **Response:** On success, 200 OK with updated batch JSON (including sell_price, timestamps) or minimal success message; use content-negotiation for versioned responses
- **Errors:** 4xx/5xx with RFC7807 problem+json (e.g., {""title"": ""Validation Error"", ""detail"": ""Invalid price"", ""status"": 422}); 401/403 for auth failures; 404 for batch not found
- Formats align with Deshio standards: UTC timestamps, soft delete flags, polymorphic relations; optional etag for caching

## Relevant Business Logic

- Validate batch exists and is not soft-deleted; check state (e.g., via state machine) for repricing eligibility (e.g., not reserved/fulfilled if impacts orders)
- Update sell_price atomically; propagate to related entities (e.g., product pricing, inventory valuation, ledgers with transaction headers + ledger_entry lines)
- Handle reversals if needed; ensure consistency for reporting (e.g., promo impact, price change history, LTV/AOV)
- Transactional stock/financial events: Post ledger on price update; support cycle count accuracy and low stock alerts if valuation changes
- Conflicts (e.g., concurrent updates) resolved via optimistic locking or idempotency; log all events for audits/compliance
- Integrates with order domain: If batch in pending orders, flag for review; synchronize with shipments/returns/RMA if affects fulfillment/refunds
- Enables features like bulk import/export for pricing, feature flags for repricing rules, and system maintenance (e.g., reindex after updates)"
95,batch,Move Batch Store,Move batch ownership to store,api/batches/{id}/move-store,post,Admin,Implement API: Move Batch Ownership to Store (POST /api/batches/{id}/move-store),"## Overview

Deshio is a Laravel-based ERP system for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers.

Order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment covers shipments and inter-store dispatch with transactional stock movements. Returns handle RMA, refunds, exchanges. Payments manage intent→capture/void, refunds, synchronization. Accounting uses transaction headers + ledger_entry lines for movements, reversals, reconciliation/export.

Services include service/service_order with lifecycle and profitability. Integrations cover carriers, waybills/rates/tracking, webhooks, notifications. Security features user/role/permission with multi-role support, sessions, email verification, password reset, TOTP MFA, API keys. Observability includes audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines ensure legal transitions for orders, items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links. Design enables deterministic admin assignment, safe reservation/consumption, consistent ledger posting on stock/financial events.

This API endpoint, categorized under 'batch', allows moving batch ownership to a different store. It supports inventory management by enabling inter-store batch transfers, ensuring transactional stock movements, ledger postings, and state machine compliance for inventory legality.

## API Specifications

- **Category:** batch
- **Title:** Move Batch Store
- **Description:** Move batch ownership to store
- **Route:** api/batches/{id}/move-store
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint handles POST requests to move batch ownership to a specified store
- [ ] Validates batch ID exists and is batch-centric inventory item
- [ ] Ensures target store is valid and accessible to admin
- [ ] Performs transactional stock movement from source to target store
- [ ] Posts consistent ledger entries for the inventory transfer
- [ ] Updates batch state via state machine, rejecting illegal transitions with RFC7807 problem+json
- [ ] Applies RBAC: requires admin role with inventory management permissions
- [ ] Handles soft deletes: prevents moves on archived batches
- [ ] Supports idempotency for retry safety
- [ ] Includes audit_event logging for the move operation
- [ ] Returns 200 OK on success with updated batch details
- [ ] Returns appropriate errors (e.g., 404 for invalid batch, 403 for unauthorized, 422 for validation)
- [ ] Unit and integration tests cover happy path, edge cases, and errors
- [ ] Documentation updated in API specs

## Technical Requirements

- Implement in Laravel: Define route in api.php, create BatchController method for moveStore
- Use resource routing for batches if not already, with this as a custom action
- Input validation: Request body should include 'target_store_id' (required, integer, exists in stores table); optional 'notes' for polymorphic attachment
- Authorization: Use middleware for Admin auth (JWT/API key), RBAC check for inventory.move permission, branch scope if multi-tenant
- Business logic: Verify batch current store ownership; execute atomic transaction for stock deduction/addition, ledger_entry creation (debit/credit inventory accounts), audit log; trigger any notifications/webhooks for inventory changes; ensure UTC timestamps and EAV attribute preservation
- Error handling: Use Laravel exceptions, return JSON with problem+json for state conflicts; domain guards for reservation/promo/override conflicts
- Observability: Add request-id tracing, log the operation, metrics for inventory moves
- Performance: Use queues if move involves heavy computation (e.g., valuation recalc); caching/etag for batch reads

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC: User must have role with permission 'batches.move-store' or equivalent inventory transfer ability
- Additional checks: Active user, email-verified, 2FA if enabled; branch scope to ensure store access
- Middleware stack: auth, active-user, email-verified, 2fa, rbac, branch-scope

## Expected Request/Response Format Considerations

- **Request:** JSON body: {""target_store_id"": 123, ""notes"": ""Optional transfer reason""}
  - Headers: Accept: application/json, Content-Type: application/json, Authorization: Bearer <token>
- **Success Response (200):** {""data"": {""id"": <batch_id>, ""store_id"": <new_store_id>, ""moved_at"": ""UTC timestamp"", ""ledger_entry_id"": <id>}, ""message"": ""Batch moved successfully""}
- **Error Response (e.g., 422):** RFC7807 format: {""type"": ""https://problems.example.net/validation"", ""title"": ""Validation Error"", ""detail"": ""Target store invalid"", ""status"": 422, ""invalid-params"": [{""field"": ""target_store_id"", ""reason"": ""Store not found""}]}
- Versioned: Support content-negotiation for API version; locale/tz for timestamps
- Idempotency: Use key in header or body to prevent duplicate moves

## Relevant Business Logic

- Batch-centric inventory: Move involves transferring ownership, updating quantity_available in source/target stores
- Transactional: All or nothing – stock movements, reservations release/consume, ledger posting, audit
- State machine: Ensure batch state allows move (e.g., not reserved/shipped); illegal transitions blocked
- Integrations: Trigger inventory aging/low stock reports update; possible webhook for external systems
- Compliance: PII masking if notes include sensitive data; soft delete preservation
- Edge cases: Inter-store dispatch linkage if related to fulfillment; valuation recalc if price_override affected; cycle count implications"
96,inventory,Inventory Snapshot,List inventory by filters,api/inventory,get,Employee,Implement Inventory Snapshot API: GET /api/inventory,"## Overview

This GitHub issue is for implementing the Inventory Snapshot API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The Inventory Snapshot endpoint allows listing inventory by various filters, providing a current view of batch-centric inventory, including reservations, adjustments, and ledgers.

## API Specifications

- **Category:** inventory
- **Title:** Inventory Snapshot
- **Description:** List inventory by filters
- **Route:** api/inventory
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET /api/inventory endpoint to list inventory snapshots by filters
- [ ] Support query parameters for filtering (e.g., by store/branch, product, batch, date range, stock levels)
- [ ] Ensure response reflects current inventory state, accounting for reservations, adjustments, and soft deletes
- [ ] Apply branch scope and RBAC permissions for Employee authentication
- [ ] Handle errors with RFC7807 problem+json for invalid filters or unauthorized access
- [ ] Include pagination, sorting, and search capabilities
- [ ] Write unit and integration tests covering happy paths, edge cases, and authentication
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger)
- [ ] Verify middleware integration (auth, throttling, request ID, etc.)
- [ ] Ensure data is returned in UTC and respects EAV attributes

## Technical Requirements

- Use Laravel framework: Define route in api.php, create InventoryController with index method
- Implement Eloquent queries on inventory-related models (e.g., batches, reservations, ledgers) with joins for products, stores, and attributes
- Add request validation using FormRequest for query parameters (e.g., filters, pagination)
- Integrate state machine checks if applicable for inventory states
- Use caching/etag for performance on repeated queries
- Log audit events for access to inventory data
- Handle bulk-like filtering efficiently with database indexes
- Ensure idempotency and replay defense via middleware

## Authentication/Authorization Requirements

- Require Employee authentication via JWT, session, or API key
- Enforce RBAC: User must have permission to view inventory (e.g., 'inventory.view')
- Apply branch scope: Limit results to user's assigned branches/stores
- Include active user, email-verified, and optional 2FA checks via middleware
- Reject unauthorized requests with 401/403 and problem+json details

## Expected Request/Response Format Considerations

- **Request:** GET /api/inventory?filter[store_id]=1&filter[product_id]=123&filter[batch_expiry_after]=2023-01-01&per_page=50&page=1&sort=quantity_desc
  - Query params: Flexible filters for location, product, batch, quantity thresholds, dates; pagination (per_page, page); sorting
  - Content-Type: application/json; Accept: application/json (versioned)
- **Response:** 200 OK with JSON array of inventory snapshots
  - Structure: [{id, product_id, batch_id, store_id, quantity_available, quantity_reserved, expiry_date, valuation, attributes, created_at, updated_at}, ...]
  - Include metadata: {data: [...], links: {...}, meta: {total, per_page, current_page}}
  - Errors: 4xx/5xx with RFC7807 {title, detail, type, status}
  - Use ETag for caching; respect locale/tz if applicable

## Relevant Business Logic

- Inventory is batch-centric; snapshot must aggregate per-unit items if applicable
- Account for reservations (e.g., from orders/fulfillments) to show available vs. total stock
- Include adjustments, cycle counts, and ledger impacts in the current state
- Support low stock/inventory aging filters for reporting
- Ensure transactional consistency: No partial snapshots; use database transactions for queries if needed
- Handle soft deletes: Exclude archived data unless explicitly filtered
- Integrate with promotions/pricing if filters include overrides
- Conflicts (e.g., invalid state transitions) return problem+json; use state machines for inventory legality"
97,inventory,Reserve Inventory,Reserve items for order,api/inventory/reserve,post,Employee,Implement API: Reserve Inventory for Orders (POST /api/inventory/reserve),"## Overview

This GitHub issue is for implementing the 'Reserve Inventory' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs built over a normalized ERD. Core entities include products/categories/vendors with attributes (fields/features), media (product images), barcodes, pricing (price overrides), and promotions. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. Orders involve order/order_item states (pending → confirmed → fulfilled|cancelled), assignment to stores, notes/attachments, promotions, taxes, and fraud flags. Fulfillment includes shipments (shipment/shipment_item) and inter-store dispatches (dispatch + tracking, scan events, POD) with transactional stock movements. Returns handle RMAs (return/return_item), receiving/restocking/scrap, refunds, and exchanges (exchange_order). Payments manage intents → captures/voids, refunds, and order.payment_status synchronization. Accounting uses transaction headers + ledger_entry lines for all movements, reversals, and reconciliation/export. Services include service/service_order with lifecycle and profitability. Integrations cover carriers/accounts, waybills/rates/tracking, webhooks, and notification templates (email/SMS). Security and identity features user/role/permission with abilities (role ↔ perm) and multi-role assignments, sessions, email verification, password reset, TOTP MFA + backup codes, and API keys. Observability and compliance include audit_event, logs, request-id, PII masking, health/metrics, queues, caching/ETag. Middleware encompasses TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user checks, email verification, 2FA, RBAC/permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitization, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload MIME guards, provider webhook signatures + replay defense, and cache headers. Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, and activity. State machines enforce legal transitions for orders, order items, dispatches, shipments, returns, payments, and cycle counts, with conflicts returning RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindexing, backups/restores, feature flags, and system maintenance. Data is stored in UTC with soft deletes for archival, EAV for attributes, polymorphic notes/attachments, and strict referential links across junctions. The design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The 'Reserve Inventory' endpoint reserves items for an order, ensuring availability for fulfillment while handling batch-centric inventory, reservations, and transactional stock movements. It integrates with order states, store assignments, and ledger postings, using state machines for legality.

## API Specifications

- **Category:** inventory
- **Title:** Reserve Inventory
- **Description:** Reserve items for order
- **Route:** api/inventory/reserve
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST /api/inventory/reserve endpoint in Laravel
- [ ] Add comprehensive input validation for request data (e.g., order_id, items with product_id, quantity, batch_id)
- [ ] Ensure proper authentication and authorization for Employee users with RBAC checks
- [ ] Handle business logic for reservations: check availability in batch-centric inventory, create reservations, update order states if needed, post to ledgers
- [ ] Implement error handling with RFC7807 problem+json for conflicts (e.g., insufficient stock, invalid transitions)
- [ ] Add unit and integration tests covering success, failure, and edge cases (e.g., over-reservation, concurrent requests)
- [ ] Verify middleware application: auth, RBAC, branch scope, idempotency, input sanitization, domain guards for reservations
- [ ] Ensure response includes reservation details (e.g., reservation_id, reserved quantities) or success status
- [ ] Document the endpoint in API specs with request/response examples
- [ ] Test integration with related entities (orders, inventory ledgers, state machines)

## Technical Requirements

- Use Laravel controller (e.g., InventoryController@reserve) and define route in api.php with middleware stack
- Implement input validation using Form Requests or Validator, enforcing rules like required order_id, valid product_ids, positive quantities, existing batches with sufficient stock
- Apply state machine checks for order and inventory transitions to ensure legal reservations
- Handle transactional operations: use DB transactions for atomicity in creating reservations, deducting available stock, and posting ledger entries
- Integrate with inventory domain: support batch-centric reservations, optional per-unit items, and prevent over-reservation across stores/branches
- Include audit logging for reservation events and request-id tracing
- Optimize for performance: use queues if needed for heavy ledger postings, caching for stock checks
- Follow Deshio conventions: UTC timestamps, soft deletes, EAV attributes, polymorphic relations
- Add idempotency support to handle duplicate requests safely

## Authentication/Authorization Requirements

- Require Employee authentication via JWT, session, or API key
- Enforce RBAC: Employee must have permissions for inventory reservations (e.g., 'inventory.reserve' ability)
- Apply branch scope: Reservations limited to employee's assigned stores/branches
- Include active user, email-verified, and optional 2FA checks via middleware
- Use domain guards to validate order ownership and prevent unauthorized reservations

## Expected Request/Response Format Considerations

- **Request Format:** JSON body with:
  - order_id: string (required, references valid pending/confirmed order)
  - items: array of objects, each with product_id (string), quantity (integer >0), batch_id (string, optional for batch selection), store_id (string, for branch scoping)
  - notes: string (optional, polymorphic attachment)
  Example:
  {
    ""order_id"": ""ord-123"",
    ""items"": [
      {""product_id"": ""prod-456"", ""quantity"": 5, ""batch_id"": ""batch-789"", ""store_id"": ""store-101""}
    ],
    ""notes"": ""Urgent reservation""
  }

- **Response Format:** JSON with 200 OK on success, including reservation summary; 4xx/5xx with RFC7807 problem+json on errors
  Success Example (200):
  {
    ""success"": true,
    ""data"": {
      ""reservation_id"": ""res-001"",
      ""reserved_items"": [
        {""product_id"": ""prod-456"", ""quantity_reserved"": 5, ""batch_id"": ""batch-789""}
      ],
      ""order_status"": ""confirmed""
    }
  }
  Error Example (422):
  {
    ""title"": ""Validation Error"",
    ""detail"": ""Insufficient stock for product prod-456"",
    ""status"": 422,
    ""type"": ""https://example.com/probs/validation""
  }
- Support content-negotiation for versioned APIs, locale/tz handling, and ETag caching

## Relevant Business Logic

- Reservations deduct from available inventory without consuming (until fulfillment); support order assignment to stores
- Use state machines to validate transitions (e.g., order must be pending/confirmed; inventory must have available batches)
- Handle conflicts: insufficient stock, fraud-flagged orders, or branch mismatches return problems
- Post consistent ledger entries for reservation events (e.g., debit available stock, credit reserved stock)
- Integrate with promotions/taxes if reservation affects pricing; support attachments/notes
- Ensure safe concurrent handling: use locks or optimistic concurrency for stock checks
- On success, potentially trigger notifications (email/SMS) via templates and update order states
- Comply with observability: log events, mask PII, track metrics for reservation SLAs and inventory aging"
98,inventory,Release Reservation,Release reserved items,api/inventory/reserve/{reservation_id}/release,post,Employee,Implement Release Reservation API for Inventory,"## Overview

This GitHub issue is for implementing the ""Release Reservation"" API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD that covers catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. This endpoint specifically handles releasing reserved items, which is crucial for managing inventory reservations in the order fulfillment process. Order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment involves shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.

The design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.

## API Specifications

- **Category:** inventory
- **Title:** Release Reservation
- **Description:** Release reserved items
- **Route:** api/inventory/reserve/{reservation_id}/release
- **HTTP Method:** POST
- **Authentication:** Employee

Middleware plan includes: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

## Acceptance Criteria

- [ ] Implement the POST endpoint at api/inventory/reserve/{reservation_id}/release to release reserved items
- [ ] Ensure the endpoint authenticates as Employee and enforces RBAC permissions for inventory management
- [ ] Add input validation for {reservation_id} (must exist and be releasable)
- [ ] Handle business logic for releasing reservations, including updating inventory ledgers and stock movements transactionally
- [ ] Return appropriate success response (e.g., 200 OK with updated reservation details) and error responses using RFC7807 problem+json for invalid states or conflicts
- [ ] Write unit and integration tests covering happy path, invalid ID, unauthorized access, and state machine transitions
- [ ] Add audit logging for the release event
- [ ] Ensure idempotency for repeated releases
- [ ] Verify compatibility with branch scope and soft deletes

## Technical Requirements

- Use Laravel controller and define the route in api.php with appropriate middleware stack (auth, RBAC, branch scope, idempotency, input sanitizer, domain guards for reservation)
- Implement in a dedicated InventoryReservationController or similar
- Use Eloquent models for Reservation and related Inventory/Batch entities
- Leverage state machines to validate and execute the release transition
- Post ledger entries for the stock release event
- Handle polymorphic attachments/notes if applicable to reservations
- Ensure UTC handling and no PII exposure
- Add OpenAPI/Swagger documentation for the endpoint

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT/session/API key
- Enforce active user, email-verified, and 2FA if enabled
- RBAC check: Employee must have permissions for inventory reservation management (e.g., 'inventory.release-reservation')
- Branch scope: Release only affects reservations within the user's scoped branches

## Expected Request/Response Format Considerations

- **Request:** POST with {reservation_id} in path; optional JSON body for partial release if applicable (e.g., {""items"": [ids]}), but primarily path-based
- **Response:** 200 OK with JSON { ""success"": true, ""reservation"": {updated details}, ""released_items"": [...] } or 422/403/404 errors in RFC7807 format
- Use versioned content-negotiation (e.g., Accept: application/vnd.deshio.v1+json)
- Include ETag for caching if reservation data is cacheable
- JSON limits and sanitizer applied

## Relevant Business Logic

- Reservations are part of inventory management, tied to orders or dispatches; releasing frees up batch stock for other uses
- Transactional: Rollback on failure to maintain ledger consistency
- Trigger notifications/webhooks if release affects order status
- Prevent release if reservation is in confirmed/fulfilled state (use state machine)
- Integrate with cycle counts/valuations post-release
- Support bulk operations if extending to future bulk release API"
99,inventory,Transfer Stock,Transfer between stores,api/inventory/transfer,post,Admin,Implement POST /api/inventory/transfer for Stock Transfers Between Stores,"## Overview

This GitHub issue is for implementing the 'Transfer Stock' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs built over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist.

Inventory management is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes states (pending→confirmed→fulfilled|cancelled), assignment to stores, notes/attachments, promos, taxes, and fraud flags. Fulfillment involves shipments and inter-store dispatches with tracking, scan events, and proof-of-delivery (POD), ensuring transactional stock movements.

Returns are handled via RMAs with receive/restock/scrap, refunds, and exchanges. Payments follow intent→capture/void lifecycles with refund synchronization. Accounting uses transaction headers and ledger entries for all movements, including reversals and reconciliation.

Services include service orders with lifecycle and profitability tracking. Integrations cover carriers, waybills, rates, tracking, webhooks, and notification templates. Security features user/role/permission with abilities, sessions, email verification, password reset, TOTP MFA, backup codes, and API keys.

Observability includes audit events, logs, request IDs, PII masking, health/metrics, queues, caching/ETags. Middleware encompasses TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user checks, email verification, 2FA, RBAC/permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitization, domain guards (for orders/payments/dispatch/reservations/promos/overrides/cycle-counts/fraud), upload MIME guards, webhook signatures with replay defense, and cache headers.

Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, and activity.

State machines enforce legal transitions for orders, items, dispatches, shipments, returns, payments, and cycle counts, with conflicts returning RFC7807 problem+json responses. APIs support bulk import/export, search/autosuggest, attachments, reindexing, backups/restores, feature flags, and system maintenance. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential integrity.

The design ensures deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting for every stock/financial event.

This endpoint enables transferring stock between stores, likely involving inter-store dispatch creation, transactional stock movements from source to destination stores, inventory ledger updates, and optional batch considerations.

## API Specifications

- **Category:** inventory
- **Title:** Transfer Stock
- **Description:** Transfer between stores
- **Route:** api/inventory/transfer
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint handles POST requests to /api/inventory/transfer and returns a 201 Created on success
- [ ] Requires Admin authentication; unauthorized requests return 401 Unauthorized
- [ ] Validates input parameters (e.g., from_store_id, to_store_id, items array with product_id, quantity, optional batch_id)
- [ ] Performs business logic for stock transfer: deducts from source store inventory, adds to destination, creates dispatch record if applicable, updates ledgers transactionally
- [ ] Handles sufficient stock checks; insufficient stock returns 422 Unprocessable Entity with RFC7807 error details
- [ ] Supports batch-centric transfers with optional per-unit handling
- [ ] Integrates with state machines for legal transitions and audit logging
- [ ] Includes proper error handling for conflicts (e.g., store not found, product invalid) using problem+json
- [ ] Response includes transfer details (e.g., transfer ID, updated quantities, dispatch ID if created)
- [ ] Unit and integration tests cover happy path, edge cases (e.g., zero quantity, invalid stores), and error scenarios
- [ ] Endpoint respects middleware: RBAC (admin permission), branch scope, idempotency, input sanitization, and domain guards for inventory/reservations
- [ ] Data integrity maintained with UTC timestamps, soft deletes if applicable, and referential links
- [ ] Performance considerations: efficient queries for inventory lookups, transactional atomicity to prevent partial transfers

## Technical Requirements

- Implement in Laravel: Define route in api.php, create dedicated controller (e.g., InventoryTransferController) with store method
- Use FormRequest for input validation (e.g., required from_store_id/to_store_id as integers, items as array of objects with product_id, quantity > 0)
- Integrate with Eloquent models: Store, Product, InventoryBatch, Dispatch, LedgerEntry; ensure polymorphic relations for notes/attachments if needed
- Business logic in service class (e.g., StockTransferService): Check stock availability (reservations/adjustments), perform atomic DB transactions for movements, post to ledgers, trigger state machine transitions
- Handle inter-store dispatch creation with tracking/scan events if transfer requires fulfillment
- Authentication/authorization: Use middleware for JWT/API key auth, admin role/permission check (e.g., 'inventory.transfer' permission), active user/email-verified/2FA if enabled
- Request format: JSON body, e.g., {""from_store_id"": 1, ""to_store_id"": 2, ""items"": [{""product_id"": 123, ""quantity"": 10, ""batch_id"": null}]}, with idempotency key header
- Response format: JSON, e.g., 201 {""id"": 456, ""status"": ""pending"", ""from_store"": {...}, ""to_store"": {...}, ""items"": [...], ""dispatch_id"": 789}, or 200 for dry-run if supported; errors as RFC7807
- Error handling: Use exceptions for validation/domain errors, log with request ID, audit events for transfers
- Testing: PHPUnit tests for controller/service, feature tests for full flow, mock auth/RBAC
- Observability: Add metrics for transfer success/failure rates, queue if async processing needed (e.g., for notifications)
- Security: Sanitize inputs, guard against over-transfer (e.g., via cycle count accuracy), PII masking if customer data involved
- Integrations: Trigger webhooks for inventory changes, notifications (email/SMS) for transfer completion, update reports/analytics (e.g., inventory aging)
- Documentation: Add OpenAPI/Swagger annotations for endpoint, include examples in issue comments post-implementation"
100,inventory,Adjust Stock,Manual stock adjustment,api/inventory/adjust,post,Admin,Implement Adjust Stock API Endpoint for Inventory,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue covers the implementation of the 'Adjust Stock' API endpoint. This endpoint enables manual stock adjustments in the inventory domain, which is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. Core entities include product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers + tags/blacklist. Adjustments must ensure transactional stock movements, consistent ledger posting on every stock event, and adherence to state machines for legality of transitions. Data is stored in UTC, with soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential links.

The endpoint handles manual stock adjustments, integrating with accounting (transaction headers + ledger_entry lines for movements; reversals; reconciliation/export), observability (audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag), and middleware (TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers). Reporting/analytics include inventory aging/low stock, cycle count accuracy. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. State machines drive transitions; conflicts return RFC7807 problem+json.

## API Specifications

- **Category:** inventory
- **Title:** Adjust Stock
- **Description:** Manual stock adjustment
- **Route:** api/inventory/adjust
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST /api/inventory/adjust endpoint in Laravel controller
- [ ] Add comprehensive input validation for adjustment details (e.g., branch/store, product/batch, quantity delta, reason)
- [ ] Ensure adjustment triggers transactional stock movements, ledger posting, and audit events
- [ ] Handle state machine transitions for inventory states, returning RFC7807 errors on conflicts
- [ ] Integrate RBAC permission checks for admin users with branch scope
- [ ] Write unit and integration tests covering success, validation errors, authorization failures, and edge cases (e.g., negative adjustments, insufficient stock)
- [ ] Verify idempotency for repeated requests
- [ ] Document request/response schemas in OpenAPI/Swagger
- [ ] Ensure compatibility with middleware stack (auth, throttling, sanitization, domain guards for inventory/reservation/override/cycle-count)
- [ ] Test integration with related domains (orders, fulfillment, accounting)

## Technical Requirements

- Use Laravel framework: Define route in api.php, create InventoryAdjustController with store method
- Implement Eloquent models for inventory batches/items, transactions, and ledgers; use soft deletes and UTC timestamps
- Apply Request validation class with rules for required fields (e.g., branch_id, product_id, batch_id, adjustment_type [add/subtract], quantity, reason)
- Use Laravel's queueing for async ledger posting if needed, with request-id tracing
- Handle attachments/notes polymorphically if adjustment includes them
- Ensure referential integrity across junctions (e.g., product attributes, store branches)
- Support feature flags for enabling/disabling adjustments
- Include caching/etag for related inventory queries; PII masking in logs
- For bulk adjustments, consider extending to support array inputs in future, but start with single adjustment
- Error handling: Use problem+json for validation/domain errors; HTTP 4xx/5xx appropriately

## Authentication/Authorization Requirements

- Require Admin authentication via JWT/session/API key
- Enforce active user, email-verified, and 2FA (TOTP MFA + backup codes) middleware
- RBAC: User must have role/permission for inventory adjustments (ability: role↔perm, user_role multi-role)
- Branch scope: Adjustments limited to user's assigned branches/stores
- Optional tenancy if multi-tenant setup
- Sessions with email verification and password reset integration

## Expected Request/Response Format Considerations

- **Request:** JSON body, e.g., {""branch_id"": 1, ""product_id"": 123, ""batch_id"": null, ""adjustment_type"": ""add"", ""quantity"": 10, ""reason"": ""Cycle count correction"", ""notes"": ""Optional note""}. Support content-negotiation for versioned API (e.g., /v1/inventory/adjust)
- **Response:** On success, 201 Created with JSON {""id"": adjustment_id, ""status"": ""completed"", ""new_stock_level"": 50}. On error, 4xx with RFC7807 problem+json (e.g., {""type"": ""https://example.com/probs/invalid-quantity"", ""title"": ""Invalid quantity"", ""detail"": ""Quantity must be positive""})
- Use locale/tz from request headers; sanitize inputs; JSON limits enforced
- Idempotency: Use key from header/body to prevent duplicate adjustments

## Relevant Business Logic

- Inventory adjustments must be deterministic, safe for reservations/consumption, and post to ledgers on every event (e.g., add stock increases available, triggers valuation update)
- Support batch-centric adjustments; optional per-unit if no batch
- Integrate with cycle counts (accuracy reporting), low stock alerts, inventory aging
- For orders/fulfillment: Ensure adjustments don't conflict with reservations (use domain guards)
- Accounting: Create transaction header + ledger_entry lines; support reversals
- Auditing: Log audit_event with request-id; track changes for compliance
- Promotions/pricing: Adjustments may affect price overrides or promo eligibility indirectly via stock levels
- Returns/services: Align with RMA restock or service_order profitability if related
- Conflicts (e.g., concurrent reservations): Use state machines to validate transitions; rollback on failure
- Enable admin assignment for related online orders if adjustment impacts availability"
101,inventory,Start Cycle Count,Open a cycle count session,api/inventory/cycle-counts,post,Admin,Implement API: Start Cycle Count (POST /api/inventory/cycle-counts),"## Overview

This GitHub issue is for implementing the 'Start Cycle Count' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs built over a normalized ERD covering domains such as catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. This endpoint specifically opens a cycle count session, which is part of the inventory management domain enabling cycle counts for accuracy, aging, low stock monitoring, and cycle count accuracy reporting.

The design ensures deterministic admin assignment, safe reservation/consumption, and consistent ledger posting on stock events. Data is stored in UTC, uses soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential links. State machines drive legality of transitions for cycle counts, with conflicts returning RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (including cycle-count), upload mime guard, cache headers. Observability covers audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Reporting includes inventory aging/low stock, cycle count accuracy.

## API Specifications

- **Category:** inventory
- **Title:** Start Cycle Count
- **Description:** Open a cycle count session
- **Route:** api/inventory/cycle-counts
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST endpoint to start a cycle count session
- [ ] Validate input parameters for required fields like store/branch, count type (full/partial), and optional filters (e.g., product categories, locations)
- [ ] Ensure the endpoint creates a new cycle count record with initial state (e.g., 'open') and associates it with the requesting admin and scoped branch/store
- [ ] Handle state machine transitions for cycle count lifecycle, enforcing legality and returning RFC7807 errors for invalid states
- [ ] Integrate with inventory ledger for any initial postings or reservations if applicable
- [ ] Add unit and integration tests covering success, validation failures, unauthorized access, and error scenarios
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger) including request/response schemas
- [ ] Verify compatibility with bulk operations, search/autosuggest for cycle counts, and reporting metrics (e.g., cycle count accuracy)
- [ ] Ensure soft deletes and archival support for cycle count records
- [ ] Test middleware stack: auth, RBAC, branch scope, throttles, idempotency, input sanitizer, domain guards for cycle-count

## Technical Requirements

- Use Laravel framework: Define route in api.php, create a dedicated controller (e.g., CycleCountController@start), and leverage Eloquent models for cycle_count entity linked to inventory batches, stores/branches, and audit_events
- Implement input validation using Laravel's Form Requests or Validator, checking for required fields (e.g., store_id, count_scope), optional EAV attributes, and referential integrity (e.g., valid branch scope)
- Handle business events: Trigger state machine for 'open' state, post to ledger if adjustments/reservations are implied, log audit_event with request-id, and support polymorphic attachments/notes
- Proper error handling: Use RFC7807 problem+json for validation/state errors, HTTP 401/403 for auth/RBAC failures, 429 for throttles; include PII masking in logs
- Integrate with queues for any async tasks (e.g., notifications), caching/etag for response optimization, and feature flags for optional behaviors
- Ensure UTC storage, soft deletes via traits, and strict junctions to related entities (e.g., products, inventory batches)
- Support versioned content-negotiation, locale/tz handling, and cache headers

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce active user, email-verified, and 2FA (TOTP + backup codes) via middleware
- RBAC checks: User must have role/permission for 'cycle-count.start' ability, scoped to branch/store via user_role multi-role assignments
- Branch scope middleware to restrict to authorized locations
- Optional tenancy isolation if multi-tenant mode is enabled

## Expected Request/Response Format Considerations

- **Request:** JSON body with fields like {""store_id"": 1, ""type"": ""full"", ""filters"": {""categories"": [1,2]}, ""notes"": ""Initial count""}; support file uploads for attachments if needed, validated by mime guard
- **Response:** 201 Created with JSON payload including cycle_count resource (id, state: 'open', store_id, created_at, etc.), etag for caching, and links for related resources (e.g., self, items)
- Use strict JSON limits, input sanitizer, and idempotency keys to prevent duplicates
- Errors: Standardized problem+json with title, detail, instance (request-id)

## Relevant Business Logic

- Cycle counts are batch-centric, supporting full/partial counts with reservations/adjustments; integrate with inventory valuation/ledgers for discrepancies
- Enforce state machine: From 'idle' to 'open' on start, preventing concurrent counts on same scope; conflicts (e.g., ongoing count) return errors
- Admin assignment is deterministic; link to user for accountability in audits/reports
- On start, initialize session with scan events support, POD-like tracking if mobile-integrated, and tie into dispatch/inventory movements
- Ensure transactional stock movements if pre-count reservations are made; post ledger_entry for count initiation
- Align with reporting: Track SLA, accuracy, aging; support low stock alerts post-count
- Handle promotions/pricing overrides if count affects availability; fraud flags if anomalies detected (via domain guards)"
102,inventory,Submit Cycle Count,Submit counted quantities,api/inventory/cycle-counts/{id}/submit,post,Admin,Implement Submit Cycle Count API Endpoint,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue focuses on implementing the ""Submit Cycle Count"" API endpoint in the inventory category. Deshio handles core entities like products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. This endpoint allows submitting counted quantities for a specific cycle count, enabling inventory accuracy updates. Order domain includes states (pending→confirmed→fulfilled|cancelled), fulfillment with shipments and dispatches, returns via RMA, payments with intents and refunds, accounting via transaction headers and ledger entries, services, integrations, security with RBAC and MFA, observability with audits and logs, middleware for security and performance, reporting/analytics, state machines for transitions (including cycle counts), bulk operations, and data in UTC with soft deletes and EAV.

## API Specifications

- **Category:** inventory
- **Title:** Submit Cycle Count
- **Description:** Submit counted quantities
- **Route:** api/inventory/cycle-counts/{id}/submit
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint handles POST requests to submit counted quantities for a given cycle count ID
- [ ] Validates input data including cycle count ID existence and user permissions
- [ ] Transitions cycle count state via state machine, ensuring legal transitions
- [ ] Updates inventory quantities based on submitted counts, posting to ledgers if needed
- [ ] Handles batch-centric inventory with optional per-unit adjustments
- [ ] Returns success response on valid submission and appropriate errors (RFC7807 problem+json) for conflicts or invalid states
- [ ] Integrates with middleware: auth (JWT/session/API key), RBAC, branch scope, input sanitizer, domain guards (cycle-count)
- [ ] Includes audit events and logging for the submission action
- [ ] Supports soft deletes and referential integrity
- [ ] Unit and integration tests cover happy path, validation errors, unauthorized access, and state transition failures
- [ ] Documentation updated for API reference

## Technical Requirements

- Implement in Laravel: Define route in api.php, create or update CycleCountController with submit method
- Use Eloquent models for cycle counts, inventory batches/items, and ledgers
- Input validation: Request body as JSON (e.g., {""items"": [{""sku"": ""string"", ""counted_qty"": integer, ""batch_id"": optional uuid}]}), validate ID as UUID, ensure cycle count is in countable state
- Business logic: Verify admin auth and branch scope; apply counts to reservations/adjustments; trigger state machine transition; post ledger entries for valuation impacts; handle conflicts like concurrent counts
- Error handling: Use problem+json for 4xx/5xx, e.g., 422 for validation, 403 for unauthorized, 409 for state conflicts
- Response format: 200 OK with updated cycle count summary (JSON), or 204 No Content
- Authentication/authorization: Admin role required; RBAC checks via permissions (e.g., inventory.cycle-count.submit); active user, email-verified, optional 2FA
- Middleware application: TLS/HSTS, CORS, RequestId, JSON limits, versioned negotiation, locale/tz, auth, RBAC, branch scope, throttles, idempotency, sanitizer, domain guards, cache headers
- Observability: Log request-id, audit_event for submission, PII masking if applicable
- Testing: PHPUnit tests for controller, validation, state transitions; feature tests for full flow; cover edge cases like low stock impacts or promo interactions
- Data integrity: All operations in UTC; use transactions for atomic updates; polymorphic attachments if notes added"
103,inventory,Recount Cycle,Initiate recount task,api/inventory/cycle-counts/{id}/recount,post,Admin,Implement Recount Cycle API Endpoint for Inventory,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD, implement the 'Recount Cycle' endpoint in the inventory category. This endpoint initiates a recount task for a specific cycle count, supporting inventory management features like batch-centric inventory, reservations, adjustments, cycle counts, valuation, and ledgers. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory supports optional per-unit items and transactional stock movements. The system uses state machines for legality of transitions (e.g., for cycle counts), conflicts return RFC7807 problem+json. Data is stored in UTC, with soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential links. Design ensures deterministic admin assignment, safe reservation/consumption, and consistent ledger posting on events. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and maintenance. Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards (e.g., cycle-count), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting covers revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. Other domains: orders (states: pending→confirmed→fulfilled|cancelled), fulfillment (shipments/dispatches), returns (RMA), payments (intent→capture/void, refunds), accounting (transactions/ledgers), services, integrations (carriers/webhooks/notifications), security (user/role/permission, MFA, API keys), observability (audits/logs/PII masking/health/metrics/queues/caching/etag).

This endpoint enables admins to trigger a recount for cycle counts, ensuring accurate inventory valuation and ledger consistency.

## API Specifications

- **Category:** inventory
- **Title:** Recount Cycle
- **Description:** Initiate recount task
- **Route:** api/inventory/cycle-counts/{id}/recount
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST endpoint to initiate a recount task for the specified cycle count ID
- [ ] Ensure the endpoint requires Admin authentication and RBAC permission checks for inventory/cycle-count actions
- [ ] Validate that the cycle count exists, is owned by the requesting branch/store, and is in a state allowing recount (per state machine rules)
- [ ] Handle successful initiation by queuing or starting the recount task, returning appropriate success response (e.g., 202 Accepted)
- [ ] Implement proper error handling for invalid ID, unauthorized access, invalid state, or conflicts, using RFC7807 problem+json format
- [ ] Add unit/integration tests covering happy path, validation errors, auth failures, and state machine transitions
- [ ] Ensure endpoint integrates with middleware stack: auth (JWT/session/API key), RBAC, branch scope, throttles, idempotency, input sanitizer, domain guards for cycle-count
- [ ] Verify audit logging for the recount initiation event
- [ ] Confirm response includes relevant headers like Request-Id, cache headers, and ETag if applicable
- [ ] Test for soft deletes: do not allow recount on deleted cycle counts
- [ ] Ensure transactional consistency: if recount initiation affects ledgers or reservations, post entries deterministically

## Technical Requirements

- Define the route in Laravel routes/api.php with {id} as the cycle count identifier
- Create or update a Laravel controller (e.g., CycleCountController) with a recount method handling the POST request
- Use Laravel's resource controllers or dedicated methods for inventory domain
- Implement input validation: {id} must be a valid UUID/integer; no request body expected, or minimal params if needed (e.g., via query or form data)
- Integrate with state machine for cycle count transitions (e.g., from 'in-progress' to 'recounting')
- Queue the recount task if asynchronous (using Laravel queues) for performance, especially for large inventories
- Handle business logic: Recount should re-evaluate batch/unit counts, update valuation/ledgers, and potentially trigger adjustments or notifications
- Apply domain guards: Prevent recount if conflicting reservations, ongoing dispatches, or fraud flags
- Use Eloquent models for CycleCount entity, ensuring relationships to inventory batches, stores, and ledgers
- For responses: JSON format with success message/task ID; errors in problem+json (title, detail, status, type)
- No PII in requests/responses; mask if logs involve customer data
- Ensure UTC handling and timezone-agnostic operations
- Add Observability: Log request-id, audit_event for initiation, metrics for endpoint performance

## Authentication/Authorization Requirements

- Requires Admin role with specific permissions (e.g., 'inventory.cycle-count.recount') via RBAC system (user/role/permission with ability mappings)
- Enforce active user, email-verified, and optional 2FA/MFA checks via middleware
- Support JWT, session, or API key auth; branch scope limits to user's assigned stores/branches
- Reject if user lacks permission or cycle count not in scope, returning 403 Forbidden

## Expected Request/Response Format Considerations

- **Request:** POST to /api/inventory/cycle-counts/{id}/recount; no body required (initiate action); validate {id} exists and accessible
- **Response (Success):** 202 Accepted or 200 OK, JSON: {""message"": ""Recount task initiated"", ""task_id"": ""uuid"", ""cycle_count_id"": ""id""}
- **Response (Error):** 4xx/5xx with RFC7807 problem+json, e.g., {""title"": ""Invalid Cycle Count"", ""detail"": ""Cycle count not found or invalid state"", ""status"": 404, ""type"": ""https://example.com/probs/invalid-cycle""}
- Include headers: Content-Type: application/json, X-Request-Id, Cache-Control
- Versioned via content-negotiation (e.g., Accept: application/vnd.deshio.v1+json)
- Idempotency: Support key in header to prevent duplicate initiations

## Relevant Business Logic

- Cycle counts are part of inventory domain: Support accuracy checks, aging, low stock alerts, and reporting (e.g., cycle count accuracy metrics)
- Recount initiates re-verification of counts, potentially updating reservations, adjustments, and ledgers transactionally
- State machine ensures legal transitions; e.g., cannot recount if fulfilled or cancelled
- Integrate with accounting: Post ledger_entry lines for any count discrepancies
- Notifications: Trigger email/SMS via templates if recount reveals issues
- Compliance: Audit all events; support feature flags for recount behavior; enable bulk recount if extended later
- Conflicts: If ongoing order fulfillment or dispatch affects inventory, block or queue recount
- Post-recount: Update promo impacts, price overrides, or fraud flags if variances detected"
104,inventory,Discrepancy Report,List count variances,api/inventory/cycle-counts/{id}/discrepancies,get,Admin,Implement GET /api/inventory/cycle-counts/{id}/discrepancies Endpoint,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the 'Discrepancy Report' API endpoint in the inventory category.

This endpoint lists count variances for a specific cycle count, supporting inventory management features like batch-centric inventory, reservations, adjustments, cycle counts, valuation, and ledgers. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers + tags/blacklist. Inventory supports optional per-unit items and transactional stock movements.

The endpoint enables reporting on discrepancies identified during cycle counts, ensuring accurate inventory tracking and compliance with state machines for legality of transitions, conflicts returning RFC7807 problem+json. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential links.

Design ensures deterministic admin assignment, safe reservation/consumption, and consistent ledger posting on stock events. Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD). Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

## API Specifications

- **Category:** inventory
- **Title:** Discrepancy Report
- **Description:** List count variances
- **Route:** api/inventory/cycle-counts/{id}/discrepancies
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET endpoint to retrieve discrepancies for a given cycle count ID
- [ ] Ensure the endpoint lists count variances accurately, reflecting batch-centric inventory and cycle count logic
- [ ] Add input validation for the {id} parameter (must be a valid cycle count ID)
- [ ] Implement proper error handling for invalid IDs or unauthorized access, returning RFC7807 problem+json for conflicts
- [ ] Write unit tests for successful retrieval, invalid ID, and authorization failures
- [ ] Write integration tests to verify integration with inventory ledgers and state machines
- [ ] Ensure response includes relevant fields like variance details, affected batches/items, and timestamps
- [ ] Confirm endpoint respects branch scope and RBAC permissions
- [ ] Add audit logging for endpoint access
- [ ] Verify soft deletes are handled appropriately in queries
- [ ] Test with UTC timestamps and polymorphic relations if applicable

## Technical Requirements

- Use Laravel framework: Define route in api.php, create or extend InventoryCycleCountController
- Implement query to fetch discrepancies from cycle count entity, joining relevant inventory tables (e.g., batches, items, ledgers)
- Apply Eloquent models with relationships for efficient data retrieval
- Input validation: Use FormRequest or controller validation for {id} (integer, exists in cycle_counts table)
- Proper error handling: 404 for non-existent ID, 403 for unauthorized, 422 for validation errors
- Response format: JSON array of discrepancy objects, e.g., [{id, cycle_count_id, item_id, expected_count, actual_count, variance, batch_id, notes, created_at}]
- Pagination if large result sets expected (use Laravel's paginate)
- Caching/etag support via middleware
- Queues for any background processing if needed (e.g., complex calculations)
- Feature flags for enabling/disabling if applicable

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have relevant permissions (e.g., inventory.view_discrepancies) via role/permission checks
- Middleware: auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope
- Multi-role support; optional tenancy isolation
- Throttling and idempotency keys for repeated requests

## Expected Request/Response Format Considerations

- **Request:** GET /api/inventory/cycle-counts/{id}/discrepancies
  - Path param: {id} - Cycle count identifier (required, validated)
  - Query params: Optional filters like ?branch_id=1&date_from=2023-01-01 (if extending scope)
  - Headers: Authorization (Bearer/JWT), Accept: application/json, X-Request-ID, locale/tz

- **Response:** 200 OK with JSON body
  - Array of discrepancies: Each object includes id, cycle_count_id, product_id/item_id, batch_id, expected_quantity, counted_quantity, variance, status (e.g., resolved/unresolved), notes/attachments (polymorphic), timestamps (UTC)
  - Error responses: 401 Unauthorized, 403 Forbidden, 404 Not Found, 422 Unprocessable Entity (with RFC7807 problem+json)
  - Use versioned content-negotiation; JSON limits enforced

## Relevant Business Logic

- Discrepancies arise from variances between expected (system) and actual (counted) inventory during cycle counts
- Integrate with state machines: Ensure cycle count is in a valid state (e.g., completed) for discrepancy reporting
- Trigger ledger entries or adjustments if discrepancies lead to stock movements
- Support reservations and transactional consistency; prevent conflicts with ongoing orders/fulfillments
- Handle batch-centric logic: Variances per batch/unit, with optional per-unit items
- Fraud/domain guards: Validate against fraud flags or overrides
- Post-event: Consistent accounting transaction headers + ledger_entry lines; potential reversals
- Reporting tie-in: Feed into inventory aging/low stock, cycle count accuracy analytics
- Compliance: PII masking if customer data indirectly involved; audit_event logging for access"
105,inventory,Inventory Ledger,Per product/batch/store ledger,api/inventory/ledger,get,Admin,Implement Inventory Ledger API Endpoint (GET /api/inventory/ledger),"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint provides access to the per product/batch/store ledger in the inventory category, allowing admins to retrieve detailed inventory movement records.

## API Specifications

- **Category:** inventory
- **Title:** Inventory Ledger
- **Description:** Per product/batch/store ledger
- **Route:** api/inventory/ledger
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET /api/inventory/ledger endpoint in Laravel
- [ ] Support query parameters for filtering by product, batch, store, date range, and movement types (e.g., reservations, adjustments, shipments)
- [ ] Return paginated results with ledger entries including transaction details, quantities, values, and timestamps
- [ ] Ensure all responses use UTC timestamps and handle soft deletes appropriately
- [ ] Add input validation for query parameters
- [ ] Implement proper error handling with RFC7807 problem+json for invalid requests or conflicts
- [ ] Write unit and integration tests covering success, error, and edge cases (e.g., no records, large datasets)
- [ ] Verify audit logging for endpoint access
- [ ] Ensure compatibility with middleware stack (auth, RBAC, throttling, etc.)
- [ ] Document the endpoint in API specs (e.g., OpenAPI)

## Technical Requirements

- Use Laravel controller (e.g., InventoryLedgerController) and define route in api.php with proper versioning
- Leverage Eloquent models for inventory ledger entities (e.g., ledger_entry linked to products, batches, stores)
- Implement query builder or scopes for efficient filtering and pagination (e.g., using LengthAwarePaginator)
- Integrate with state machines if ledger entries involve transitions (e.g., cycle counts)
- Use caching/etag for repeated queries where applicable
- Handle bulk data efficiently to prevent performance issues
- Ensure transactional consistency for any related stock movements

## Authentication/Authorization Requirements

- Require Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have admin role or specific permission (e.g., 'view-inventory-ledger')
- Apply branch scope if multi-tenant (optional tenancy middleware)
- Include active user check, email verification, and 2FA if enabled
- Log audit_event for access attempts

## Expected Request/Response Format Considerations

- **Request:** GET with query params, e.g., ?product_id=123&batch_id=456&store_id=789&from_date=2023-01-01&to_date=2023-12-31&type=adjustment&per_page=50&page=1
  - Validate params: integers for IDs, valid dates, enum for types
  - Sanitize inputs per middleware
- **Response:** JSON array of ledger entries (paginated)
  - Example: {
    ""data"": [
      {
        ""id"": 1,
        ""product_id"": 123,
        ""batch_id"": 456,
        ""store_id"": 789,
        ""movement_type"": ""adjustment"",
        ""quantity"": 10,
        ""value"": 100.00,
        ""timestamp"": ""2023-01-01T00:00:00Z"",
        ""transaction_id"": 789,
        ""notes"": ""Cycle count adjustment""
      }
    ],
    ""meta"": { ""current_page"": 1, ""per_page"": 50, ""total"": 100 }
  }
  - Use content-negotiation for JSON; include cache headers
  - Errors: 400 for invalid params, 403 for unauthorized, 404 if no data

## Relevant Business Logic

- Ledger tracks all inventory movements: reservations, adjustments, cycle counts, shipments, returns, inter-store dispatches
- Entries tied to transaction headers with ledger_entry lines for stock/financial impacts
- Support valuation methods and reversals
- Ensure deterministic posting on every event; handle conflicts via state machines
- Filter by batch-centric inventory (optional per-unit); include pricing overrides if relevant
- Integrate with reporting for inventory aging, low stock, and accuracy metrics
- Maintain referential integrity across junctions (e.g., product/category/vendor)"
106,dispatch,List Dispatches,Paginated dispatches,api/dispatches,get,Employee,Implement List Dispatches API Endpoint (GET /api/dispatches),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue covers the implementation of the 'List Dispatches' API endpoint. This endpoint provides paginated access to dispatches, which are part of the fulfillment domain handling inter-store dispatches including dispatch tracking, scan events, and Proof of Delivery (POD) with transactional stock movements. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. Order domain involves states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment includes shipments and dispatches with stock movements. Returns handle RMA, refunds, exchanges. Payments, accounting (transactions, ledgers, reversals), services, integrations (carriers, webhooks, notifications), security (RBAC, MFA, API keys), observability (audits, logs, PII masking), middleware (TLS, auth, RBAC, throttles, etc.), reporting/analytics (revenue, LTV, inventory aging, etc.), state machines for transitions, bulk operations, EAV for attributes, polymorphic relations, and UTC/soft deletes. Design ensures deterministic admin assignment, safe reservations, and consistent ledger posting.

This endpoint lists dispatches in a paginated manner, enabling retrieval of inter-store dispatch data for logistics and inventory management.

## API Specifications

- **Category:** dispatch
- **Title:** List Dispatches
- **Description:** Paginated dispatches
- **Route:** api/dispatches
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET /api/dispatches endpoint to return paginated list of dispatches
- [ ] Support pagination parameters (e.g., page, per_page) with default sensible limits
- [ ] Ensure response includes relevant dispatch fields like ID, status, tracking, scan events, POD, associated stock movements, and links to related entities (e.g., orders, shipments, stores)
- [ ] Handle filtering/sorting if applicable (e.g., by store, date, status) based on business needs
- [ ] Add input validation for query parameters
- [ ] Implement proper error handling with RFC7807 problem+json for conflicts or invalid states
- [ ] Write unit/integration tests covering happy path, edge cases, pagination, and authorization
- [ ] Ensure compliance with middleware: auth (JWT/session/API key), RBAC & permission checks, branch scope, throttles, idempotency, input sanitizer
- [ ] Verify state machine legality for dispatch transitions
- [ ] Test transactional stock movements and ledger posting integration
- [ ] Document the endpoint in API specs (e.g., OpenAPI)

## Technical Requirements

- Use Laravel controller (e.g., DispatchController@list) and define route in api.php with proper middleware stack (RequestId, auth, active user, RBAC, branch scope, etc.)
- Implement pagination using Laravel's LengthAwarePaginator or similar, with Eloquent queries on the dispatch model
- Query should join/filter relevant relations (e.g., dispatch_items, tracking, scan_events, POD, stock_movements, ledgers)
- Apply soft deletes archival and UTC handling
- Use caching/etag if applicable for performance
- Input validation via FormRequest or Validator for query params (e.g., page, filters)
- Error handling: 400 for invalid input, 403 for unauthorized, 404 if needed, with problem+json
- Response format: JSON with paginated structure (data array, meta for pagination)
- Ensure referential integrity across junctions (e.g., polymorphic notes/attachments)
- Integrate with observability: audit_event logging, request-id tracing, health/metrics

## Authentication/Authorization Requirements

- Requires Employee authentication (JWT, session, or API key)
- RBAC: Employee must have permission to view dispatches (role↔perm via ability and user_role multi-role)
- Active user check, email-verified if applicable, optional 2FA
- Branch scope: Limit results to employee's assigned branches/stores
- Domain guards for dispatch/reservation/stock events

## Expected Request/Response Format Considerations

- **Request:** GET /api/dispatches?page=1&per_page=20&filter[status]=pending&sort=created_at.desc
  - Query params: page (int), per_page (int, max e.g., 100), optional filters (status, store_id, date_range), sort
  - No body required
- **Response (200 OK):** 
  {
    ""data"": [
      {
        ""id"": 1,
        ""status"": ""in_transit"",
        ""tracking_number"": ""TRACK123"",
        ""scan_events"": [...],
        ""pod"": {...},
        ""stock_movements"": [...],
        ""related_order_id"": 456,
        ""from_store_id"": 1,
        ""to_store_id"": 2,
        ""created_at"": ""2023-01-01T00:00:00Z"",
        // other fields
      }
    ],
    ""meta"": {
      ""current_page"": 1,
      ""last_page"": 5,
      ""per_page"": 20,
      ""total"": 100
    }
  }
- **Errors:** 400/403/422 with RFC7807 format, e.g., {""type"": ""https://example.com/probs/invalid-query"", ""title"": ""Invalid Query"", ""detail"": ""..."", ""status"": 400}
- Versioned content-negotiation, JSON limits, locale/tz handling

## Relevant Business Logic

- Dispatches represent inter-store movements with transactional stock updates (reservations, consumption, ledgers)
- State machine governs transitions (e.g., pending→in_transit→delivered|cancelled), rejecting illegal states
- Integrate with fulfillment: link to orders/shipments, handle scan events, POD for completion
- Ensure consistent ledger posting on stock/financial events, reversals if cancelled
- Support attachments/notes polymorphic to dispatch
- Fraud flag or blacklist checks if applicable to related customers/orders
- Align with inventory batch-centric model, cycle counts, valuation
- Bulk export/search possible via extensions, but focus on paginated list
- Webhooks for delivery notifications if status changes
- Reporting tie-in: dispatch performance, SLA metrics"
107,dispatch,Create Dispatche,Create dispatche,api/dispatches,post,Admin,Implement POST /api/dispatches - Create Dispatch Endpoint,"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint is for creating a dispatch in the dispatch category, which handles inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.

## API Specifications

- **Category:** dispatch
- **Title:** Create Dispatch
- **Description:** Create dispatch
- **Route:** api/dispatches
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST /api/dispatches endpoint to create a new dispatch record
- [ ] Validate input data according to business rules (e.g., required fields, referential integrity)
- [ ] Handle successful creation with appropriate response (e.g., 201 Created with dispatch ID)
- [ ] Return proper error responses for validation failures, unauthorized access, or conflicts (RFC7807 problem+json)
- [ ] Integrate with state machines for dispatch transitions
- [ ] Ensure transactional stock movements and ledger posting on creation
- [ ] Add unit and integration tests covering happy path, edge cases, and errors
- [ ] Document the endpoint in API docs (e.g., OpenAPI/Swagger)
- [ ] Verify middleware application (auth, RBAC, branch scope, idempotency)

## Technical Requirements

- Use Laravel controller and routes for implementation
- Define request validation using Form Requests or Validator facade
- Handle soft deletes and UTC storage
- Integrate with polymorphic notes/attachments if applicable
- Ensure strict referential links across junctions (e.g., to orders, shipments, inventory batches)
- Apply domain guards for dispatch/reservation/stock movements
- Use EAV for any dispatch attributes if needed
- Implement proper error handling with logging (request-id, audit_event)
- Support idempotency for duplicate requests
- Add caching/etag considerations if relevant
- Ensure compatibility with queues for any async processing (e.g., notifications)

## Authentication/Authorization Requirements

- Requires Admin authentication (JWT/session/API key)
- Enforce active user, email-verified, and 2FA checks via middleware
- Apply RBAC & permission checks (e.g., user must have permission to create dispatches)
- Branch scope: Ensure dispatch creation is scoped to authorized branches/stores
- Optional tenancy isolation if enabled

## Expected Request/Response Format Considerations

- Request: JSON body with fields for dispatch details (e.g., from_store_id, to_store_id, items array with quantities, notes)
- Validate required fields, relationships (e.g., valid order/shipment references), and business constraints (e.g., available inventory)
- Response: On success, return 201 with JSON { id: dispatch_id, status: 'pending', ... } and Location header
- Errors: 400 for validation, 401/403 for auth, 409 for conflicts (e.g., invalid state transition), in RFC7807 problem+json format
- Use versioned content-negotiation and locale/tz handling

## Relevant Business Logic

- Dispatch creation triggers inter-store stock movements: reserve/consume inventory batches, post to ledgers
- Use state machines to validate initial state (e.g., from confirmed orders or inventory adjustments)
- Handle tracking setup, scan events initialization, and POD preparation
- Integrate with shipments if applicable (shipment/shipment_item linkage)
- Ensure determinism for admin assignment and safe reservation/consumption
- Trigger notifications (email/SMS via templates) and webhooks on creation
- Support attachments and fraud flags if relevant to dispatch
- Account for promotions, taxes, and pricing overrides in movement calculations
- Maintain consistency with order fulfillment lifecycle (e.g., update order states)
- Comply with observability: log events, mask PII, track metrics for dispatch performance"
108,dispatch,Get Dispatche,Get by id,api/dispatches/{id},get,Employee,Implement GET /api/dispatches/{id} Endpoint for Dispatch Retrieval,"## Overview

This GitHub issue is for implementing the 'Get Dispatch' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain handles states (pending→confirmed→fulfilled|cancelled), assignment, notes/attachments, promos, taxes, fraud flags. Fulfillment involves shipments, inter-store dispatch (with tracking, scan events, POD), and transactional stock movements. Returns cover RMA, restock/scrap, refunds, exchanges. Payments include intent capture/void, refunds, and synchronization. Accounting uses transaction headers + ledger entries for movements, reversals, reconciliation. Services include service orders with lifecycle and profitability. Integrations handle carriers, waybills/rates/tracking, webhooks, notifications. Security features user/role/permission with multi-role support, sessions, email verification, password reset, TOTP MFA, API keys. Observability includes audit events, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware encompasses TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines ensure legal transitions for orders, dispatches, etc., with RFC7807 problem+json for conflicts. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, strict referential links. Design enables deterministic admin assignment, safe reservation/consumption, consistent ledger posting.

This endpoint retrieves a specific dispatch by ID, part of the dispatch category for inter-store fulfillment and tracking.

## API Specifications

- **Category:** dispatch
- **Title:** Get Dispatch
- **Description:** Get by id
- **Route:** api/dispatches/{id}
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint returns a single dispatch resource by ID when authenticated as an employee with appropriate permissions
- [ ] Endpoint handles non-existent ID with 404 error in RFC7807 format
- [ ] Endpoint enforces RBAC and branch scope for dispatch visibility
- [ ] Response includes related entities like shipment_items, tracking events, stock movements, and audit logs
- [ ] Unit and integration tests cover success, error cases, and authorization failures
- [ ] Endpoint integrates with state machine to ensure dispatch state legality
- [ ] Performance: Response time under 200ms for typical loads, with caching/etag support
- [ ] Documentation updated in API specs with examples

## Technical Requirements

- Implement in Laravel: Define route in api.php, create or extend DispatchController with show method
- Use Eloquent model for Dispatch with relationships to shipment, shipment_item, dispatch tracking, scan events, POD, stock movements
- Apply middleware stack: auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, throttles, idempotency, input sanitizer, RequestId, versioned content-negotiation, locale/tz, cache headers
- Input validation: Ensure {id} is a valid UUID or integer via route model binding and validator
- Error handling: Use try-catch for database errors, return problem+json for validation/state conflicts; soft deletes considered for archival
- Response formatting: JSON API compliant, include UTC timestamps, optional EAV attributes, polymorphic attachments/notes
- Integrate with ledger for any financial implications of dispatch state
- Observability: Log request-id, audit_event on access, PII masking if applicable
- Testing: PHPUnit tests for controller, feature tests for full flow, mock auth/RBAC

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- RBAC: Employee must have permission to view dispatches (e.g., role↔perm via ability table)
- Branch scope: Limit to dispatches within user's assigned branches/stores
- Additional checks: Active user, email-verified, 2FA if enabled; deny if fraud flag or domain guards trigger

## Expected Request/Response Format Considerations

- **Request:** GET /api/dispatches/{id} with Accept: application/json, optional ?include=relations (e.g., shipments,tracking)
- **Response (200 OK):** JSON object with dispatch details: id, state, origin/destination stores, assigned user, timestamps, related shipments/shipment_items, tracking events, stock movements ledger, attachments/notes; use resource classes for transformation
- **Error Responses:** 401 Unauthorized, 403 Forbidden (RBAC/scope), 404 Not Found, 422 Unprocessable (validation), all in RFC7807 problem+json with title, detail, type
- Content negotiation: Versioned (e.g., v1), locale/tz aware; cache headers for etag

## Relevant Business Logic

- Dispatch represents inter-store fulfillment: Tracks movement from origin to destination store with scan events, POD
- State machine governs transitions (e.g., pending→in-transit→delivered|failed), ensuring legality before retrieval
- On retrieval, include transactional stock reservations/consumptions, ledger postings for inventory valuation
- Conflicts (e.g., invalid state access) return problem+json; support for determinism in admin assignment and safe consumption
- Integrates with shipments, orders, inventory batches; optional per-unit items; fraud flags may restrict access"
109,dispatch,Update Dispatche,Update by id,api/dispatches/{id},put,Admin,Implement PUT /api/dispatches/{id} for Updating Dispatch,"## Overview

This GitHub issue is for implementing the 'Update Dispatch' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint allows updating a dispatch by its ID, which is part of the fulfillment domain involving inter-store dispatch with tracking, scan events, and proof of delivery (POD), ensuring transactional stock movements.

## API Specifications

- **Category:** dispatch
- **Title:** Update Dispatch
- **Description:** Update by id
- **Route:** api/dispatches/{id}
- **HTTP Method:** PUT
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the PUT /api/dispatches/{id} endpoint in the Laravel controller
- [ ] Ensure the endpoint updates dispatch details, including tracking, scan events, and POD, while maintaining transactional stock movements
- [ ] Add input validation for update fields, ensuring referential integrity with related entities like orders, shipments, and inventory
- [ ] Implement state machine checks for legal transitions in dispatch states
- [ ] Handle soft deletes and archival properly if applicable
- [ ] Write unit and integration tests covering successful updates, validation errors, unauthorized access, and state conflicts
- [ ] Ensure responses follow RFC7807 for errors (problem+json)
- [ ] Verify middleware integration: auth (Admin), RBAC & permission checks, branch scope, domain guards for dispatch
- [ ] Test idempotency and throttling
- [ ] Confirm audit logging for update events
- [ ] Ensure data remains in UTC and PII masking if applicable

## Technical Requirements

- Use Laravel framework: Create or update a DispatchController with the update method
- Define routes in api.php: Route::put('/dispatches/{id}', [DispatchController::class, 'update']);
- Implement input validation using Form Requests or Validator, covering fields like status, tracking info, scan events, POD, notes/attachments
- Integrate with Eloquent models for Dispatch, related to shipments, orders, inventory batches; use strict referential links
- Apply polymorphic relations for notes/attachments if updates include them
- Handle business logic: Validate state transitions via state machines; trigger ledger postings for stock movements; synchronize with inventory reservations/adjustments
- Use transactions for atomicity in updates affecting stock or financials
- Include middleware stack: TLS/HSTS, CORS, RequestId, auth (JWT/API key for Admin), RBAC (permissions for dispatch updates), branch scope, idempotency, input sanitizer, domain guards
- Support feature flags if dispatch updates are configurable
- Ensure caching/etag and queueing for any async operations like notifications

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have roles/permissions allowing dispatch updates (e.g., ability tied to role↔perm)
- Check active user, email-verified, and 2FA (TOTP MFA + backup codes) as per middleware
- Apply branch scope to ensure updates are within authorized stores/branches
- Optional tenancy if multi-tenant setup
- Reject unauthorized requests with 401/403, using problem+json format

## Expected Request/Response Format Considerations

- **Request:** JSON body with updatable fields (e.g., {""status"": ""in_transit"", ""tracking_number"": ""ABC123"", ""scan_events"": [...], ""pod"": {...}, ""notes"": ""Updated note""}); {id} as URL param (UUID or integer)
- Validate against dispatch schema, supporting EAV attributes if applicable; sanitize inputs
- **Response:** 200 OK with updated dispatch JSON (including related entities like shipment_items, stock movements); or 204 No Content if no body needed
- Error responses: 400 for validation/state errors, 404 if dispatch not found (respect soft deletes), 422 for unprocessable entity, all in RFC7807 problem+json
- Use versioned content-negotiation; set cache headers; include request-id
- Support bulk aspects if updates affect multiple items, but primary is single ID update

## Relevant Business Logic

- Dispatch updates must respect state machines for legal transitions (e.g., from assigned to in_transit to delivered), preventing invalid states and returning conflicts
- Ensure transactional stock movements: Updates triggering reservations, adjustments, or ledgers must post consistently to accounting (transaction headers + ledger_entry lines)
- Integrate with fulfillment: Link to shipments/shipment_items; handle inter-store aspects with tracking and scan events
- Fraud/domain guards: Check for fraud flags on related orders; prevent overrides outside permissions
- Notifications: Trigger webhooks/deliveries, email/SMS via templates on status changes
- Compliance: Log audit_events; mask PII; support reversals if update leads to cancellations
- Analytics impact: Updates may affect reporting like dispatch performance, SLA, inventory aging"
110,dispatch,Delete Dispatche,Delete by id,api/dispatches/{id},delete,Admin,Implement DELETE /api/dispatches/{id} for Admin in Deshio ERP,"## Context about Deshio ERP

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.
Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

## Overview

This GitHub issue is for implementing the Delete Dispatch API endpoint in the Deshio ERP system. The endpoint allows authorized admins to delete a specific dispatch by its ID. Dispatches are part of the fulfillment domain, handling inter-store movements with tracking, scan events, and proof of delivery (POD), involving transactional stock movements. Deletion should respect state machine legality to ensure only valid transitions occur, preventing deletion of dispatches in non-deletable states (e.g., already shipped or completed). On deletion, reverse any associated ledger entries, stock movements, and audit events. Use soft deletes for archival compliance.

## API Specifications

- **Category:** dispatch
- **Title:** Delete Dispatch
- **Description:** Delete by id
- **Route:** api/dispatches/{id}
- **HTTP Method:** DELETE
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint deletes the dispatch record by provided ID if it exists and is in a deletable state
- [ ] Returns 204 No Content on successful deletion
- [ ] Returns 404 Not Found if dispatch ID does not exist
- [ ] Returns 403 Forbidden if user lacks admin permissions or RBAC checks fail
- [ ] Returns RFC7807 problem+json for state machine conflicts (e.g., cannot delete fulfilled dispatch)
- [ ] Implements soft delete instead of hard delete for compliance
- [ ] Reverses associated transactional stock movements and ledger entries on deletion
- [ ] Logs audit_event for the deletion action
- [ ] Handles branch scope and idempotency via middleware
- [ ] Includes unit and integration tests covering success, error cases, and business logic
- [ ] Endpoint is protected by all relevant middleware (auth, RBAC, throttles, etc.)
- [ ] Documentation updated for API reference

## Technical Requirements

- Use Laravel framework: Define route in api.php with prefix 'api', middleware groups for auth and admin checks
- Implement in a dedicated DispatchController with a destroy method
- Use Eloquent model for Dispatch with softDeletes trait enabled
- Apply state machine validation before deletion to check legality of transition to deleted state
- Integrate with inventory ledgers: On deletion, post reversal entries for any stock movements
- Ensure polymorphic relations (e.g., notes/attachments) are handled appropriately (e.g., cascade soft delete)
- Use RequestId middleware for observability and trace deletion events
- Cache invalidation if dispatch data is cached (e.g., via etag or queues)
- Follow data standards: UTC timestamps, strict referential integrity

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have 'admin' role or specific 'delete-dispatch' permission via ability checks
- Apply branch scope middleware to ensure user can only delete dispatches within their scoped branches/stores
- Include active user, email-verified, and optional 2FA checks
- Use domain guards for dispatch-specific validations

## Expected Request/Response Format Considerations

- **Request:** DELETE /api/dispatches/{id} (path parameter 'id' as UUID or integer; no request body)
- **Validation:** Ensure {id} is valid format; check existence and permissions before processing
- **Response:** 
  - Success: 204 No Content (empty body)
  - Errors: 4xx/5xx with JSON body following RFC7807 (problem+json), e.g., {""type"": ""https://example.com/probs/state-invalid"", ""title"": ""Cannot delete dispatch"", ""status"": 422, ""detail"": ""Dispatch is already fulfilled""}
- Content negotiation: Versioned API response with JSON; include cache headers and ETag if applicable
- No PII in responses; mask if necessary for compliance

## Relevant Business Logic

- Deletion must be idempotent: Multiple calls return same result without side effects
- Respect dispatch lifecycle: Only allow deletion in states like 'pending' or 'cancelled'; use state machine for transitions
- Transactional: Wrap deletion in DB transaction including stock reversals, ledger postings, and audit logs
- On delete, update related entities (e.g., release reservations, notify via webhooks if integrated)
- Prevent deletion if dispatch affects ongoing shipments, orders, or returns; return problem+json for conflicts
- Ensure consistency with fulfillment domain: Coordinate with shipments and inter-store movements
- Post audit_event with request-id for traceability; integrate with reporting for dispatch performance metrics"
111,dispatch,Pick Items,Mark items picked,api/dispatches/{id}/pick,post,Employee,Implement Pick Items API for Dispatch in Deshio ERP,"## Overview

This GitHub issue is for implementing the 'Pick Items' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs built over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes (fields/features), media (product images), barcodes, pricing (price overrides), and promotions; stores/branches; customers with tags/blacklists.

Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain handles order/order_item states (pending → confirmed → fulfilled|cancelled), assignment to stores, notes/attachments, promotions, taxes, and fraud flags. Fulfillment involves shipments (shipment/shipment_item) and inter-store dispatches (dispatch + tracking, scan events, POD) with transactional stock movements. Returns manage RMAs (return/return_item), receiving/restocking/scrap, refunds, and exchanges (exchange_order). Payments include intent → payment capture/void; refund lifecycles; and order.payment_status synchronization.

Accounting features transaction headers + ledger_entry lines for all movements, reversals, and reconciliation/export. Services handle service/service_order with lifecycles and profitability. Integrations include carriers & accounts, waybills/rates/tracking; webhooks with deliveries; and notification templates (email/SMS).

Security & identity: user/role/permission with ability (role ↔ perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The 'Pick Items' endpoint specifically marks items as picked in the dispatch process, which is part of fulfillment and inter-store logistics. This action should trigger state transitions via state machines, update inventory reservations, log audit events, and ensure transactional stock movements.

## API Specifications

- **Category:** dispatch
- **Title:** Pick Items
- **Description:** Mark items picked
- **Route:** api/dispatches/{id}/pick
- **HTTP Method:** POST
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint responds to POST requests at api/dispatches/{id}/pick
- [ ] Requires Employee authentication and appropriate RBAC permissions (e.g., dispatch-related roles/permissions)
- [ ] Validates dispatch ID exists and is in a pickable state (e.g., assigned but not yet picked, per state machine)
- [ ] Marks specified items as picked, updating dispatch/shipment_item states
- [ ] Triggers state machine transitions for dispatch and related entities (e.g., from 'assigned' to 'picked')
- [ ] Performs transactional stock movements/reservations if applicable (e.g., consume reservations)
- [ ] Logs audit events for the pick action
- [ ] Handles errors with RFC7807 problem+json format for invalid states/transitions
- [ ] Includes unit/integration tests covering success, validation failures, unauthorized access, and state conflicts
- [ ] Integrates with middleware stack (auth, RBAC, branch scope, idempotency, etc.)
- [ ] Supports request/response in JSON format with proper caching/etag headers
- [ ] Ensures data integrity with soft deletes, UTC storage, and referential links

## Technical Requirements

- Implement in Laravel: Define route in API routes file, create/update DispatchController with pickItems method
- Use Laravel's resource controllers and request validation (e.g., FormRequest for input sanitization)
- Integrate state machines for dispatch transitions (e.g., using a library like spatie/laravel-model-states or custom implementation)
- Handle inventory updates transactionally (e.g., via DB transactions for stock movements, reservations consumption)
- Add audit logging via audit_event model for the pick action, including user, timestamp, and changes
- Implement error handling: Return 4xx/5xx with problem+json for validation errors, unauthorized, forbidden (RBAC), or state conflicts
- Consider idempotency: Use request-id or similar to prevent duplicate picks
- Ensure compatibility with observability: Add metrics for endpoint health, log requests with request-id, mask PII if applicable
- Write comprehensive tests: PHPUnit for unit (validation, state transitions), feature tests for full flow, including mocks for auth/RBAC
- Follow Deshio conventions: Versioned API, content-negotiation, locale/tz handling, queueable if async processing needed (e.g., notifications)

## Authentication/Authorization Requirements

- Authentication: Employee via JWT/session/API key
- Authorization: RBAC checks for user roles/permissions related to dispatch (e.g., 'dispatch.pick' permission)
- Additional guards: Active user, email-verified, 2FA if enabled, branch scope (ensure employee can access the dispatch's branch)
- Middleware: Apply auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope

## Expected Request/Response Format Considerations

- **Request:** JSON body with items to pick, e.g., {""items"": [{""id"": 1, ""quantity_picked"": 5}, ...]}; Validate quantities against dispatch/shipment_item availability
- **Response:** On success, 200 OK with updated dispatch JSON (including picked items status); Include etag for caching
- **Errors:** 400 Bad Request for invalid input; 401 Unauthorized; 403 Forbidden (RBAC/branch); 404 Not Found (dispatch ID); 409 Conflict (state machine invalid transition); All in RFC7807 problem+json
- Use strict typing, sanitize inputs, enforce JSON limits via middleware

## Relevant Business Logic

- Dispatch lifecycle: Picking is a scan/pick event in inter-store dispatch, leading to tracking updates and eventual POD
- Inventory impact: Consume reservations for picked items; If batch-centric, update batch quantities; Trigger ledger entries for stock movements
- State validation: Use state machines to ensure dispatch is in a valid state for picking (e.g., not cancelled/fulfilled)
- Transactions: All changes (state update, inventory adjustment, audit log) in a single DB transaction; Rollback on failure
- Notifications: Optionally queue email/SMS via templates if pick completes a stage
- Compliance: Mask PII in logs; Ensure reversibility if needed (e.g., unpick via another endpoint)
- Integrations: Update shipment tracking if picking advances fulfillment; Webhook if external systems need notification
- Edge cases: Partial picks (if not all items picked), over-picking prevention, concurrent picks (use locks/idempotency)"
112,dispatch,Pack Items,Mark items packed,api/dispatches/{id}/pack,post,Employee,Implement Pack Items API Endpoint for Dispatches,"## Overview

This GitHub issue is for implementing the 'Pack Items' API endpoint in the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations. Deshio features ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The dispatch domain handles inter-store movements with tracking, scan events, and proof of delivery (POD), including transactional stock movements. This endpoint specifically marks items as packed in a dispatch, advancing the fulfillment process while ensuring state machine legality for transitions, conflicts returning RFC7807 problem+json. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential links.

## API Specifications

- **Category:** dispatch
- **Title:** Pack Items
- **Description:** Mark items packed
- **Route:** api/dispatches/{id}/pack
- **HTTP Method:** POST
- **Authentication:** Employee

Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, cache headers.

## Acceptance Criteria

- [ ] Endpoint handles POST requests to api/dispatches/{id}/pack successfully for valid dispatch IDs
- [ ] Validates that the dispatch exists and is in a state allowing packing (e.g., confirmed, not yet shipped)
- [ ] Updates dispatch/shipment_item states to 'packed' via state machine, ensuring legal transitions
- [ ] Performs transactional stock movements and ledger postings for packed items
- [ ] Returns appropriate success response (e.g., 200 OK with updated dispatch details)
- [ ] Handles errors for invalid states, permissions, or non-existent dispatches with RFC7807 problem+json
- [ ] Integrates with audit_event logging for the packing action
- [ ] Supports idempotency to prevent duplicate packing
- [ ] Includes unit/integration tests covering happy path, edge cases, and errors
- [ ] Documentation updated in API specs with examples
- [ ] Endpoint tested for PII masking, request-id tracing, and queue/caching compatibility

## Technical Requirements

- Implement in Laravel: Define route in api.php, create/update DispatchController with packItems method
- Use Eloquent models for Dispatch, ShipmentItem, etc., with relationships to inventory batches and ledgers
- Input validation: Ensure {id} is a valid UUID/integer; optional request body for partial packing if applicable (e.g., item quantities)
- Error handling: Use Laravel exceptions, return JSON errors with problem+json for conflicts (e.g., invalid state transition)
- Business logic: Advance state machine for dispatch items; trigger stock reservations/consumption if needed; post to accounting ledger for movements; log audit_event with user/branch context
- Observability: Integrate request-id, metrics for SLA/dispatch performance; support webhooks for delivery notifications if packing completes fulfillment
- Security: Enforce RBAC (employee role with dispatch.pack permission), branch scope to prevent cross-branch actions
- Integrations: Update related entities like shipments, inventory ledgers; ensure consistency with returns/exchanges if applicable
- Reporting: Actions should feed into analytics for dispatch performance and inventory aging

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- User must be active, email-verified, and 2FA-enabled if configured
- RBAC check: Employee role with specific permission (e.g., 'dispatch.pack') via ability (role↔perm) mapping
- Branch scope: Employee must have access to the dispatch's originating/destination branch
- Optional tenancy isolation if multi-tenant mode is active

## Expected Request/Response Format Considerations

- **Request:** POST api/dispatches/{id}/pack
  - Path param: {id} - Dispatch ID (UUID/integer)
  - Body: JSON optional, e.g., {""items"": [{""id"": ""item_uuid"", ""quantity_packed"": 5}]} for partial packing; empty for full pack
  - Headers: Authorization (Bearer/JWT), X-Request-Id, Accept: application/vnd.deshio.v1+json, Content-Type: application/json

- **Response:** 
  - Success (200 OK): {""data"": {""dispatch"": {updated dispatch object with packed items, state, tracking events}}, ""meta"": {""request_id"": ""uuid""}}
  - Error (e.g., 400/403/422): RFC7807 problem+json, e.g., {""title"": ""Invalid State"", ""detail"": ""Dispatch cannot be packed"", ""type"": ""https://problems.deshio.com/invalid-transition"", ""status"": 400}

- Consider bulk operations if extending to multiple items; use ETag for caching dispatch state; sanitize inputs to prevent injection

## Relevant Business Logic

- Packing advances dispatch lifecycle (e.g., pending → packed → shipped), triggering scan events and POD preparation
- Ensures safe reservation/consumption of inventory batches; handles per-unit items if not batch-centric
- Integrates with fulfillment: Links to shipments/shipment_items; supports inter-store dispatch with transactional movements
- If packing completes dispatch, auto-post to accounting (transaction headers + ledger_entry lines), potentially triggering notifications (email/SMS via templates) or carrier integrations (waybills/tracking)
- Conflicts (e.g., insufficient stock, fraud flag) block transition with domain guards
- Supports reversals if unpacked later (e.g., via RMA or adjustment); maintains audit trail for compliance
- Aligns with order domain: If dispatch fulfills an order, sync payment_status and update order states (fulfilled/cancelled)
- Deterministic assignment to stores/branches; feature flags for optional behaviors like auto-confirmation post-packing"
113,dispatch,Ship Dispatch,Mark as shipped / handover,api/dispatches/{id}/ship,post,Employee,Implement Ship Dispatch API: Mark as Shipped (POST /api/dispatches/{id}/ship),"## Overview

This GitHub issue is for implementing the 'Ship Dispatch' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits.

Core entities include: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.

Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.

Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.

Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).

Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.

Services: service/service_order with lifecycle and profitability.

Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.

Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint specifically handles marking a dispatch as shipped or handed over, part of the fulfillment domain with transactional stock movements, tracking, scan events, and proof of delivery (POD).

## API Specifications

- **Category:** dispatch
- **Title:** Ship Dispatch
- **Description:** Mark as shipped / handover
- **Route:** api/dispatches/{id}/ship
- **Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST /api/dispatches/{id}/ship endpoint in the relevant Laravel controller (e.g., DispatchController)
- [ ] Validate that the dispatch ID exists and is in a shippable state per the state machine
- [ ] Perform the state transition to 'shipped' or 'handed over', ensuring legality via state machine
- [ ] Handle transactional stock movements (e.g., consume reservations from source branch, update inventory ledgers)
- [ ] Record scan events, update tracking, and generate POD if applicable for inter-store dispatch
- [ ] Synchronize related entities (e.g., update shipments, orders, or fulfillment status)
- [ ] Post accounting ledger entries for stock/financial movements, including reversals if needed
- [ ] Trigger notifications (email/SMS) or webhooks for delivery events if configured
- [ ] Add input validation for any optional request body (e.g., handover notes)
- [ ] Implement proper error handling with RFC7807 problem+json for invalid states, permissions, or conflicts
- [ ] Write unit tests for controller logic, state transitions, and business rules
- [ ] Write integration tests for end-to-end flow including stock movements and ledger posting
- [ ] Update OpenAPI/Swagger documentation for the endpoint
- [ ] Ensure endpoint respects middleware stack (auth, RBAC, branch scope)
- [ ] Test for soft deletes, UTC handling, and audit logging

## Technical Requirements

- Use Laravel framework: Define route in routes/api.php with proper versioning and content-negotiation
- Controller: Handle POST request, inject Dispatch model by ID, apply domain guards for dispatch/reservation/stock
- Input validation: Use FormRequest or validator for optional JSON body (e.g., {'notes': 'string'}); enforce JSON limits and sanitizer
- State machine: Integrate with dispatch state machine to validate and execute transition; reject illegal transitions
- Transactions: Wrap stock movements, ledger postings, and entity updates in DB transactions for atomicity
- Error handling: Return 404 for non-existent dispatch, 403 for unauthorized, 422 for validation/state errors, using problem+json
- Observability: Log audit_event, request-id tracing; cache headers and ETag for responses
- Performance: Respect throttles, idempotency keys; branch scope filtering

## Authentication/Authorization Requirements

- Authentication: Requires Employee role via JWT, session, or API key; enforce active user, email-verified, and 2FA if enabled
- Authorization: RBAC checks for permissions (e.g., 'dispatch.ship') via role→permission mapping; multi-role support
- Scope: Branch/store scope middleware to ensure employee can only ship dispatches assigned to their branch
- Security: TLS/HSTS, CORS, input sanitizer; optional tenancy isolation

## Expected Request/Response Format Considerations

- **Request:** POST to /api/dispatches/{id}/ship
  - Headers: Authorization (Bearer/JWT), Content-Type: application/json, X-Request-ID
  - Body: Optional JSON, e.g., {""notes"": ""Handover to carrier at 10:00 UTC"", ""tracking_number"": ""string""} (validate mime and size)
  - No required params beyond path {id} (UUID or integer)

- **Response:** 
  - Success: 200 OK with JSON of updated dispatch resource (include id, state, tracking, updated_at; mask PII)
    Example: {""data"": {""id"": 123, ""state"": ""shipped"", ""tracking_events"": [...], ""stock_movements"": {...}}}
  - Or 204 No Content if no body returned
  - Errors: RFC7807 problem+json, e.g., 422 {""type"": ""https://problems.example/invalid-state"", ""title"": ""Dispatch not shippable"", ""detail"": ""Current state: assigned""}

- Formats: Versioned JSON (e.g., v1), locale/tz aware; ETag for caching

## Relevant Business Logic

- Dispatch context: Part of inter-store fulfillment; ensures safe reservation/consumption of inventory batches
- State transition: Only from eligible states (e.g., 'assigned' or 'ready'); use state machine to enforce legality and trigger side effects (e.g., release reservations, post ledgers)
- Stock movements: Transactionally deduct from source branch inventory, add to destination (if applicable); update valuation, aging reports
- Integrations: Update carrier tracking if waybill provided; trigger webhooks for shipment updates; sync with order fulfillment state
- Accounting: Create transaction header + ledger_entry lines for movements; ensure reversals possible for errors
- Compliance: Audit all changes (audit_event); soft delete ineligible dispatches; handle fraud flags or domain guards
- Edge cases: Handle concurrent requests with idempotency; low stock conflicts; cycle count impacts; promo/reservation interactions
- Reporting: Update metrics for dispatch performance, SLA, inventory aging post-shipment"
114,dispatch,Receive Dispatch,Receive at destination,api/dispatches/{id}/receive,post,Employee,Implement Receive Dispatch API Endpoint (POST /api/dispatches/{id}/receive),"## Overview

This GitHub issue is for implementing the ""Receive Dispatch"" API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring approximately 290 REST APIs built over a normalized ERD. It covers domains including catalog (products/categories/vendors with attributes, media, barcodes, pricing, promotions), stores/branches, customers (with tags/blacklist), inventory (batch-centric with reservations, adjustments, cycle counts, valuation, ledgers), orders (order/order_item states from pending to confirmed/fulfilled/cancelled, assignment to store, notes/attachments, promos, taxes, fraud flags), fulfillment (shipments/shipment_items, inter-store dispatches with tracking, scan events, POD, and transactional stock movements), returns (RMA with return/return_items, receive/restock/scrap, refunds, exchanges), payments (intent to capture/void, refunds, order.payment_status sync), accounting (transaction headers + ledger_entries for movements, reversals, reconciliation/export), services (service/service_order lifecycle and profitability), integrations (carriers/accounts, waybills/rates/tracking, webhooks, notification templates for email/SMS), security/identity (user/role/permission with abilities and multi-roles, sessions, email verification, password reset, TOTP MFA + backup codes, API keys), observability/compliance (audit_events, logs, request-id, PII masking, health/metrics, queues, caching/etag), middleware (TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth via JWT/session/API key, active user, email-verified, 2FA, RBAC/permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards for order/payment/dispatch/reservation/promo/override/cycle-count/fraud, upload mime guard, provider webhook signatures + replay defense, cache headers), reporting/analytics (revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity), state machines for legal transitions (orders, order items, dispatch, shipments, returns, payments, cycle counts with RFC7807 problem+json on conflicts), bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, strict referential links. Design supports deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on stock/financial events.

The endpoint allows receiving a dispatch at its destination store/branch, updating status, handling scan events, triggering stock movements, ledger entries, and related business logic for inter-store inventory transfers.

## API Specifications

- **Category:** dispatch
- **Title:** Receive Dispatch
- **Description:** Receive at destination
- **Route:** api/dispatches/{id}/receive
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST endpoint to receive a dispatch by ID, updating its status to received and handling destination store assignment
- [ ] Validate that the dispatch exists, is in a receivable state (e.g., en-route via state machine), and the authenticating employee has permissions for the destination branch
- [ ] Handle successful receipt: update dispatch tracking/scan events, perform transactional stock movements (add to destination inventory batches, subtract from origin if needed), post ledger entries for inventory valuation, trigger notifications (email/SMS via templates), and audit the event
- [ ] Integrate with related domains: update reservations if applicable, sync with shipments/POD if linked, ensure referential integrity across junctions (e.g., dispatch/shipment_items)
- [ ] Add input validation for any request body (e.g., optional notes/attachments, received quantities per item if partial)
- [ ] Implement error handling: return RFC7807 problem+json for invalid states, permissions, or conflicts (e.g., insufficient stock, concurrent modifications via idempotency keys)
- [ ] Write unit/integration tests covering happy path, edge cases (e.g., partial receipt, cancellation mid-receipt), and error scenarios
- [ ] Ensure middleware application: auth (Employee JWT/session/API key), RBAC (dispatch receive permission), branch scope, throttles, input sanitizer, domain guards for dispatch/reservation/inventory
- [ ] Add observability: log request-id, audit_event for receipt action, PII masking if customer data involved
- [ ] Verify response includes updated dispatch details (status, tracking, stock impacts) and complies with caching/etag, versioned content-negotiation
- [ ] Test integration with reporting: update dispatch performance metrics, inventory aging

## Technical Requirements

- Use Laravel framework: Define route in api.php with {id} parameter binding to Dispatch model
- Create/Update DispatchController with receive method, leveraging Request validation (FormRequest class for body if needed)
- Employ state machine to enforce legal transitions (e.g., from 'en_route' to 'received'); use Eloquent for models (Dispatch, DispatchItem, InventoryBatch, LedgerEntry)
- Handle transactions: Use DB::transaction for atomicity across inventory movements, ledger postings, status updates
- Polymorphic relations for notes/attachments on dispatch; soft deletes for archival
- UTC handling for timestamps; optional EAV if custom receipt attributes needed
- Middleware chain: Include auth, permissions (via Gates/Policies for 'receive-dispatch' ability), branch scoping to destination
- Response: JSON with 200 OK on success, including dispatch resource (hypermedia links if applicable); errors as problem+json

## Authentication/Authorization Requirements

- Requires Employee authentication (JWT, session, or API key)
- Employee must be active, email-verified, and 2FA-enabled if policy requires
- RBAC: User must have 'receive-dispatch' permission via role(s); multi-role support
- Branch scope: Employee assigned to or permitted for destination branch of the dispatch
- Optional tenancy if multi-tenant setup

## Expected Request/Response Format Considerations

- **Request:** POST to /api/dispatches/{id}/receive; optional JSON body e.g., {""notes"": ""string"", ""attachments"": [...], ""received_quantities"": {""item_id"": qty}} for partial/complex receipts; use idempotency key header for retries
- **Response:** 200 OK with JSON: {""data"": {dispatch resource with updated status, items, tracking events, stock movements summary}, ""links"": {...}}; 4xx/5xx as problem+json (e.g., {""title"": ""Invalid State"", ""detail"": ""Dispatch not en-route"", ""status"": 409})
- Content negotiation: Versioned (e.g., Accept: application/vnd.deshio.v1+json); JSON limits enforced
- Idempotency: Replay defense for duplicate receives

## Relevant Business Logic

- Dispatch receipt finalizes inter-store transfer: Validate origin dispatch matches destination receive; handle batch-centric inventory (match batches, optional per-unit)
- Stock movements: Reservation consumption at origin if pending, addition to destination (with valuation method); trigger adjustments if discrepancies
- Ledger: Post transaction header + entries for inventory value transfer; support reversals if receipt fails post-commit
- State transitions: Use state machine; illegal transitions (e.g., receiving cancelled dispatch) return errors
- Integrations: Update tracking with scan event; trigger webhooks for delivery; notify via templates; link to shipments if external carrier involved
- Conflicts: Domain guards prevent oversights (e.g., low stock at destination, fraud flags); ensure consistent posting on events
- Analytics: Update dispatch SLA/performance, inventory aging; soft delete not applicable for receipts (archival via audits)"
115,dispatch,Reject Dispatch,Reject due to damage/mismatch,api/dispatches/{id}/reject,post,Employee,Implement POST /api/dispatches/{id}/reject for Rejecting Dispatches,"## Overview

In the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this endpoint enables employees to reject an inter-store dispatch due to damage or mismatch. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, ledgers. Order domain involves states (pending→confirmed→fulfilled|cancelled), assignment, notes/attachments, promos, taxes, fraud flags. Fulfillment includes shipments/shipment_items and dispatches with tracking, scan events, POD, transactional stock movements. Returns handle RMA, receive/restock/scrap, refunds, exchanges. Payments manage intents, captures/voids, refunds, synchronization. Accounting uses transaction headers + ledger_entries for movements, reversals, reconciliation/export. Services cover service_orders with lifecycle/profitability. Integrations include carriers, waybills/rates/tracking, webhooks, notifications. Security/identity: users/roles/permissions with abilities, multi-roles, sessions, email verification, password reset, TOTP MFA, API keys. Observability/compliance: audit_events, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC/permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines ensure legal transitions for orders, items, dispatches, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data in UTC; soft deletes; EAV for attributes; polymorphic notes/attachments; strict referential links. Design supports deterministic admin assignment, safe reservation/consumption, consistent ledger posting on stock/financial events.

This endpoint specifically rejects a dispatch, updating its state, reversing stock movements, posting ledger entries, and triggering audits/notifications as needed.

## API Specifications

- **Category:** dispatch
- **Title:** Reject Dispatch
- **Description:** Reject due to damage/mismatch
- **Route:** api/dispatches/{id}/reject
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST endpoint to reject a dispatch by ID, only if in a valid state (e.g., in-transit) per state machine rules
- [ ] Validate the dispatch ID exists and is accessible to the employee's branch/scope
- [ ] Handle rejection due to damage/mismatch, optionally accepting a reason in request body
- [ ] Update dispatch state to rejected, reverse any stock reservations/movements, post reversal ledger entries
- [ ] Trigger audit events, notifications (e.g., email/SMS via templates), and webhooks if configured
- [ ] Return 204 No Content on success, or RFC7807 problem+json for errors (e.g., invalid state, unauthorized)
- [ ] Ensure soft deletes and referential integrity are maintained
- [ ] Add unit/integration tests for success, invalid ID, unauthorized access, invalid state, and edge cases like concurrent updates
- [ ] Verify idempotency for repeated rejections
- [ ] Confirm PII masking in logs and compliance with observability standards

## Technical Requirements

- Define route in Laravel routes/api.php with middleware stack: auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks (employee role with dispatch reject permission), branch scope, throttles, idempotency, input sanitizer, domain guards for dispatch/reservation/fraud
- Create controller method in DispatchController (or similar) handling the rejection logic
- Use state machine to validate/enforce transition legality; throw ValidationException or custom error for conflicts
- Implement input validation: required dispatch ID (UUID/integer), optional request body { ""reason"": ""damage|mismatch"", ""notes"": ""string"" } with JSON schema validation
- Handle business logic: fetch dispatch via repository/Eloquent with branch scoping; check state; update status; reverse inventory via batch adjustments; post accounting transactions (headers + ledger_entries); attach polymorphic notes if provided; log audit_event with request-id
- Response: No content on success; errors as problem+json with title, detail, status, type per RFC7807
- Expected request format: POST with JSON body (optional reason/notes), Content-Type: application/json
- Expected response format: 204 or 4xx/5xx with problem+json; include ETag for caching if applicable
- Integrate with queues for async tasks (e.g., notifications, ledger posting); use UTC timestamps
- Add feature flag support for endpoint if needed; ensure versioned API (e.g., v1)
- Write tests using PHPUnit: mock auth/user, state machine, repositories; cover validation, authorization, business rules, error paths
- Documentation: Update OpenAPI spec with endpoint, params, body schema, responses; add examples for request/response"
116,dispatch,Add Tracking,Attach tracking info,api/dispatches/{id}/tracking,post,Employee,Implement Add Tracking Endpoint for Dispatches (POST /api/dispatches/{id}/tracking),"## Overview

As a technical writer creating GitHub issues for API implementation in the Deshio ERP system, this issue covers the development of the 'Add Tracking' API endpoint. Deshio is a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits.

Core entities include: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.

Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.

Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.

Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).

Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.

Services: service/service_order with lifecycle and profitability.

Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.

Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint specifically attaches tracking information to a dispatch, integrating with fulfillment logistics for inter-store dispatches, including tracking, scan events, and proof of delivery (POD), while ensuring transactional stock movements.

## API Specifications

- **Category:** dispatch
- **Title:** Add Tracking
- **Description:** Attach tracking info
- **Route:** api/dispatches/{id}/tracking
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST endpoint to attach tracking information to the specified dispatch
- [ ] Validate the dispatch ID exists and is in a valid state for tracking attachment (e.g., confirmed, using state machine)
- [ ] Ensure tracking attachment triggers any necessary events like notifications or ledger postings
- [ ] Add unit and integration tests covering success, validation errors, unauthorized access, and invalid states
- [ ] Verify response follows REST conventions with proper status codes (e.g., 201 Created on success, 422 Unprocessable Entity on validation failure)
- [ ] Confirm endpoint handles soft deletes and UTC timezones correctly
- [ ] Test for transactional integrity in stock movements related to dispatch
- [ ] Include audit logging for the tracking addition event
- [ ] Ensure compatibility with middleware stack (auth, RBAC, branch scope, etc.)
- [ ] Document the endpoint in API specs with request/response examples

## Technical Requirements

- Use Laravel framework: Define route in api.php, create or extend DispatchController with addTracking method
- Implement input validation using FormRequest class for tracking details (e.g., carrier_id, tracking_number, expected_delivery_date)
- Integrate with Dispatch model; associate tracking via polymorphic or dedicated tracking entity with scan events and POD support
- Handle business logic: Check dispatch state via state machine; if invalid transition, return RFC7807 problem+json error
- Ensure transactional stock movements if dispatch involves inventory (e.g., reservations or adjustments)
- Add proper error handling for cases like non-existent dispatch, concurrent updates (use optimistic locking or database transactions)
- Support idempotency for repeated requests
- Include ETag/caching headers if applicable; use request-id for observability
- Write comprehensive tests: PHPUnit for unit, feature tests for endpoint, including mock auth and RBAC

## Authentication/authorization Requirements

- Require Employee authentication via JWT, session, or API key
- Enforce RBAC: User must have permissions for dispatch management (e.g., 'dispatch.update' ability via role/permission)
- Apply branch scope: Employee can only access dispatches assigned to their branch/store
- Include middleware checks: active user, email-verified, 2FA if enabled
- For multi-role users, verify at least one role grants the necessary permission
- Reject unauthorized requests with 401/403 status and problem+json details

## Expected Request/Response Format Considerations

- **Request:** JSON body with fields like {""carrier_id"": integer, ""tracking_number"": string, ""notes"": string (optional), ""scan_events"": array (optional)}
  - Validate required fields, carrier existence, unique tracking number per dispatch
  - Use content-negotiation for JSON input; sanitize inputs via middleware
- **Response:** On success (201), return updated dispatch JSON with embedded tracking info, including ID, status, and timestamps
  - Include links for related resources (e.g., shipment, order)
  - On error (e.g., 404 Not Found for dispatch, 422 for validation), return RFC7807 problem+json with title, detail, and instance
- All dates in UTC ISO format; mask PII if tracking includes customer data
- Support bulk or partial updates if extending functionality, but start with single tracking addition

## Relevant Business Logic

- Dispatch tracking is part of fulfillment for inter-store movements; attaching info enables monitoring via waybills, rates, and carrier integrations
- Trigger webhooks for tracking updates and notification templates (email/SMS) for stakeholders
- Ensure state machine legality: Only attach tracking post-confirmation; invalid states block action and log audit_event
- Post ledger_entry for any financial/stock implications (e.g., valuation adjustments)
- Handle conflicts like existing tracking (update vs. error) based on business rules
- Integrate with reporting: Update dispatch performance metrics, SLA tracking
- Maintain referential integrity: Link to carriers/accounts; support polymorphic attachments/notes for tracking details
- If dispatch involves orders/shipments, synchronize statuses (e.g., order to 'in-transit')"
117,dispatch,Track Dispatch,Get live tracking info,api/dispatches/{id}/tracking,get,Employee,Implement Track Dispatch API: GET /api/dispatches/{id}/tracking,"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This issue is for implementing the 'Track Dispatch' API endpoint in the dispatch category. It provides live tracking information for a specific dispatch, including status, scan events, and proof of delivery (POD) details, integrating with the fulfillment domain's dispatch tracking features.

## API Specifications

- **Category:** dispatch
- **Title:** Track Dispatch
- **Description:** Get live tracking info
- **Route:** api/dispatches/{id}/tracking
- **HTTP Method:** GET
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET endpoint to retrieve live tracking information for a dispatch by ID
- [ ] Validate the dispatch ID exists and is accessible to the authenticated employee
- [ ] Ensure response includes dispatch status, scan events, tracking history, and POD if available
- [ ] Handle unauthorized access or non-existent dispatch with appropriate RFC7807 problem+json errors
- [ ] Add unit and integration tests covering success, validation errors, auth failures, and edge cases (e.g., soft-deleted dispatches)
- [ ] Verify integration with state machines for dispatch transitions and transactional stock movements
- [ ] Confirm middleware application: auth (JWT/session/API key), RBAC & permission checks, branch scope, throttles, idempotency, input sanitizer, domain guards for dispatch
- [ ] Ensure response caching/etag support and audit_event logging for the request
- [ ] Test for PII masking in tracking info if applicable (e.g., customer details)

## Technical Requirements

- Use Laravel controller (e.g., DispatchController@tracking) and define route in api.php with proper versioning and content-negotiation
- Implement input validation for {id} using Laravel's FormRequest or validator (must be valid UUID or integer)
- Fetch dispatch data from dispatch model, including related scan events, tracking, and POD; use eager loading for efficiency
- Integrate with observability: generate request-id, log events, emit audit_event on access
- Apply soft deletes check; return 404 for archived dispatches unless specified
- Support polymorphic attachments/notes if tracking includes them
- Ensure UTC handling and locale/tz awareness in any timestamped events
- Use queues if real-time tracking involves external integrations (e.g., carriers)
- Add feature flag support for endpoint if needed for rollout

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- Enforce active user, email-verified, and 2FA (TOTP MFA + backup codes) checks via middleware
- RBAC: Employee must have permission to view dispatch tracking (e.g., role↔perm ability for 'view-dispatch')
- Branch scope: Restrict to dispatches assigned to the employee's accessible stores/branches
- Optional tenancy if multi-tenant setup is enabled

## Expected Request/Response Format Considerations

- **Request:** No body; path param {id} for dispatch ID. Query params optional for filtering (e.g., ?include=events,pod)
- **Response:** JSON object with tracking details, e.g., {""dispatch_id"": ""uuid"", ""status"": ""in_transit"", ""events"": [{ ""timestamp"": ""UTC"", ""type"": ""scanned"", ""location"": ""..."" }], ""pod"": { ""delivered_at"": ""..."", ""signature"": ""..."" } }. Use HTTP 200 for success, 401/403 for auth/authz, 404 for not found, 422 for validation
- Follow RFC7807 for errors: problem+json with title, detail, type, status
- Include cache headers (ETag), Link headers if paginated events
- Ensure JSON limits and sanitizer applied; versioned response (e.g., Accept: application/vnd.deshio.v1+json)

## Relevant Business Logic

- Dispatch tracking ties into fulfillment: inter-store dispatch with scan events and POD, ensuring transactional stock movements and ledger posting
- Live info reflects current state from state machine (e.g., pending→in_transit→delivered|failed)
- Integrate with integrations for carrier tracking/waybills if external
- Conflicts (e.g., invalid transition) return problem+json; support webhooks for tracking updates
- Ensure deterministic handling for reservations/consumption during dispatch
- Analytics tie-in: Track dispatch performance metrics (e.g., SLA) via this endpoint's data"
118,dispatch,Scan Event,Append scan event,api/dispatches/{id}/scan-events,post,Employee,Implement POST /api/dispatches/{id}/scan-events for Scan Events,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue focuses on implementing the 'Scan Event' API endpoint in the dispatch category. Deshio handles core entities such as product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), and promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, and fraud flags. Fulfillment involves shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns cover RMA (return/return_item), receive/restock/scrap, refunds, and exchanges (exchange_order). Payments manage intent→payment capture/void, refund lifecycle, and order.payment_status synchronization. Accounting features transaction headers + ledger_entry lines for all movements, reversals, and reconciliation/export. Services include service/service_order with lifecycle and profitability. Integrations encompass carriers & accounts, waybills/rates/tracking, webhooks with deliveries, and notification templates (email/SMS). Security & identity involve user/role/permission with ability (role↔perm) and user_role (multi-role), sessions, email verification, password reset, TOTP MFA + backup codes, and API keys. Observability & compliance include audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plans cover TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, and cache headers. Reporting/analytics provide revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, and activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, and cycle counts, with conflicts returning RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC with soft deletes for archival, EAV for attributes, polymorphic notes/attachments, and strict referential links across all junctions. The design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint specifically allows appending a scan event to a dispatch for tracking purposes in inter-store dispatch workflows, ensuring transactional stock movements and audit compliance.

## API Specifications

- **Category:** dispatch
- **Title:** Scan Event
- **Description:** Append scan event
- **Route:** api/dispatches/{id}/scan-events
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST endpoint to append a scan event to the specified dispatch ID
- [ ] Ensure the endpoint integrates with dispatch tracking and scan events as per inter-store dispatch workflows
- [ ] Validate input data for scan events, including event type, timestamp, location, and scanner details
- [ ] Handle state machine transitions for dispatch legality, returning RFC7807 problem+json on conflicts
- [ ] Add comprehensive unit and integration tests covering success, validation errors, unauthorized access, and edge cases like invalid dispatch ID
- [ ] Verify audit_event logging for all scan event appendages, including request-id and PII masking
- [ ] Ensure transactional consistency with stock movements and ledger posting if applicable
- [ ] Test middleware application: auth (JWT/session for Employee), RBAC permission checks, branch scope, throttles, idempotency, and input sanitizer
- [ ] Confirm soft delete handling and UTC timestamping for new scan events
- [ ] Document the endpoint in API specs with examples

## Technical Requirements

- Develop in Laravel: Create a controller method in the DispatchController (or similar) handling the POST route
- Define the route in api.php with {id} parameter binding to Dispatch model
- Use Eloquent for Dispatch and ScanEvent models, ensuring polymorphic relations if needed for notes/attachments
- Implement input validation using Form Requests or Validator, covering required fields like event_type, location, and optional scanner_id/user_id
- Integrate with state machines to validate dispatch state transitions on scan event append
- Leverage queues for any asynchronous processing, such as notifications or ledger updates
- Apply domain guards for dispatch and reservation consistency
- Use caching/etag for response optimization if scan events are frequently accessed
- Ensure error handling follows RFC7807 for validation and business rule violations
- Support bulk operations if extending to multiple scan events, aligning with general API patterns

## Authentication/Authorization Requirements

- Require Employee authentication via JWT, session, or API key
- Enforce RBAC: User must have role/permission allowing dispatch scan event modifications (e.g., 'dispatch.update' ability)
- Apply active user, email-verified, and 2FA checks via middleware
- Scope to branch/store: Employee must have access to the dispatch's assigned branch
- Optional tenancy if multi-tenant setup is enabled
- Include session management and TOTP MFA validation for employee sessions

## Expected Request/Response Format Considerations

- **Request Format:** JSON body with fields such as {""event_type"": ""string (e.g., 'scanned', 'received')"", ""timestamp"": ""ISO 8601 UTC"", ""location"": ""string"", ""scanner_id"": ""optional uuid"", ""notes"": ""optional string"", ""attachments"": ""optional array of file ids""}. Use content-negotiation for JSON input with limits.
- **Response Format:** On success, return 201 Created with JSON {""id"": ""uuid"", ""dispatch_id"": ""uuid"", ""event_type"": ""string"", ""timestamp"": ""ISO 8601"", ""location"": ""string"", ...} including ETag for caching. On error, return RFC7807 problem+json (e.g., 422 for validation, 403 for auth, 404 for invalid dispatch).
- Sanitize inputs and mask PII in logs/responses.
- Support idempotency keys in headers to prevent duplicate scan events.
- Version the API (e.g., /v1/) and handle locale/tz via headers.

## Relevant Business Logic

- Scan events track dispatch progress in inter-store fulfillment, including scan events for POD (Proof of Delivery) and transactional stock movements.
- Append event only if dispatch state allows (via state machine: e.g., from 'in-transit' to 'delivered').
- Trigger related actions: Update dispatch tracking, post ledger entries for stock adjustments, send notifications (email/SMS via templates), and flag fraud if anomalous.
- Ensure referential integrity with strict links to dispatch, user, and location entities.
- Handle reversals if scan event leads to return/RMA workflows.
- Integrate with reporting: Update dispatch performance metrics and activity logs.
- Maintain consistency with reservations/consumption and cycle counts if inventory-impacting."
119,dispatch,Proof of Delivery,Upload POD,api/dispatches/{id}/pod,post,Employee,Implement POST /api/dispatches/{id}/pod for POD Upload,"## Overview

This GitHub issue is for implementing the 'Proof of Delivery' API endpoint in the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD. The system covers catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain handles states (pending→confirmed→fulfilled|cancelled), assignments, notes/attachments, promos, taxes, fraud flags. Fulfillment involves shipments and inter-store dispatch (including tracking, scan events, POD) with transactional stock movements. Returns cover RMA with receive/restock/scrap, refunds, exchanges. Payments manage intents, captures/voids, refunds, and order synchronization. Accounting uses transaction headers + ledger entries for movements, reversals, reconciliation/export. Services include service orders with lifecycle and profitability. Integrations handle carriers, waybills/rates/tracking, webhooks, notification templates (email/SMS). Security features user/role/permission with multi-role support, sessions, email verification, password reset, TOTP MFA + backup codes, API keys. Observability includes audit events, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware encompasses TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines ensure legal transitions for orders, dispatches, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, strict referential links. Design supports deterministic admin assignment, safe reservation/consumption, consistent ledger posting on stock/financial events.

This endpoint allows employees to upload Proof of Delivery (POD) for a specific dispatch, updating the dispatch status, triggering transactional stock movements, ledger entries, notifications, and webhooks as per business logic.

## API Specifications

- **Category:** dispatch
- **Title:** Proof of Delivery
- **Description:** Upload POD
- **Route:** api/dispatches/{id}/pod
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint handles POST requests to upload POD file for a given dispatch ID
- [ ] Validates dispatch existence and employee authorization to access/update it
- [ ] Supports file upload (e.g., images/documents) with MIME type validation
- [ ] Updates dispatch status to 'delivered' upon successful upload, respecting state machine transitions
- [ ] Triggers transactional stock movements, ledger postings, notifications (email/SMS), and webhooks
- [ ] Handles errors with RFC7807 problem+json format for invalid states or conflicts
- [ ] Includes audit events and logs for the upload action
- [ ] Unit and integration tests cover success, failure, validation, and authorization scenarios
- [ ] Documentation updated with request/response examples
- [ ] Endpoint integrated with middleware stack (auth, RBAC, upload guard, etc.)

## Technical Requirements

- Implement in Laravel: Define route in api.php, create/update DispatchController with podUpload method
- Use Laravel's file upload handling (e.g., $request->file('pod')) and store in media polymorphic relation (e.g., dispatch media)
- Integrate with Eloquent models: Dispatch model with state machine for transitions (e.g., using laravel-statable or similar)
- Handle attachments polymorphically (notes/attachments)
- Ensure soft deletes and UTC storage
- Add input validation using Form Requests: Validate dispatch ID exists, file is present and valid MIME (e.g., image/*, pdf), size limits
- Implement proper error handling: 404 for non-existent dispatch, 403 for unauthorized, 422 for validation errors, 409 for state conflicts
- Use RequestId middleware for tracing
- Cache headers and ETag support if applicable
- Queues for heavy operations like notifications or ledger posting
- Feature flags for enabling/disabling if needed
- Bulk operations not required, but idempotency key support via middleware

## Authentication/Authorization Requirements

- Requires Employee authentication (JWT/session/API key)
- RBAC check: Employee must have permission for dispatch updates (e.g., role→perm mapping for 'dispatch.update' or 'dispatch.pod')
- Active user, email-verified, 2FA if enabled
- Branch scope: Employee scoped to dispatch's branch/store
- Optional tenancy if multi-tenant setup

## Expected Request/Response Format Considerations

- **Request:** Multipart/form-data with 'pod' file field; optional fields like 'notes' (string) for additional comments
  Example:
  POST /api/dispatches/123/pod
  Content-Type: multipart/form-data
  Authorization: Bearer <token>
  Files: pod (image/jpeg, max 5MB)
  Form data: notes=""Delivery confirmed""

- **Response (Success - 201 Created):**
  {
    ""data"": {
      ""dispatch_id"": 123,
      ""pod_media_id"": 456,
      ""status"": ""delivered"",
      ""updated_at"": ""2023-10-01T12:00:00Z""
    },
    ""message"": ""POD uploaded successfully""
  }

- **Response (Error - e.g., 422 Unprocessable Entity):**
  HTTP/1.1 422 Unprocessable Entity
  Content-Type: application/problem+json
  {
    ""title"": ""Validation Error"",
    ""detail"": ""Invalid file type"",
    ""type"": ""https://example.com/probs/validation-error"",
    ""status"": 422,
    ""errors"": {
      ""pod"": [""File must be an image or PDF""]
    }
  }

- Versioned via content-negotiation (e.g., Accept: application/vnd.deshio.v1+json)
- JSON limits enforced by middleware

## Relevant Business Logic

- POD upload confirms delivery for inter-store dispatch, transitioning state via state machine (e.g., from 'in_transit' to 'delivered')
- On success: Consume reservations, post ledger entries for stock movements (transactional), update related shipment/order statuses if linked
- Trigger events: Notifications to stakeholders (templates for email/SMS), webhooks for integrations (e.g., carriers), audit_event logging
- Handle conflicts: If dispatch not in valid state (e.g., already delivered or cancelled), return 409 with problem+json
- Integrate with tracking/scan events: Append POD as final scan event
- Ensure referential integrity: Link POD media to dispatch via polymorphic relation
- Fraud/domain guards: Check for fraud flags on dispatch before allowing upload
- Post-upload: Potential for returns/RMA if issues arise later"
120,order,Create Order,Initialize order,api/orders,post,Employee,Implement POST /api/orders for Creating Orders,"## Overview

This GitHub issue tracks the implementation of the 'Create Order' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.

Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.

Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.

Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).

Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.

Services: service/service_order with lifecycle and profitability.

Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.

Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint initializes a new order, setting initial state to 'pending', handling order items, customer association, store assignment, and initial validations.

## API Specifications

- **Category:** order
- **Title:** Create Order
- **Description:** Initialize order
- **Route:** api/orders
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST /api/orders endpoint in Laravel controller
- [ ] Validate input data including customer, items, store assignment, and promotions
- [ ] Ensure order creation triggers state machine for 'pending' state and initial ledger postings
- [ ] Handle authentication and RBAC checks for employee users
- [ ] Return created order in JSON response with proper HTTP 201 status
- [ ] Implement error handling for invalid inputs or conflicts using RFC7807 problem+json
- [ ] Add unit and integration tests covering success, validation errors, and authorization failures
- [ ] Verify middleware integration (auth, RBAC, branch scope, idempotency)
- [ ] Ensure data integrity: UTC timestamps, soft delete readiness, referential integrity
- [ ] Test business logic: order item reservations, tax calculations, fraud flag

## Technical Requirements

- Use Laravel framework: Create or update OrdersController with store method
- Define routes in api.php with proper middleware stack (auth:employee, rbac:order.create, etc.)
- Input validation using Form Requests: Validate customer_id, store_id, items array (product_id, quantity, etc.), promo codes, notes
- Integrate with Eloquent models: Order, OrderItem, Customer, Store, with relationships
- Apply state machine for order lifecycle transitions
- Handle inventory reservations transactionally on creation
- Post to accounting ledger for initial order value
- Use queues for any async tasks like notifications
- Implement caching/etag if applicable, request-id tracing, audit_event logging
- Support attachments and polymorphic relations if notes/attachments provided

## Authentication/Authorization Requirements

- Requires 'Employee' authentication via JWT/session/API key
- RBAC check: User must have 'order.create' permission via role/permission abilities
- Active user, email-verified, 2FA if enabled
- Branch scope: Employee scoped to relevant stores/branches
- Optional tenancy isolation
- Throttling and idempotency keys to prevent duplicate orders

## Expected Request/Response Format Considerations

- **Request:** JSON body with fields like: customer_id (int), store_id (int), items (array of {product_id: int, quantity: int, attributes: object}), shipping_address (object), billing_address (object), promo_codes (array), notes (string), fraud_flag (bool). Use idempotency-key header.
- **Response:** 201 Created with JSON: {id: int, number: string, state: 'pending', customer: object, items: array, total: decimal, created_at: timestamp, ...} or 4xx/5xx errors in RFC7807 format.
- Versioned API: Support content-negotiation for API version
- PII masking in logs, input sanitization

## Relevant Business Logic

- Initialize order in 'pending' state; confirm later via state machine
- Assign to store/branch; validate stock availability and reserve batches
- Calculate pricing with overrides, promotions, taxes
- Associate with customer/tags/blacklist; check fraud indicators
- Support notes/attachments polymorphically
- Trigger ledger entries for order value; ensure transactional consistency
- Handle conflicts (e.g., insufficient inventory) with domain guards
- Enable future fulfillment: shipments, dispatches, payments integration
- Comply with observability: Log audit events, metrics for order creation SLA"
121,order,List Orders,Filter by status/date/customer,api/orders,get,Employee,Implement List Orders API Endpoint (GET /api/orders),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs over a normalized ERD, this issue covers the implementation of the 'List Orders' API endpoint. Deshio manages core entities including products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment involves shipments and inter-store dispatch with tracking and stock movements. Returns handle RMA with receive/restock/scrap, refunds, exchanges. Payments include intent→payment lifecycle and synchronization. Accounting features transaction headers + ledger_entry lines, reversals, reconciliation/export. Services cover service/service_order lifecycle. Integrations include carriers, webhooks, notifications. Security & identity: user/role/permission with multi-role support, sessions, email verification, password reset, TOTP MFA + backup codes, API keys. Observability: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines ensure legal transitions for orders and related entities, with conflicts returning RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, strict referential links. Design supports deterministic admin assignment, safe reservation/consumption, consistent ledger posting.

This endpoint allows filtering orders by status, date, and customer to retrieve a list of orders, enabling efficient order management in the retail/omni-channel workflow.

## API Specifications

- **Category:** order
- **Title:** List Orders
- **Description:** Filter by status/date/customer
- **Route:** api/orders
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET /api/orders endpoint in the Laravel controller
- [ ] Support filtering by order status (e.g., pending, confirmed, fulfilled, cancelled), date ranges, and customer identifiers
- [ ] Ensure pagination for large result sets, with support for page size and offset
- [ ] Handle authentication requiring employee role with appropriate RBAC permissions
- [ ] Validate query parameters for filters (status, date, customer) with proper error responses
- [ ] Return orders with relevant fields: id, status, customer info, date, store assignment, total, items summary, notes/attachments, promos, taxes, fraud flag
- [ ] Integrate state machine checks to ensure only valid order states are filterable
- [ ] Apply branch scope middleware to limit results to user's accessible branches/stores
- [ ] Include audit logging for API calls with request-id and PII masking
- [ ] Support search/autosuggest if extended filters are added
- [ ] Write unit and integration tests covering happy path, edge cases (e.g., no results, invalid filters), and error scenarios
- [ ] Ensure responses follow JSON API standards with ETag caching and content-negotiation
- [ ] Test for middleware stack: auth, RBAC, throttles, idempotency, input sanitizer
- [ ] Verify compatibility with soft deletes (exclude deleted orders unless specified)
- [ ] Document the endpoint in API specs with examples

## Technical Requirements

- Use Laravel controller (e.g., OrderController@index) and register route in api.php with proper versioning
- Implement query builder with filters: whereIn for status, whereBetween for dates (UTC), joins for customer data; apply scopes for branch and soft deletes
- Input validation: Use FormRequest or validator for query params (status as array/enum, dates as ISO8601, customer as ID/email)
- Error handling: Return 400 for invalid filters (RFC7807 problem+json), 401/403 for auth/RBAC issues, 429 for throttles
- Authentication/Authorization: Require JWT/session/API key for authenticated employee; RBAC check for 'view_orders' permission; active user, email-verified, 2FA if enabled; branch scope to filter by user's branches
- Expected Request Format: GET /api/orders?status[]=pending&status[]=confirmed&from_date=2023-01-01&to_date=2023-12-31&customer_id=123 (query params only, no body)
- Expected Response Format: 200 OK with JSON array/object: {""data"": [{id, status, customer: {id, name}, created_at, store_id, total_amount, items_count, ...}], ""meta"": {pagination info}, ""links"": {self, next, prev}} – include optional fields like fraud_flag, payment_status; use polymorphic relations for notes/attachments if expanded
- Business Logic: Orders follow state machine (pending→confirmed→fulfilled|cancelled); filters must respect legality; synchronize with payments (payment_status); support reservations and ledger postings indirectly via order data; handle promos/taxes in summary; exclude PII unless authorized; ensure deterministic assignment to stores
- Additional: Integrate with queues for heavy filtering if needed; support locale/tz for date filters; add domain guards for order access; use EAV for custom attributes if filterable; ensure referential integrity in queries"
122,order,Get Order,Get order with items,api/orders/{id},get,Employee,Implement GET /api/orders/{id} - Retrieve Order with Items,"## Overview

Deshio is a Laravel-based ERP system for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers.

The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment involves shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns handle RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments cover intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting uses transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services include service/service_order with lifecycle and profitability.

Integrations encompass carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity features user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance include audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint retrieves a specific order with its items, falling under the order category. It allows authenticated employees to fetch detailed order information, including state, items, assignments, notes, promotions, taxes, and fraud flags, ensuring integration with inventory, fulfillment, payments, and accounting domains.

## API Specifications

- **Category:** order
- **Title:** Get Order
- **Description:** Get order with items
- **Route:** api/orders/{id}
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint returns the full order details including order items, states, assignments, notes/attachments, promotions, taxes, and fraud flag for a valid order ID
- [ ] Handles non-existent order IDs with appropriate 404 error (RFC7807 problem+json)
- [ ] Ensures order state transitions are respected via state machine checks
- [ ] Includes related entities like customer tags/blacklist, store/branch assignment, and linked inventory batches
- [ ] Supports soft deletes by excluding archived orders or handling gracefully
- [ ] Implements caching/etag for performance, with proper cache headers
- [ ] Logs audit_event for access, with request-id and PII masking
- [ ] Validates input (order ID) and sanitizes output
- [ ] Returns data in UTC, with locale/tz considerations
- [ ] Integrates with RBAC for employee permissions and branch scope
- [ ] Writes unit/integration tests covering success, error cases, auth failures, and edge cases (e.g., cancelled/fulfilled orders)
- [ ] Documents the endpoint in API specs with examples

## Technical Requirements

- Use Laravel controller (e.g., OrderController@show) and define route in api.php with {id} parameter binding
- Implement input validation for {id} as UUID/integer using FormRequest or validator
- Fetch order using Eloquent with eager loading for items, customer, store, payments, shipments, etc., to avoid N+1 queries
- Apply soft deletes query scope if order is archived
- Use state machine to validate current order state and include in response
- Handle polymorphic relations for notes/attachments
- Ensure referential integrity checks for linked entities (e.g., order_items to products/batches)
- Integrate with middleware stack: auth (JWT/session/API key), RBAC/permission checks (e.g., 'view orders'), branch scope, throttles, idempotency if applicable
- Proper error handling: 404 for not found, 403 for unauthorized, 422 for invalid input, using RFC7807 format
- Add queueing if heavy computations (e.g., ledger summaries) are needed, but keep synchronous for single order
- Use EAV for dynamic attributes in response if applicable to orders
- Enable feature flags for endpoint if under maintenance

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- Employee must have active status, email-verified, and 2FA if enabled
- RBAC: User must have role/permission allowing 'view orders' or specific ability (role↔perm)
- Branch scope: Restrict to orders assigned to user's branches/stores
- Optional tenancy if multi-tenant setup
- Audit access with user_id in audit_event

## Expected Request/Response Format Considerations

- **Request:** GET /api/orders/{id} (no body; {id} as path param, e.g., UUID or integer)
- **Response:** 200 OK with JSON object:
  {
    ""data"": {
      ""id"": ""uuid"",
      ""state"": ""confirmed"",
      ""customer"": { ... },
      ""store"": { ... },
      ""items"": [ { ""product"": { ... }, ""quantity"": 1, ""price"": ... , ""batch"": { ... } } ],
      ""promotions"": [ ... ],
      ""taxes"": { ... },
      ""fraud_flag"": false,
      ""notes"": [ ... ],
      ""attachments"": [ ... ],
      ""payments"": { ""status"": ""paid"", ... },
      ""shipments"": [ ... ],
      ""ledger_entries"": [ ... ] // summary if needed
    },
    ""meta"": { ""request_id"": ""..."", ""timestamp"": ""UTC"" }
  }
- Include ETag for caching; support If-None-Match
- Errors: RFC7807 problem+json, e.g., { ""type"": ""https://example.com/probs/order-not-found"", ""title"": ""Not Found"", ""status"": 404, ""detail"": ""Order does not exist"" }
- Versioned via content-negotiation (e.g., Accept: application/vnd.deshio.v1+json)
- JSON limits enforced; sanitize inputs/outputs

## Relevant Business Logic

- Order retrieval must reflect current state (pending/confirmed/fulfilled/cancelled) and prevent access to invalid transitions
- Include linked fulfillment (shipments/dispatch) with tracking/POD if applicable
- Sync payment_status and handle refunds/exchanges if order involves returns (RMA)
- Ensure inventory reservations/consumptions are reflected in item batches
- Post to ledger on-the-fly summary if financials queried, but avoid full computation
- Fraud flag integration for risk assessment
- Customer tags/blacklist to influence visibility or additional checks
- Deterministic assignment to admin/store for online orders
- Consistent posting to accounting ledger for any stock/financial events tied to the order
- Use domain guards for order-specific validations (e.g., promo/override eligibility)
- Support attachments/media polymorphic to order/order_item"
123,order,Update Order,Update fields,api/orders/{id},put,Employee,Implement PUT /api/orders/{id} - Update Order Endpoint,"## Overview

This GitHub issue is for implementing the 'Update Order' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint allows updating fields on an existing order, respecting order states, RBAC permissions, and business rules like state machine transitions.

## API Specifications

- **Category:** order
- **Title:** Update Order
- **Description:** Update fields
- **Route:** api/orders/{id}
- **HTTP Method:** put
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the PUT /api/orders/{id} endpoint in Laravel controller
- [ ] Validate input fields for order updates, including order items, notes, attachments, promos, taxes, and fraud flags
- [ ] Enforce state machine transitions for order and order_item states (e.g., pending→confirmed→fulfilled|cancelled)
- [ ] Handle authorization for Employee role with RBAC checks, branch scope, and permission verification
- [ ] Integrate with inventory reservations, ledger postings, and payment synchronization on updates
- [ ] Return RFC7807 problem+json for conflicts, invalid states, or permission errors
- [ ] Add unit and integration tests covering valid updates, state transitions, errors, and edge cases like soft deletes
- [ ] Ensure middleware application: auth (JWT/session/API key), RBAC, throttles, idempotency, input sanitizer
- [ ] Document request/response schemas, including expected fields for order updates
- [ ] Verify audit_event logging and request-id tracing for the endpoint

## Technical Requirements

- Use Laravel controller and routes for the endpoint
- Implement input validation with Laravel's Form Requests or Validator, supporting EAV attributes and polymorphic relations
- Handle business logic: Validate order state transitions via state machines; trigger transactional stock movements if inventory affected; post to accounting ledgers for financial changes; synchronize payment_status if payments updated
- Authentication/authorization: Require Employee authentication; check user_role permissions for order updates; apply branch scope; enforce active user, email-verified, and 2FA if enabled; use domain guards for order/reservation/promo/override/fraud
- Expected request/response format: Request body as JSON with updatable fields (e.g., {""notes"": ""Updated notes"", ""order_items"": [...], ""promos"": [...], ""taxes"": {...}, ""fraud_flag"": true}); Response: Updated order JSON (200 OK) or problem+json (4xx/5xx); Use versioned content-negotiation, JSON limits, and cache headers
- Error handling: Soft deletes for archival; PII masking in logs; return detailed errors per RFC7807
- Integrations: If updates affect shipments, dispatches, returns, or payments, trigger related state changes and webhooks; Support attachments uploads with mime guard
- Observability: Log audit_event for updates; Include request-id; Metrics for endpoint performance
- Data considerations: All data in UTC; Strict referential integrity; Optional tenancy support
- Testing: Cover bulk scenarios if applicable; Ensure idempotency for repeated updates"
124,order,Cancel Order,Cancel order,api/orders/{id}/cancel,post,Employee,Implement Cancel Order API Endpoint (POST /api/orders/{id}/cancel),"## Overview

This GitHub issue is for implementing the 'Cancel Order' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs built over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits.

Core entities include: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.

Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.

Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.

Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).

Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.

Services: service/service_order with lifecycle and profitability.

Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.

Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The 'Cancel Order' endpoint allows authorized employees to cancel an existing order, transitioning its state to 'cancelled' if permissible, while handling associated business logic such as inventory reservations, payments, and ledger entries.

## API Specifications

- **Category:** order
- **Title:** Cancel Order
- **Description:** Cancel order
- **Route:** api/orders/{id}/cancel
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint responds to POST requests at /api/orders/{id}/cancel
- [ ] Requires Employee authentication via JWT/session/API key
- [ ] Validates the order ID exists and is accessible (considering branch scope)
- [ ] Checks order state for cancellability using state machine (e.g., pending or confirmed, not fulfilled)
- [ ] Handles cancellation: updates order state to 'cancelled', releases inventory reservations, reverses any payments if applicable, posts ledger entries for reversals
- [ ] Returns RFC7807 problem+json for invalid states/transitions or unauthorized access
- [ ] Logs audit_event for the cancellation action
- [ ] Includes proper middleware: auth, RBAC permission check, branch scope, idempotency, input sanitizer
- [ ] Supports soft deletes and maintains referential integrity
- [ ] Unit and integration tests cover success, failure (invalid state, unauthorized), and edge cases (e.g., with promotions/taxes)
- [ ] Documentation updated with request/response examples and error codes

## Technical Requirements

- Implement in Laravel: Define route in api.php, create or update OrdersController with cancel method
- Use state machine for order transitions to ensure legality
- Integrate with inventory: Release reservations on order items
- Sync with payments: Void or refund intents if payment captured
- Post accounting entries: Create transaction headers and ledger_entry lines for reversal
- Apply middleware stack: auth (Employee), active user, email-verified, 2FA, RBAC (permission to cancel orders), branch scope
- Handle errors with standardized RFC7807 responses
- Ensure transactional consistency for stock/financial events
- Use UTC for timestamps; support caching/etag if applicable
- Add request ID for observability and logging

## Authentication/Authorization Requirements

- Authentication: Employee via JWT, session, or API key
- Authorization: RBAC check for permission to cancel orders (e.g., role with 'order.cancel' ability)
- Additional guards: Active user, email-verified, 2FA if enabled, branch scope (order assigned to user's branch)
- Optional: Tenancy if multi-tenant setup

## Expected Request/Response Format Considerations

- **Request:** POST /api/orders/{id}/cancel
  - Body: Optional JSON with reason (e.g., {""reason"": ""customer_request""}) for notes/attachments
  - Headers: Authorization, Content-Type: application/json, X-Request-ID
- **Response:** 
  - Success (200): {""data"": {""order"": {updated order details}, ""message"": ""Order cancelled successfully""}}
  - Error (e.g., 400/403/422): RFC7807 problem+json, e.g., {""title"": ""Invalid order state"", ""detail"": ""Order cannot be cancelled once fulfilled"", ""type"": ""https://example.com/probs/order-invalid-transition""}
- Versioned content-negotiation; JSON limits enforced

## Relevant Business Logic

- Order states: Transition from pending/confirmed to cancelled only if not fulfilled or already cancelled
- On cancel: Release inventory reservations/adjustments, reverse promotions/taxes, flag fraud if applicable, synchronize payment_status
- Create polymorphic notes/attachments for cancellation reason
- Ensure ledger posting for all financial/stock movements; support reversals
- If shipment/dispatch initiated, may require additional checks or partial cancels
- Trigger notifications (email/SMS) via templates if configured
- Maintain consistency with returns/exchanges if order has RMAs
- Conflicts (e.g., concurrent modifications) handled via idempotency keys"
125,order,Confirm Order,Confirm after payment/validation,api/orders/{id}/confirm,post,Employee,Implement Confirm Order API Endpoint (POST /api/orders/{id}/confirm),"## Overview

This GitHub issue is for implementing the 'Confirm Order' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.

Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.

Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.

Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.

Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).

Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.

Services: service/service_order with lifecycle and profitability.

Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.

Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint confirms an order after payment/validation, transitioning it from pending to confirmed state.

## API Specifications

- **Category:** order
- **Title:** Confirm Order
- **Description:** Confirm after payment/validation
- **Route:** api/orders/{id}/confirm
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint handles POST requests to confirm the specified order ID
- [ ] Validates that the order exists and is in a pending state
- [ ] Checks for successful payment or validation before confirmation
- [ ] Transitions order state to 'confirmed' using state machine
- [ ] Reserves inventory if applicable (batch-centric with reservations)
- [ ] Posts ledger entries for accounting (transaction headers + ledger_entry lines)
- [ ] Updates order assignment to store and applies promos/taxes if needed
- [ ] Handles fraud flags and returns appropriate errors
- [ ] Returns RFC7807 problem+json for conflicts or invalid transitions
- [ ] Includes audit_event logging for the confirmation action
- [ ] Integrates with middleware chain (auth, RBAC, branch scope, etc.)
- [ ] Unit and integration tests cover happy path, errors, and edge cases
- [ ] Documentation updated for API usage

## Technical Requirements

- Implement in Laravel controller (e.g., OrderController@confirm)
- Define route in api.php with {id} parameter binding to Order model
- Use Request validation for any input (likely minimal or empty body)
- Apply domain guards for order confirmation (e.g., payment status sync)
- Leverage state machine for order state transition (pending → confirmed)
- Ensure transactional stock movements and ledger posting on confirmation
- Handle soft deletes and UTC timestamps
- Use EAV for any attribute updates if relevant
- Integrate with observability: audit_event, request-id, PII masking
- Support idempotency for repeated confirmations
- Follow content-negotiation for versioned responses

## Authentication/Authorization Requirements

- Requires Employee authentication (JWT/session/API key)
- Enforce RBAC: User must have role/permission for order confirmation (e.g., ability in role↔perm)
- Apply active user, email-verified, and 2FA checks via middleware
- Branch scope: Confirm only orders assignable to user's branch/store
- Optional tenancy if multi-tenant setup

## Expected Request/Response Format Considerations

- **Request:** POST with optional JSON body (e.g., {""notes"": ""string""} for polymorphic notes); {id} as path param (UUID or integer)
- **Response:** 200 OK with confirmed order JSON (include id, state: 'confirmed', updated_at, payment_status); or 204 No Content
- Error responses: 400/403/404/422 with RFC7807 problem+json (e.g., {""title"": ""Invalid State"", ""detail"": ""Order not pending""})
- Headers: Cache-Control, ETag if applicable; Request-Id for tracing
- Content-Type: application/json; versioned via Accept header

## Relevant Business Logic

- Confirm only after payment capture/validation; sync order.payment_status
- Transition via state machine: Ensure legality (pending → confirmed); block if fraud flagged or inventory unavailable
- Trigger downstream: Inventory reservation/consumption, ledger posting for financial events, potential notifications (email/SMS templates)
- Handle attachments/notes: Allow adding polymorphic notes during confirmation
- Ensure consistency: Deterministic assignment to store, safe reservation, no partial confirms
- Reversals: Support if later cancelled (fulfilled|cancelled states)
- Integrations: If confirmed, may trigger shipment creation or dispatch"
126,order,Assign Store,Assign order to a store,api/orders/{id}/assign-store,post,Admin,Implement API: Assign Order to Store (POST /api/orders/{id}/assign-store),"## Overview

This GitHub issue is for implementing the 'Assign Store' API endpoint in the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations. The endpoint allows assigning an order to a specific store or branch, which is crucial for order fulfillment, inventory management, and logistics. This supports core entities like orders with states (pending→confirmed→fulfilled|cancelled), stores/branches, and ensures deterministic admin assignment for online orders. The implementation must align with Deshio's normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Data is stored in UTC, with soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential links. State machines drive legality of transitions, returning RFC7807 problem+json for conflicts.

Deshio features ~290 REST APIs, batch-centric inventory with reservations/adjustments/cycle counts/valuation/ledgers, fulfillment via shipments/dispatches with tracking/POD, returns (RMA)/refunds/exchanges, payments with intent capture/void/refund lifecycle, accounting ledgers for movements/reversals/reconciliation, services with profitability, integrations (carriers/webhooks/notifications), security (user/role/permission, JWT/session/API key, 2FA, API keys), observability (audits/logs/PII masking/health/metrics), middleware (TLS/CORS/RequestId/auth/RBAC/branch scope/throttles/idempotency/sanitizer/domain guards), reporting (revenue/LTV/AOV/returns/SLA/inventory/promo impact), bulk import/export/search/attachments/reindex/backups/feature flags/maintenance.

## API Specifications

- **Category:** order
- **Title:** Assign Store
- **Description:** Assign order to a store
- **Route:** api/orders/{id}/assign-store
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST endpoint to assign a store to an order
- [ ] Validate request input (e.g., store_id must exist and be valid for the branch scope)
- [ ] Ensure order state allows assignment (e.g., pending or confirmed, per state machine)
- [ ] Update order record with store assignment, triggering any related events (e.g., inventory reservations, ledger postings)
- [ ] Handle errors appropriately (e.g., order not found: 404; invalid state: 422 with RFC7807 problem+json; unauthorized: 403)
- [ ] Add unit tests for controller logic, validation, and business rules
- [ ] Add integration tests for full request/response flow, including middleware
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger)
- [ ] Ensure compatibility with bulk operations, search, and reporting (e.g., update order analytics)
- [ ] Verify soft deletes and referential integrity are respected

## Technical Requirements

- Use Laravel controller (e.g., OrderController@assignStore) and define route in api.php with {id} parameter binding
- Implement input validation using FormRequest (e.g., require 'store_id' as integer, exists in stores table)
- Apply middleware stack: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks (e.g., 'orders.assign-store'), branch scope, throttles, idempotency, input sanitizer, domain guards (order/reservation), cache headers
- Integrate with state machine for order transitions; prevent assignment if fulfilled/cancelled
- Trigger transactional stock movements/reservations if applicable, and post to accounting ledger for consistency
- Use Eloquent for order/store relations; ensure polymorphic attachments/notes can reference the assignment
- Handle bulk/import scenarios if order is part of a batch; support feature flags for endpoint
- Implement observability: log audit_event, request-id tracing, PII masking; queue if async processing needed
- Error handling: Return RFC7807 problem+json for validation/state conflicts; 201/200 for success with updated order or 204 No Content

## Authentication/Authorization Requirements

- Require Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have role with permission 'orders.assign-store' via ability (role↔perm) and user_role (multi-role)
- Apply branch scope to ensure store assignment is within user's accessible branches
- Include active user check, email verification, and optional 2FA/TOTP
- Optional tenancy isolation if multi-tenant mode enabled

## Expected Request/Response Format Considerations

- **Request:** JSON body, e.g., {""store_id"": 123} (validate store exists, belongs to valid branch, compatible with order)
- **Headers:** Accept: application/json, Content-Type: application/json, Authorization: Bearer <token>, X-Request-Id, X-Branch-Scope
- **Response (Success - 200 OK):** JSON with updated order object, including assigned store details, e.g., {""data"": {""id"": 456, ""store"": {""id"": 123, ""name"": ""Branch A""}, ""state"": ""confirmed""}}
- **Response (Created/Assigned - 201 Created):** If new assignment triggers creation (e.g., shipment), return location header
- **Response (No Content - 204):** If assignment is a simple update without body return
- **Error Responses:** 400/422 for validation (problem+json with type/title/detail/instance), 403 for authz, 404 for not found, 429 for throttling
- Support ETag/caching for order reads post-assignment; versioned API (e.g., /v1/)

## Relevant Business Logic

- Assignment enables fulfillment routing to store/branch for inventory pickup/shipping; supports inter-store dispatch if needed
- Validate order state via state machine: Allow only for pending/confirmed; transition if required (e.g., to confirmed)
- Check fraud flag, promos/taxes compatibility with store pricing/overrides
- Ensure safe reservation/consumption of inventory batches; post ledger_entry for stock/financial movements
- If order has items, verify store has sufficient stock or trigger adjustments/cycle counts
- Handle notes/attachments: Allow adding assignment note polymorphically
- Integrate with reporting: Update revenue/orders by store, SLA/dispatch performance metrics
- Conflicts (e.g., store out of scope, reservation failure) return detailed problem+json; support idempotency for retries
- Align with overall design: Deterministic assignment for online orders, consistent ledger posting on events, UTC storage"
127,order,Reassign Store,Reassign to another store,api/orders/{id}/reassign-store,post,Admin,Implement API: Reassign Order to Store (POST /api/orders/{id}/reassign-store),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the 'Reassign Store' endpoint. This endpoint allows reassigning an existing order to another store/branch, handling core entities like orders and stores. Key context includes: product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments, inter-store dispatch with tracking. Returns: RMA with receive/restock/scrap, refunds, exchanges. Payments: intent→payment, refunds, synchronization. Accounting: transaction headers + ledger_entry for movements. Services: service/service_order. Integrations: carriers, webhooks, notifications. Security: user/role/permission, sessions, MFA, API keys. Observability: audit_event, logs, PII masking. Middleware: TLS/HSTS, CORS, auth (JWT/session/API key), RBAC, branch scope, throttles, etc. Reporting: revenue, LTV/AOV, etc. State machines for transitions; conflicts return RFC7807 problem+json. APIs include bulk ops, search, attachments. Data in UTC; soft deletes; EAV attributes; polymorphic relations; deterministic assignment, safe reservation/consumption, ledger posting.

This endpoint supports reassigning orders while ensuring inventory reservations, stock movements, and ledger consistency.

## API Specifications

- **Category:** order
- **Title:** Reassign Store
- **Description:** Reassign to another store
- **Route:** api/orders/{id}/reassign-store
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint handles POST requests to reassign order to a new store
- [ ] Validates order exists and is in a reassignable state (e.g., pending or confirmed, not fulfilled/cancelled)
- [ ] Validates target store exists and is active
- [ ] Checks branch scope and permissions for the admin user
- [ ] Handles inventory reservations: transfers or cancels reservations in old store, attempts new reservations in target store
- [ ] Updates order assignment, triggers state machine transition if needed, posts ledger entries for any stock/financial movements
- [ ] Processes related entities: updates shipment/dispatch if applicable, recalculates taxes/promos if store-specific
- [ ] Returns success response with updated order data or error in RFC7807 format for conflicts (e.g., insufficient stock)
- [ ] Implements idempotency for safe retries
- [ ] Adds audit_event for the reassignment action
- [ ] Includes unit/integration tests covering happy path, validation errors, permission denials, inventory failures
- [ ] Ensures soft deletes and referential integrity are respected
- [ ] Documents request/response schemas in OpenAPI/Swagger

## Technical Requirements

- Use Laravel controller (e.g., OrderController@reassignStore) and register route in api.php with middleware stack: auth (JWT/API key), active user, email-verified, 2FA (if enabled), RBAC & permission checks (e.g., 'orders.reassign'), branch scope
- Input validation: Use FormRequest for {id} (UUID/integer), request body with 'store_id' (required, exists in stores table, active), optional 'reason' for notes
- Handle state machine: Verify legality of reassignment transition for order/order_items; use conflicts for invalid states
- Business logic: On success, update order.store_id, cascade to order_items if needed; manage reservations via inventory service (reserve in new store, release in old); trigger transactional stock movements if inventory affected; post accounting ledger_entries for any value changes (e.g., price overrides); polymorphic attachments/notes preserved
- Error handling: 404 for non-existent order/store, 403 for unauthorized, 422 for validation, 409 for conflicts (e.g., stock unavailability, ongoing fulfillment); use problem+json with request-id
- Observability: Log action with request-id, audit_event with user/store details, PII masking for customer data; queue heavy ops like inventory adjustments if needed
- Caching: Invalidate order-related caches/etags post-update
- Data integrity: All ops in transactions; UTC timestamps; soft delete if order becomes invalid
- Integrations: If order has payments/promos, sync status; notify via webhooks if reassignment impacts fulfillment

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC: User must have role with permission 'orders.reassign' (via ability/role/permission tables, multi-role support)
- Branch scope: Admin must have access to both source and target stores (e.g., via user_role or tenancy if enabled)
- Additional guards: Email-verified, active user, optional 2FA; domain guards for order/reservation/promo/override

## Expected Request/Response Format Considerations

- **Request:** JSON body: {""store_id"": ""uuid-or-id"", ""reason"": ""optional string""}; {id} in path as order identifier (UUID/integer)
- **Response:** 200 OK with JSON: {""data"": {""order"": {updated order object with store_id, status, etc.}}, ""message"": ""Order reassigned successfully""}; Include ETag for caching
- **Errors:** 4xx/5xx in problem+json: e.g., {""type"": ""https://example.com/probs/out-of-stock"", ""title"": ""Reassignment failed"", ""detail"": ""Insufficient inventory in target store"", ""status"": 409}
- Content negotiation: Versioned API (e.g., /v1/), locale/tz from headers; JSON limits enforced
- Bulk considerations: N/A for this endpoint, but ensure scalability for high-volume reassignments

## Relevant Business Logic

- Reassignment only for orders in eligible states (pending/confirmed); use state machines to enforce
- Inventory: Batch-centric; check availability in target store before reassigning reservations; support inter-store dispatch if needed
- Financial: Recalculate pricing/taxes/promos based on new store (price_override, store-specific rules); post ledger_entries for adjustments, ensure reversals if partial
- Fulfillment: If shipment/dispatch exists, update or create new; handle RMA/exchanges if order is in return state
- Compliance: Audit all changes; PII masking in logs; feature flags for enabling reassignment
- Edge cases: Fraud-flagged orders block reassignment; cycle counts/inventory aging unaffected unless stock moved; promo impact recalculated for reporting
- Deterministic: Safe reservation/consumption; consistent ledger on every event"
128,order,Reserve Items,Reserve inventory for order,api/orders/{id}/reserve,post,Employee,Implement Reserve Items API for Orders in Deshio ERP,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the 'Reserve Items' API endpoint. This endpoint reserves inventory for a specific order, supporting core entities like products, inventory (batch-centric with reservations), and orders (with states like pending→confirmed). Inventory supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain includes order/order_item states, assignment to store, notes/attachments, promos, taxes, and fraud flags. The design ensures deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event. State machines drive legality of transitions for orders and order items, with conflicts returning RFC7807 problem+json.

## API Specifications

- **Category:** order
- **Title:** Reserve Items
- **Description:** Reserve inventory for order
- **Route:** api/orders/{id}/reserve
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint successfully reserves inventory for the specified order ID
- [ ] Validates that the order exists and is in a reservable state (e.g., pending or confirmed)
- [ ] Checks inventory availability across batches and reserves stock transactionally
- [ ] Handles cases where insufficient inventory exists, returning appropriate errors
- [ ] Updates order status and posts to inventory ledger upon successful reservation
- [ ] Integrates with middleware for auth, RBAC, branch scope, and idempotency
- [ ] Includes unit and integration tests covering success, failure, and edge cases
- [ ] Ensures data consistency with soft deletes, UTC storage, and referential integrity
- [ ] Documents the endpoint in API specs with request/response examples

## Technical Requirements

- Implement in Laravel controller (e.g., OrderController) with route registration in api.php
- Use Eloquent models for Order, OrderItem, InventoryBatch, and related entities
- Apply input validation using Form Requests or Validator facade for order ID and any optional parameters
- Handle errors with RFC7807 problem+json format for validation failures, unauthorized access, or business rule violations
- Integrate state machine for order/order_item transitions to ensure legal reservation
- Perform transactional stock movements: reserve from available batches, update reservations, and ledger entries
- Support polymorphic notes/attachments if reservation notes are added
- Use middleware stack: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, JWT/session/API key auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope, throttles, idempotency, input sanitizer, domain guards (order/reservation), cache headers
- Ensure observability: audit_event logging, request-id tracing, PII masking
- Add bulk considerations if extending to multiple items, but focus on single order reservation

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- RBAC: User must have role/permission for order management (e.g., ability role↔perm mapping for 'reserve-order')
- Multi-role support via user_role junction
- Enforce active user, email verification, and optional TOTP MFA + backup codes
- Branch scope: Employee must be scoped to the order's assigned store/branch
- Optional tenancy if multi-tenant setup is enabled

## Expected Request/Response Format Considerations

- **Request:** POST to /api/orders/{id}/reserve
  - Path param: id (UUID/integer of order)
  - Body: JSON optional, e.g., {""notes"": ""string"", ""reserve_all"": true} for custom reservations or full order
  - Content-Type: application/json
  - Idempotency-Key header for safe retries

- **Response:** 
  - Success (200 OK): {""data"": {""order_id"": ""uuid"", ""reserved_items"": [...], ""status"": ""confirmed""}, ""message"": ""Items reserved successfully""}
  - Error (4xx/5xx): RFC7807 problem+json, e.g., {""type"": ""https://example.com/probs/out-of-stock"", ""title"": ""Insufficient Inventory"", ""detail"": ""..."", ""status"": 400}

- Use ETag/caching headers for responses
- Versioned API (e.g., /api/v1/...)
- All data in UTC; handle locale/tz in middleware

## Relevant Business Logic

- Verify order state allows reservation (pending→confirmed); use state machine for transitions
- For each order_item, locate available batch inventory (per-unit or batch-centric) in the assigned store/branch
- Reserve stock: deduct from available, add to reserved (supports reservations, adjustments, cycle counts)
- If partial reservation possible, reserve what’s available and flag partial in response
- Post to accounting ledger: transaction header + ledger_entry for stock movement
- Handle fraud flag or blacklist on customer/order
- Integrate with promotions/pricing if reservation affects overrides
- On failure (e.g., low stock, aging inventory), suggest alternatives like inter-store dispatch
- Ensure safe consumption: reservations expire or convert on fulfillment/cancellation
- Conflicts (e.g., concurrent reservations) use optimistic locking or domain guards
- Support for returns/exchanges if reservation ties to RMA, but focus on initial order reservation"
129,order,Release Reservation,Release order reservation,api/orders/{id}/release-reservation,post,Employee,Implement Release Order Reservation API Endpoint,"## Overview

Deshio is a Laravel-based ERP system for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment involves shipments and inter-store dispatch with transactional stock movements. This API endpoint, 'Release Reservation', is part of the order category and allows releasing reservations for an order, enabling deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on stock/financial events. State machines drive legality of transitions for orders, with conflicts returning RFC7807 problem+json. Data is stored in UTC, uses soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential links.

## API Specifications

- **Category:** order
- **Title:** Release Reservation
- **Description:** Release order reservation
- **Route:** api/orders/{id}/release-reservation
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST endpoint at api/orders/{id}/release-reservation to release reservations for the specified order
- [ ] Ensure the endpoint validates the order ID exists and is in a state allowing reservation release (e.g., pending or confirmed)
- [ ] Verify that releasing the reservation updates inventory ledgers transactionally, reversing any reservations without affecting fulfilled items
- [ ] Add RBAC checks to restrict access to authenticated employees with appropriate permissions (e.g., order management abilities)
- [ ] Handle errors per RFC7807 problem+json for invalid states, unauthorized access, or concurrent modifications
- [ ] Write unit and integration tests covering success, failure (e.g., invalid ID, unauthorized), and edge cases (e.g., partial reservations)
- [ ] Ensure the endpoint integrates with middleware stack: auth (JWT/session/API key), active user, RBAC & permission checks, branch scope, input sanitizer, domain guards (order/reservation), idempotency, and cache headers
- [ ] Confirm response includes updated order status or reservation details if applicable, with ETag for caching
- [ ] Test for consistency with order state machine transitions and audit logging of the release event

## Technical Requirements

- Develop in Laravel: Create a dedicated controller method in OrdersController or a resource-specific controller for handling the release logic
- Define the route in api.php with proper middleware application (e.g., auth:employee, rbac:order.release-reservation)
- Implement input validation: Ensure {id} is a valid UUID/integer for the order; no request body expected, but validate if any optional parameters (e.g., reason for release)
- Use Eloquent models for Order, OrderItem, InventoryReservation, and LedgerEntry; trigger state machine transition via service class for releasing reservations
- Integrate with inventory services for batch-centric reservation reversal, updating stock levels and posting ledger entries for the movement
- Apply soft deletes and referential integrity checks; use transactions to ensure atomicity across order, inventory, and accounting updates
- Include observability: Log the event in audit_event table, propagate request-id, and mask any PII
- Support bulk operations if extensible, but focus on single order for this endpoint; consider idempotency keys for retry safety
- Align with system-wide features: Queues for async ledger posting if heavy, caching/etag for order data, and feature flags for enabling/disabling

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- Enforce RBAC: User must have role with permission for order reservation release (e.g., ability: order.release-reservation), considering multi-role assignments
- Apply branch scope: Employee can only release reservations for orders assigned to their accessible stores/branches
- Additional checks: Active user status, email verification, optional 2FA; reject if user is inactive or lacks permission, returning 403 Forbidden
- Integrate with middleware: auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope

## Expected Request/Response Format Considerations

- **Request:** POST /api/orders/{id}/release-reservation
  - Path param: {id} - Order identifier (UUID or integer)
  - Headers: Authorization (Bearer/JWT), X-Request-ID, If-Match (ETag for concurrency)
  - Body: Empty JSON {} or optional { ""reason"": ""string"" } for notes
  - Content-Type: application/json; versioned via Accept: application/vnd.deshio.v1+json

- **Success Response (200 OK):** 
  {
    ""data"": {
      ""order"": { ""id"": ""uuid"", ""status"": ""updated_state"", ""reservation_status"": ""released"" },
    ""message"": ""Reservation released successfully""
  }
  Headers: ETag, Cache-Control, X-Request-ID

- **Error Responses:**
  - 400 Bad Request: Invalid order ID or state (problem+json with type, title, detail)
  - 401 Unauthorized: Missing/invalid auth
  - 403 Forbidden: Insufficient permissions or branch scope
  - 404 Not Found: Order not found
  - 409 Conflict: Concurrent modification (ETag mismatch) or invalid state transition
  - 422 Unprocessable Entity: Validation failure

- Responses in JSON API format, localized via content-negotiation, with timestamps in UTC

## Relevant Business Logic

- Reservations are tied to order items in pending/confirmed states, holding inventory batches/units to prevent overselling
- Releasing reservations (e.g., on cancellation or timeout) reverses holds, making stock available for other orders; must not affect confirmed/fulfilled items
- Trigger ledger entries for reservation reversal as negative movements, ensuring accounting consistency
- Use state machines to validate transition legality: Only allow release if order state permits (e.g., not fulfilled); deny with problem+json if conflict
- Integrate with order lifecycle: Update order.payment_status if applicable, flag for fraud checks, and log notes/attachments if reason provided
- Ensure transactional safety: Rollback on failure to avoid partial releases; support inter-store dispatch if reservation spans branches
- Align with reporting: Update metrics for inventory aging, reservation turnover, and order SLA; enable audit trails for compliance
- Consider extensions: Webhooks for reservation release events, notifications (email/SMS) to admins, and integration with promotions/taxes if impacted"
130,order,Add Note,Add internal note,api/orders/{id}/notes,post,Employee,Implement Add Note API Endpoint for Orders,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue covers the implementation of the 'Add Note' API endpoint in the order category. This endpoint allows adding internal notes to orders, supporting polymorphic notes/attachments as per the system's design. Core entities include product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with reservations, adjustments, etc. Order domain includes states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment covers shipments, inter-store dispatch with tracking. Returns: RMA with receive/restock/scrap, refunds, exchanges. Payments: intent→payment lifecycle. Accounting: transaction headers + ledger entries. Services: service orders. Integrations: carriers, webhooks, notifications. Security: user/role/permission, sessions, MFA, API keys. Observability: audit_event, logs, PII masking, middleware (TLS/HSTS, CORS, auth, RBAC, throttles, etc.). Reporting: various analytics. State machines for transitions; bulk import/export; data in UTC, soft deletes, EAV for attributes. Design ensures deterministic assignment, safe reservations, consistent ledger posting.

The 'Add Note' endpoint enables internal documentation on orders, enhancing auditability and collaboration.

## API Specifications

- **Category:** order
- **Title:** Add Note
- **Description:** Add internal note
- **Route:** api/orders/{id}/notes
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST endpoint at api/orders/{id}/notes to add an internal note to the specified order
- [ ] Ensure the endpoint requires Employee authentication and appropriate RBAC permissions (e.g., permission to view/modify orders and add notes)
- [ ] Validate input: order ID exists, note content is provided and sanitized, user has branch scope if applicable
- [ ] Handle errors per RFC7807 problem+json for invalid order, unauthorized access, validation failures, or state machine conflicts
- [ ] Create a polymorphic note/attachment record linked to the order, with audit_event logging
- [ ] Support soft deletes and referential integrity
- [ ] Add unit/integration tests covering success, auth failure, validation errors, and edge cases (e.g., non-existent order)
- [ ] Verify middleware application: auth (JWT/session/API key), active user, email-verified, 2FA, RBAC checks, branch scope, input sanitizer, idempotency if applicable
- [ ] Ensure response includes the created note details and proper cache headers
- [ ] Document the endpoint in API specs with request/response examples

## Technical Requirements

- Use Laravel controller (e.g., OrderNoteController) and define route in api.php with proper middleware stack
- Implement input validation using Form Requests or Validator: require 'content' as string (e.g., max 10000 chars), optional fields like 'type' (default 'internal')
- Handle order retrieval with eager loading if needed, check order state for legality via state machine
- Persist note as polymorphic relation (e.g., Note model with noteable_type='Order', noteable_id={id})
- Proper error handling: 401/403 for auth/perm, 404 for order not found, 422 for validation, 409 for conflicts
- Integrate with audit logging: record audit_event for note creation
- Consider queues/caching/etag for performance if notes are frequently accessed
- Ensure data in UTC, support feature flags if notes are optional
- Follow Deshio conventions: request-id, JSON limits, versioned content-negotiation, locale/tz

## Authentication/Authorization Requirements

- Authentication: Employee via JWT, session, or API key
- Authorization: RBAC check - user must have role/permission allowing order modifications and note additions (e.g., 'orders.update' ability)
- Middleware: active user, email-verified, 2FA if enabled, branch scope (notes scoped to user's branches), optional tenancy
- Domain guards: validate order ownership/scope to prevent cross-branch notes

## Expected Request/Response Format Considerations

- **Request:** JSON body with { ""content"": ""Internal note text"", ""type"": ""internal"" (optional) }; order {id} in path
- **Response:** 201 Created with JSON { ""data"": { ""id"": note_id, ""content"": ""..."", ""type"": ""internal"", ""created_by"": user_id, ""created_at"": timestamp, ""order_id"": id } }; include Links for related order if HATEOAS
- Errors: RFC7807 problem+json, e.g., { ""title"": ""Validation Error"", ""detail"": ""..."", ""status"": 422, ""type"": URI }
- Headers: Content-Type: application/json, X-Request-Id, Cache-Control

## Relevant Business Logic

- Notes are internal (not customer-facing) and polymorphic for reuse across entities
- On creation, trigger any notification templates (e.g., email/SMS to assigned users) if configured
- Ensure consistency: no stock/financial impacts, but log for audits/compliance
- State machine: only allow if order state permits modifications (e.g., not fully archived)
- Integrations: potential webhook delivery for note events if subscribed
- PII masking: sanitize note content if it contains sensitive data
- Support attachments if extended, but for this endpoint, focus on text notes"
131,order,List Notes,List internal notes,api/orders/{id}/notes,get,Employee,Implement API: List Notes for Orders (GET /api/orders/{id}/notes),"## Overview

Deshio is a Laravel-based ERP system for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain handles order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, and fraud flags. Fulfillment involves shipments and inter-store dispatches with tracking and stock movements. Returns manage RMAs, restocking, refunds, and exchanges. Payments track intents, captures, voids, refunds, and order synchronization. Accounting uses transaction headers and ledger entries for movements, reversals, and reconciliation. Services cover service orders with lifecycle and profitability. Integrations include carriers, webhooks, and notifications. Security features user/role/permission RBAC, sessions, email verification, password reset, TOTP MFA, API keys. Observability includes audits, logs, PII masking, health/metrics, queues, caching. Middleware enforces TLS/HSTS, CORS, auth (JWT/session/API key), RBAC, branch scope, throttles, idempotency, sanitization, and more. Reporting covers revenue, LTV/AOV, returns, inventory aging, etc. State machines ensure legal transitions for orders, shipments, returns, payments; conflicts use RFC7807 problem+json. APIs support bulk operations, search, attachments, reindexing, backups, feature flags. Data uses UTC, soft deletes, EAV for attributes, polymorphic notes/attachments, strict referential integrity. Design supports deterministic assignment, safe reservations, consistent ledger posting.

This issue implements the 'List Notes' API endpoint in the order category, which lists internal notes for a specific order. Notes are polymorphic and can include attachments, as per the system's design.

## API Specifications

- **Category:** order
- **Title:** List Notes
- **Description:** List internal notes
- **Route:** api/orders/{id}/notes
- **HTTP Method:** GET
- **Authentication:** Employee (RBAC via user/role/permission with ability checks)

## Acceptance Criteria

- [ ] Endpoint returns a list of internal notes associated with the specified order ID
- [ ] Supports pagination, filtering, and sorting if applicable (e.g., by creation date, author)
- [ ] Handles invalid or non-existent order ID with appropriate 404 error (RFC7807 problem+json)
- [ ] Enforces employee authentication and authorization (e.g., permission to view order notes)
- [ ] Applies branch scope if the order is assigned to a specific store/branch
- [ ] Includes note details such as content, author (user), timestamp, and any attachments
- [ ] Uses state machine checks if notes are tied to order state transitions
- [ ] Supports soft deletes (excludes deleted notes unless specified)
- [ ] Response includes ETag for caching and proper cache headers
- [ ] Input validation for order ID (UUID or integer as per ERD)
- [ ] Write unit/integration tests covering success, auth failure, invalid ID, pagination
- [ ] Document the endpoint in API specs (e.g., OpenAPI)
- [ ] Ensure idempotency and request ID logging

## Technical Requirements

- Implement in Laravel: Define route in api.php, create dedicated controller method (e.g., OrderNoteController@index)
- Use Eloquent models for Order and polymorphic Note (with morphTo on notable_type/notable_id linking to orders)
- Input validation: Validate {id} as required UUID/integer; optional query params for pagination (per_page, page), search, sort
- Query optimization: Eager load relations (e.g., author User, attachments); apply scopes for branch/user permissions
- Error handling: Use Problem Details (RFC7807) for validation/auth errors; HTTP 401/403 for auth issues, 404 for not found
- Response format: JSON array of notes with fields like id, content, author_id, created_at, updated_at, attachments[]; paginated if applicable (using LengthAwarePaginator)
- Authentication/Authorization: Middleware stack includes auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks (e.g., 'view-order-notes'), branch scope
- Business logic: Notes are internal (employee-only); ensure read access based on order visibility; log audit_event for access; mask PII if notes contain sensitive data; handle polymorphic relations securely
- Integrations: If notes have attachments, include media URLs; support search/autosuggest if extended
- Observability: Add request-id, log access; metrics for endpoint usage; queue if heavy (but likely sync for list)
- Testing: Cover auth scenarios, edge cases (empty notes, large lists), performance for 100+ notes
- Deployment: Versioned API (e.g., v1), content-negotiation, locale/tz handling, JSON limits"
132,order,Attach File,Attach document/image,api/orders/{id}/attachments,post,Employee,Implement API: Attach File to Order (POST /api/orders/{id}/attachments),"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint allows attaching documents or images to an order, supporting polymorphic attachments for notes and files in the order domain.

## API Specifications

- **Category:** order
- **Title:** Attach File
- **Description:** Attach document/image
- **Route:** api/orders/{id}/attachments
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST endpoint to attach files to orders
- [ ] Validate order existence and employee permissions before attachment
- [ ] Handle file uploads with MIME type validation and size limits
- [ ] Store attachments polymorphically linked to the order entity
- [ ] Generate audit events for attachment actions
- [ ] Return RFC7807 problem+json for validation or authorization errors
- [ ] Ensure compatibility with state machines for order lifecycle
- [ ] Write unit and integration tests covering success, failure, and edge cases
- [ ] Document the endpoint in API specs with examples
- [ ] Integrate with middleware stack including upload mime guard and RBAC checks

## Technical Requirements

- Use Laravel controller and routes for implementation
- Leverage Eloquent models for orders and polymorphic attachments (e.g., notes/attachments table)
- Implement input validation using Laravel's FormRequest or Validator, including file type (e.g., image/document MIME), size, and order ID
- Apply proper error handling with try-catch, logging via audit_event and request-id
- Ensure data storage in UTC with soft deletes enabled
- Integrate with observability: log events, metrics, and PII masking if applicable
- Support caching/etag and queueing for large uploads if needed
- Use state machines to check order state legality for attachments (e.g., only attach to non-cancelled orders)
- Handle transactional consistency for attachment creation and any related ledger postings

## Authentication/Authorization Requirements

- Require Employee authentication via JWT/session/API key
- Enforce RBAC: Employee must have permissions for order attachments (e.g., via role/permission checks)
- Apply middleware: auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope
- Include domain guards for order access (e.g., employee scoped to correct branch/store)
- Throttle requests and ensure idempotency for upload retries

## Expected Request/Response Format Considerations

- **Request:** Multipart/form-data with file upload (e.g., 'file' field) and optional metadata (e.g., 'description' for notes); order ID in path
- **Validation:** Order must exist and not be soft-deleted; file must pass upload mime guard
- **Response:** JSON with attachment details (e.g., { ""id"": 123, ""url"": ""/attachments/123"", ""mime_type"": ""image/jpeg"", ""created_at"": ""UTC timestamp"" }); 201 Created on success
- **Errors:** 400 for invalid input, 401/403 for auth issues, 404 for non-existent order, 422 for validation failures (RFC7807 format)
- Support versioned content-negotiation and locale/tz from middleware

## Relevant Business Logic

- Attachments are polymorphic and link to order/order_item for documents/images supporting notes/attachments in order domain
- Ensure attachments do not trigger stock/financial events but log via audit_event
- Integrate with order states: attachments allowed in pending/confirmed/fulfilled but blocked in cancelled via state machine
- Support fraud flag checks if attachment relates to suspicious activity
- Enable search/autosuggest and export for attached files in reporting
- Consistent with design for safe reservation/consumption and ledger posting on events"
133,order,List Attachments,List attachments,api/orders/{id}/attachments,get,Employee,Implement API: List Order Attachments (GET /api/orders/{id}/attachments),"## Overview

This GitHub issue is for implementing the 'List Attachments' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain involves order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Attachments are polymorphic, linking to orders via notes/attachments. Fulfillment includes shipments, inter-store dispatch with tracking and scan events. Returns handle RMA with receive/restock/scrap, refunds, exchanges. Payments manage intent→capture/void, refunds, and order.payment_status sync. Accounting uses transaction headers + ledger_entry lines for movements, reversals, reconciliation/export. Services cover service/service_order lifecycle and profitability. Integrations include carriers, webhooks, notifications. Security features user/role/permission with multi-role support, sessions, email verification, password reset, TOTP MFA, API keys. Observability includes audit_event, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware encompasses TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures, cache headers. Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines ensure legal transitions for orders, items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links. Design supports deterministic admin assignment, safe reservation/consumption, consistent ledger posting on stock/financial events.

This endpoint lists attachments associated with a specific order, supporting the polymorphic attachments feature in the order domain.

## API Specifications

- **Category:** order
- **Title:** List Attachments
- **Description:** List attachments
- **Route:** api/orders/{id}/attachments
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET endpoint to list attachments for a given order ID
- [ ] Ensure the endpoint retrieves polymorphic attachments linked to the order entity
- [ ] Validate that the order exists and is accessible to the authenticated employee
- [ ] Handle soft deletes appropriately (e.g., exclude deleted attachments)
- [ ] Support pagination, filtering, and sorting if applicable to attachments
- [ ] Return attachments with relevant metadata (e.g., file name, type, upload date, notes)
- [ ] Add unit and integration tests covering success, error cases (e.g., invalid order ID, unauthorized access)
- [ ] Verify compliance with middleware (e.g., RBAC, branch scope, idempotency)
- [ ] Ensure responses use UTC timestamps and follow content-negotiation
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger)

## Technical Requirements

- Use Laravel framework: Define route in api.php, create or extend OrderController with attachments method
- Implement query to fetch attachments via polymorphic relationship (e.g., Order::findOrFail($id)->attachments())
- Apply Eloquent scopes for soft deletes and active records
- Integrate with state machines if attachment visibility depends on order state
- Use Laravel's resource classes for response formatting (e.g., AttachmentResource collection)
- Handle exceptions with RFC7807 problem+json for errors (e.g., 404 for non-existent order)
- Ensure query optimization with indexes on order_id and polymorphic_type
- Support bulk operations if attachments are numerous, using cursor pagination
- Log audit events for access to order attachments
- Cache responses with ETag if applicable, respecting cache headers middleware

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- Enforce RBAC: Employee must have permissions to view orders and attachments (e.g., 'order.view', 'attachment.view')
- Apply branch scope: Restrict to orders/attachments within the employee's assigned branches/stores
- Check active user status, email verification, and 2FA if enabled
- Use middleware chain: auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope
- For multi-role users, evaluate all roles for required abilities

## Expected Request/Response Format Considerations

- **Request:** GET /api/orders/{id}/attachments
  - Path param: id (UUID or integer for order ID)
  - Query params: Optional pagination (page, limit), filters (e.g., type, created_after), sorting (e.g., created_at desc)
  - Headers: Authorization, Accept (application/json), X-Request-ID, X-Branch-ID (for scope)

- **Response:** 200 OK with JSON array of attachments
  - Example: {""data"": [{ ""id"": 1, ""filename"": ""invoice.pdf"", ""mime_type"": ""application/pdf"", ""url"": ""/storage/attachments/1"", ""created_at"": ""2023-01-01T00:00:00Z"", ""note"": ""Order invoice"" }, ...], ""meta"": { ""current_page"": 1, ""per_page"": 15, ""total"": 50 } }
  - Error responses: 401 Unauthorized, 403 Forbidden, 404 Not Found, 422 Unprocessable (validation), with problem+json details
  - Use versioned content-negotiation (e.g., Accept: application/vnd.deshio.v1+json)
  - Mask PII in attachments if applicable (e.g., redact sensitive data in previews)

## Relevant Business Logic

- Attachments are polymorphic and can link to orders, notes, or other entities; fetch only those directly or indirectly tied to the order
- Respect order states: e.g., attachments may be restricted in cancelled/fulfilled states based on permissions
- Ensure transactional integrity: No stock or ledger impacts, but audit access for compliance
- Support media handling: Generate secure URLs for downloads, enforce upload mime guards on creation (though this is list-only)
- Integrate with notifications: Attachments may trigger email/SMS via templates if linked to events
- Handle fraud flags: If order has fraud flag, additional logging or restrictions on attachment access
- Conflicts (e.g., concurrent access) resolved via idempotency keys if extended to mutations, but for GET, use request-id for tracing
- Data in UTC; soft deletes allow archival without permanent removal"
134,order-item,Add Item,Add product to order,api/orders/{id}/items,post,Employee,Implement Add Item to Order API Endpoint (POST /api/orders/{id}/items),"## Overview

This GitHub issue is for implementing the 'Add Item' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.

Core entities include: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint allows adding a product to an existing order, updating order states and inventory reservations as needed.

## API Specifications

- **Category:** order-item
- **Title:** Add Item
- **Description:** Add product to order
- **Route:** api/orders/{id}/items
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST /api/orders/{id}/items endpoint in Laravel controller
- [ ] Validate input parameters including product ID, quantity, and optional attributes like price overrides or promotions
- [ ] Ensure the order exists and is in a valid state (e.g., pending or confirmed) for adding items
- [ ] Handle inventory reservations: check stock availability, reserve batch-centric inventory, and create transactional stock movements
- [ ] Update order totals, taxes, and apply promotions if applicable
- [ ] Create order_item record with proper associations to product, order, and any media/barcodes
- [ ] Post ledger entries for financial impact and audit events for compliance
- [ ] Return RFC7807 problem+json for conflicts (e.g., insufficient stock, invalid state transition)
- [ ] Integrate with state machines to validate order_item state transitions
- [ ] Write unit and integration tests covering success, validation errors, and edge cases (e.g., fraud flag, branch scope)
- [ ] Add API documentation in OpenAPI/Swagger format
- [ ] Ensure endpoint respects middleware: auth, RBAC (employee permissions), branch scope, idempotency, and input sanitization

## Technical Requirements

- Use Laravel controller and routes: Define route in api.php with middleware stack (auth:employee, rbac:order.write, branch.scope)
- Input validation: Use FormRequest with rules for {id} (exists:orders,id), product_id (exists:products,id), quantity (integer>0), optional fields like unit_price, discount, attributes (EAV)
- Proper error handling: 404 for non-existent order, 422 for validation/inventory errors, 403 for unauthorized access, 409 for state conflicts
- Database transactions: Wrap order_item creation, inventory reservation, and ledger posting in a transaction to ensure consistency
- Soft deletes: Respect soft deletes on related entities (e.g., products)
- UTC handling: All timestamps in UTC
- Performance: Use ETags/caching for order reads, queue heavy operations like notifications

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT/session/API key
- RBAC: Employee must have permission for order.write or similar ability in their roles
- Additional checks: User must be active, email-verified, 2FA if enabled; scope to specific branch/store for the order
- Idempotency: Support idempotency keys to prevent duplicate additions

## Expected Request/Response Format Considerations

- **Request Body (JSON):** {
  ""product_id"": ""uuid"",
  ""quantity"": 1,
  ""unit_price"": 10.99, // optional, defaults to product price
  ""attributes"": {}, // EAV for custom fields
  ""promotion_code"": ""string"", // optional
  ""notes"": ""string"" // polymorphic
}
- **Path Parameter:** {id} - Order UUID
- **Response (201 Created):** {
  ""data"": {
    ""order_item"": { ... }, // full order_item with relations (product, order)
    ""order"": { ... } // updated order summary
  }
}
- **Error Responses:** Standard RFC7807 format, e.g., {
  ""title"": ""Insufficient Stock"",
  ""status"": 409,
  ""detail"": ""...""
}
- Content negotiation: Versioned API (e.g., v1), JSON only, with locale/tz support

## Relevant Business Logic

- State Machine: Validate order state allows adding items (e.g., not fulfilled/cancelled); transition order_item to pending
- Inventory: Batch-centric check/reservation; if per-unit, handle individually; trigger adjustments if needed
- Pricing/Promos: Apply price_override if provided, validate promotions, recalculate taxes and totals
- Fraud/Compliance: Check fraud flag on order; log audit_event; mask PII in logs
- Integrations: If adding triggers shipment/dispatch, prepare for webhooks; sync payment_status if partial fulfillment
- Edge Cases: Handle returns/exchanges by linking to RMA if applicable; support service_orders if product is a service
- Ledger: Post transaction header + ledger_entry for value change; ensure reversals possible"
135,order-item,Update Item,Update quantity/status,api/orders/{id}/items/{item_id},put,Employee,Implement PUT /api/orders/{id}/items/{item_id} - Update Item,"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint allows updating the quantity or status of an order item within the order domain, ensuring compliance with state machine transitions and inventory reservations.

## API Specifications

- **Category:** order-item
- **Title:** Update Item
- **Description:** Update quantity/status
- **Route:** api/orders/{id}/items/{item_id}
- **HTTP Method:** put
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the PUT endpoint for updating order item quantity and status
- [ ] Validate that the order and item exist and are accessible to the authenticated employee
- [ ] Enforce state machine rules for status transitions (e.g., pending→confirmed→fulfilled|cancelled)
- [ ] Handle inventory reservations and adjustments if quantity changes affect stock
- [ ] Update related entities like order totals, taxes, promos, and ledger entries if applicable
- [ ] Return RFC7807 problem+json for invalid transitions or conflicts
- [ ] Add unit and integration tests covering success, failure, and edge cases
- [ ] Ensure soft deletes and UTC handling are respected
- [ ] Implement audit logging for the update event

## Technical Requirements

- Use Laravel controller (e.g., OrderItemController@update) and define route in api.php
- Apply middleware stack: auth (JWT/session/API key), RBAC & permission checks, branch scope, input sanitizer, domain guards (order/reservation/promo/override/fraud)
- Input validation using Form Requests: require order_id, item_id, and fields like quantity (numeric, positive), status (enum based on state machine)
- Integrate with state machines for order_item transitions; prevent illegal changes
- Handle transactional updates: update order_item, adjust inventory if needed, post to accounting ledger
- Support idempotency via headers to prevent duplicate updates
- Use Eloquent for database operations with strict referential integrity
- Cache invalidation if applicable (e.g., order totals)
- Error handling: 404 for non-existent order/item, 403 for unauthorized access, 422 for validation errors, 409 for state conflicts

## Authentication/Authorization Requirements

- Requires Employee authentication (JWT/session/API key)
- Employee must have RBAC permissions for order management (e.g., update_order_item ability)
- Scope to specific branch/store if order is assigned
- Enforce active user, email-verified, and 2FA if enabled
- Audit the action with request-id and user context

## Expected Request/Response Format Considerations

- **Request Body (JSON):** {""quantity"": integer (optional), ""status"": string (enum: pending, confirmed, fulfilled, cancelled) (optional), ""notes"": string (optional)}
- Validate against order item schema; partial updates allowed
- **Response (200 OK, JSON):** Updated order item object with full details (id, order_id, product_id, quantity, status, created_at, updated_at)
- Include related data like product attributes if changed; embed order summary if relevant
- **Error Responses:** Use RFC7807 format, e.g., {""type"": ""https://example.com/probs/state-transition-invalid"", ""title"": ""Invalid Transition"", ""status"": 409, ""detail"": ""Cannot update status from pending to fulfilled""}
- Headers: ETag for caching, X-Request-Id for tracing

## Relevant Business Logic

- Quantity updates must check and adjust reservations; trigger stock movements if fulfilled
- Status changes follow state machine: validate legality (e.g., cannot cancel fulfilled item), update order status if all items align
- If quantity=0, consider cancellation logic with refunds/payments sync
- Recalculate order totals, taxes, promos; flag fraud if suspicious changes
- Post ledger entries for any financial/stock impact; support reversals
- Integrate with fulfillment (shipments) or returns (RMA) if status implies
- Ensure consistency across domains: inventory ledgers, accounting transactions
- Handle polymorphic attachments/notes if added during update"
136,order-item,Remove Item,Remove product from order,api/orders/{id}/items/{item_id},delete,Employee,Implement DELETE /api/orders/{id}/items/{item_id} to Remove Order Item,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this GitHub issue covers the implementation of the 'Remove Item' API endpoint in the order-item category. This endpoint enables authenticated employees to remove a product from an order, ensuring compliance with order states (pending→confirmed→fulfilled|cancelled), state machine transitions for legality, and integration with inventory reservations, pricing, promotions, and accounting ledgers. Core entities involved include order/order_item, with attributes like notes/attachments, promos, taxes, and fraud flags. Removal must handle transactional stock movements, reversals in ledgers, and soft deletes for archival. Data is stored in UTC, with strict referential integrity across junctions. Middleware includes auth (JWT/session/API key), RBAC & permission checks, branch scope, input sanitizer, and domain guards (order/reservation/promo/override). State machines ensure conflicts return RFC7807 problem+json. This aligns with broader features like bulk operations, search, attachments, and observability (audit_event, logs, request-id).

## API Specifications

- **Category:** order-item
- **Title:** Remove Item
- **Description:** Remove product from order
- **Route:** api/orders/{id}/items/{item_id}
- **HTTP Method:** DELETE
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint successfully removes an order item if the order is in a valid state (e.g., pending) and the item exists
- [ ] Validates that the authenticated employee has RBAC permissions for order management and branch scope
- [ ] Handles cases where order is confirmed/fulfilled/cancelled by returning appropriate error (e.g., 409 Conflict with problem+json)
- [ ] Releases any inventory reservations tied to the removed item and posts reversal ledger entries for accounting
- [ ] Updates order totals, taxes, promotions, and pricing overrides affected by the removal
- [ ] Returns 204 No Content on success, 404 if order/item not found, 403 if unauthorized, 422 for validation errors
- [ ] Implements idempotency and replay defense via middleware
- [ ] Logs audit_event for the removal action with request-id and PII masking
- [ ] Includes unit/integration tests covering happy path, edge cases (e.g., last item removal, promo impact), and error scenarios
- [ ] Ensures compatibility with soft deletes, EAV attributes, and polymorphic relations (e.g., notes/attachments on item)
- [ ] Verifies transactional consistency: rollback on failure to maintain referential integrity and ledger balance

## Technical Requirements

- Develop in Laravel: Define route in api.php, create dedicated controller method (e.g., OrderItemController@destroy)
- Implement input validation: Ensure {id} and {item_id} are valid UUIDs/integers, item belongs to order, order assigned to employee's branch
- Authorization: Use policies/gates for employee auth, email-verified, 2FA if enabled, and specific permissions (e.g., 'orders.edit')
- Business Logic: Check order state via state machine; if allowed, delete item (soft delete), trigger events for reservation release, total recalculation, promo re-evaluation, tax adjustment, and ledger posting (transaction header + ledger_entry lines with reversal if needed); handle interdependencies like shipments/dispatches if partially fulfilled
- Request Format: No body required; path params only
- Response Format: 204 on success; errors as JSON with RFC7807 structure (type, title, detail, instance); include cache headers and etag if applicable
- Integration: Hook into services for notifications (email/SMS templates), webhooks if configured, and queues for async tasks (e.g., inventory adjustments)
- Error Handling: Domain guards for order/payment/reservation/promo/override; custom exceptions for state conflicts
- Testing: PHPUnit tests for controller, validation, auth; feature tests simulating full flow; mock state machine and ledger services
- Documentation: Update API docs with OpenAPI spec, examples, and edge cases; ensure versioned content-negotiation
- Observability: Add metrics for endpoint usage, integrate with health checks, and support feature flags for rollout

Relevant Deshio Context: Inventory is batch-centric with reservations/adjustments; orders support assignment to stores, fraud flags; fulfillment involves shipments/dispatches with tracking; payments sync status; accounting ensures reversals/reconciliation; security includes TOTP MFA, API keys; reporting tracks order metrics like AOV, return rates."
137,order-item,Substitute Item,Substitute with another product,api/orders/{id}/items/{item_id}/substitute,post,Employee,Implement Substitute Item API for Order Items,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD, this issue covers implementing the 'Substitute Item' endpoint in the order-item category. Deshio covers catalog, orders, inventory, logistics, payments, RBAC, and audits.

Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint allows substituting an order item with another product, ensuring compliance with order states, inventory availability, and ledger updates.

## API Specifications

- **Category:** order-item
- **Title:** Substitute Item
- **Description:** Substitute with another product
- **Route:** api/orders/{id}/items/{item_id}/substitute
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint handles substitution requests for order items in valid states (e.g., pending or confirmed)
- [ ] Validates that the substitute product exists, has sufficient inventory, and is assignable to the order's store/branch
- [ ] Updates the order item with new product details, recalculates pricing, taxes, and promotions
- [ ] Reserves inventory for the substitute product and releases reservation for the original if applicable
- [ ] Posts ledger entries for any stock or financial movements
- [ ] Returns RFC7807 problem+json for invalid states, insufficient inventory, or authorization failures
- [ ] Includes audit events for the substitution action
- [ ] Handles soft deletes and referential integrity
- [ ] Integrates with state machines to ensure legal transitions for order items
- [ ] Add unit and integration tests covering success, failure, and edge cases (e.g., out-of-stock substitute)
- [ ] Document the endpoint in API specs with request/response examples

## Technical Requirements

- Implement in Laravel: Define route in api.php, create controller method (e.g., OrderItemController@substitute)
- Use request validation with FormRequest class for inputs like new_product_id, quantity, reason (optional)
- Apply middleware stack: auth (JWT/API key), RBAC checks, branch scope, idempotency, input sanitizer, domain guards for orders/reservations/promos
- Leverage Eloquent models for Order, OrderItem, Product, Inventory; use transactions for atomicity
- Integrate with state machines for order_item transitions; trigger events for ledger posting and notifications
- Handle errors with standardized responses (RFC7807); log with request-id
- Ensure UTC timestamps and PII masking if applicable
- Support caching/etag for order reads if performance critical
- Write tests using PHPUnit: Mock repositories, test authorization, validate business rules

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- RBAC: User must have permission to modify orders (e.g., 'orders.update' ability via role)
- Active user, email-verified, and 2FA if enabled
- Branch scope: Employee must be scoped to the order's assigned store/branch
- Audit the action in audit_event table

## Expected Request/Response Format Considerations

- **Request:** JSON body expected, e.g., {""new_product_id"": 123, ""quantity"": 1, ""reason"": ""Out of stock""}; validate required fields, product existence, quantity >0
- **Response:** On success, return 200 with updated order item JSON (include id, product details, price, status); on error, 4xx/5xx with problem+json (title, detail, type)
- Use content-negotiation for versioned API; limit JSON payload size
- Idempotency: Use key from header to prevent duplicate substitutions

## Relevant Business Logic

- Substitution only allowed in order states pending/confirmed; use state machine to validate/enforce transition
- Check inventory: Ensure batch availability for substitute, reserve units transactionally, adjust ledgers for any pricing differences
- Recalculate order totals, apply promotions/taxes, flag fraud if suspicious (e.g., high-value swap)
- If original item had reservations, consume/release appropriately; support per-unit items
- For multi-store: Verify substitute assignable to order's store; may trigger inter-store dispatch if needed
- Post accounting entries: Reverse original, post new for stock/financial impact; synchronize payment status if partial
- Emit events for webhooks/notifications (e.g., email customer about change)
- Comply with referential integrity: Update polymorphic relations like notes/attachments if tied to item"
138,order-item,Backorder Item,Mark item as backordered,api/orders/{id}/items/{item_id}/backorder,post,Employee,Implement Backorder Item API Endpoint for Orders,"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.
Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint allows marking an order item as backordered, updating its state in the order domain to handle inventory shortages. It integrates with order_item states, inventory reservations, and potentially triggers ledger entries for stock movements.

## API Specifications

- **Category:** order-item
- **Title:** Backorder Item
- **Description:** Mark item as backordered
- **Route:** api/orders/{id}/items/{item_id}/backorder
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint marks the specified order item as backordered and updates its state via state machine
- [ ] Validates that the order and item exist, and the item is in a valid state for backordering (e.g., pending or confirmed)
- [ ] Ensures authentication as an Employee with appropriate RBAC permissions
- [ ] Handles inventory implications, such as releasing reservations if applicable
- [ ] Returns RFC7807 problem+json for invalid states or permissions
- [ ] Logs audit_event for the backorder action
- [ ] Includes unit tests for success, validation errors, and authorization failures
- [ ] Integrates with middleware stack (auth, RBAC, branch scope, etc.)
- [ ] Supports idempotency if multiple calls are made

## Technical Requirements

- Implement in Laravel: Define route in api.php, create or extend OrderItemController with backorder method
- Use state machine for order_item transitions to ensure legal backorder state
- Input validation: No request body expected; validate order ID and item ID as UUIDs or integers
- Error handling: 404 for non-existent order/item, 403 for unauthorized, 422 for invalid state
- Business logic: Update order_item.backordered_at timestamp or flag; trigger inventory adjustment if stock is insufficient; post to accounting ledger if financial impact; notify via webhooks if configured
- Authentication/authorization: Require Employee auth (JWT/API key); RBAC check for 'order.update' permission or similar; apply branch scope to ensure access to the order's store/branch
- Expected request/response: Request: POST with no body (or optional notes); Response: 200 JSON with updated item details (e.g., {""id"": item_id, ""state"": ""backordered"", ""backordered_at"": ""UTC timestamp""}); Errors in problem+json format
- Observability: Add request-id, audit log entry, metrics for endpoint usage; use UTC for timestamps
- Testing: Cover state transitions, inventory sync, permissions; ensure soft deletes are respected"
139,order-item,Fulfill Item,Mark item fulfilled,api/orders/{id}/items/{item_id}/fulfill,post,Employee,Implement Fulfill Item API Endpoint for Order Items,"## Overview

This GitHub issue is for implementing the 'Fulfill Item' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment involves shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns include RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments handle intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting covers transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services include service/service_order with lifecycle and profitability. Integrations encompass carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity features user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance include audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint allows marking an order item as fulfilled, transitioning its state via the state machine, ensuring transactional stock movements and ledger updates.

## API Specifications

- **Category:** order-item
- **Title:** Fulfill Item
- **Description:** Mark item fulfilled
- **Route:** api/orders/{id}/items/{item_id}/fulfill
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST endpoint to mark an order item as fulfilled
- [ ] Validate that the order and item exist and are in a valid state for fulfillment (e.g., confirmed, not already fulfilled or cancelled)
- [ ] Use state machine to handle the transition to 'fulfilled' state, rejecting invalid transitions with RFC7807 problem+json
- [ ] Perform transactional stock deduction from inventory (batch-centric, with reservations/consumption)
- [ ] Update related entities: create/update shipment/shipment_item if applicable, post ledger entries for stock/financial movements
- [ ] Handle authentication and authorization for Employee role with necessary permissions (e.g., order fulfillment permissions)
- [ ] Add input validation for request body (if any parameters like quantity or notes)
- [ ] Implement error handling for cases like insufficient stock, invalid state, or authorization failure
- [ ] Write unit and integration tests covering success, failure, and edge cases (e.g., partial fulfillment if supported)
- [ ] Ensure audit_event logging for the fulfillment action
- [ ] Verify soft deletes and referential integrity are respected
- [ ] Test with middleware: auth (JWT/session/API key), RBAC & permission checks, branch scope, idempotency, input sanitizer, domain guards
- [ ] Confirm data in UTC, PII masking if applicable, and cache headers

## Technical Requirements

- Use Laravel framework: Create controller method in OrdersController or dedicated OrderItemController
- Define route in api.php with proper versioning and content-negotiation
- Implement input validation using Form Requests or Validator facade (e.g., for optional fields like fulfillment notes or quantity)
- Integrate with Eloquent models for Order, OrderItem, Inventory, Shipment, LedgerEntry
- Use Laravel's state machine package or custom implementation to manage order_item state transitions
- Ensure transactional operations with DB::transaction() for stock movements and ledger posting
- Add proper error handling with exceptions mapped to RFC7807 JSON responses
- Include request logging with request-id and audit_event creation
- Support attachments/notes polymorphically if fulfillment includes notes
- Handle bulk scenarios if extending to multiple items (though endpoint is single-item)

## Authentication/Authorization Requirements

- Require Employee authentication via JWT, session, or API key
- Enforce active user, email-verified, and 2FA (TOTP MFA + backup codes) checks via middleware
- RBAC: Employee must have role/permission allowing order fulfillment (e.g., 'fulfill-order-item' permission linked to role via ability table)
- Branch scope: Ensure user can only fulfill items assigned to accessible stores/branches
- Optional tenancy if multi-tenant setup
- Throttling and idempotency keys to prevent duplicate fulfillments

## Expected Request/Response Format Considerations

- **Request:** POST with JSON body; minimal payload expected (e.g., {""notes"": ""optional fulfillment notes""}) or empty body. Use idempotency key in header if applicable.
- **Response:** On success, 200 OK with updated order_item JSON (including new state, fulfillment timestamp, related shipment_id if created). Include ETag for caching.
- **Errors:** 4xx/5xx with RFC7807 problem+json (e.g., {""type"": ""https://example.com/probs/invalid-state"", ""title"": ""Invalid transition"", ""status"": 422, ""detail"": ""Item already fulfilled""})
- Versioned API: Support content-negotiation (e.g., Accept: application/vnd.deshio.v1+json)
- Locale/tz handling: Parse from headers, store events in UTC

## Relevant Business Logic

- State transition: Only allow fulfillment from confirmed state; update to fulfilled, potentially triggering shipment creation or dispatch if not already assigned.
- Inventory impact: Deduct reserved stock from batch, create adjustment if partial; post ledger_entry for valuation.
- Order synchronization: If all items fulfilled, transition order to fulfilled; update payment_status if applicable.
- Fraud/override guards: Check fraud flag on order; allow price_override or promo impacts in calculations.
- Integrations: Trigger webhooks for fulfillment events; update carrier tracking if shipment created.
- Compliance: Log audit_event with user_id, request-id; mask PII in logs.
- Edge cases: Handle returns (RMA) post-fulfillment; exchanges; service_orders if applicable.
- Reporting: Ensure fulfillment data feeds into analytics (e.g., SLA, dispatch performance)."
140,payment,Create Payment Intent,Initialize payment,api/payments/intents,post,Employee,Implement Create Payment Intent API Endpoint,"## Overview

This GitHub issue is for implementing the 'Create Payment Intent' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD. Core domains include catalog (product/category/vendor with attributes, media, barcodes, pricing, promotions), stores/branches, customers + tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain covers order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment involves shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns handle RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments include intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting features transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services cover service/service_order with lifecycle and profitability. Integrations include carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint initializes a payment intent as part of the payment domain, supporting the intent→payment capture/void lifecycle and order.payment_status synchronization.

## API Specifications

- **Category:** payment
- **Title:** Create Payment Intent
- **Description:** Initialize payment
- **Route:** api/payments/intents
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST /api/payments/intents endpoint in Laravel
- [ ] Add input validation for request parameters (e.g., amount, currency, order_id, payment_method)
- [ ] Ensure authentication requires Employee role with appropriate RBAC permissions for payment creation
- [ ] Handle successful creation by returning a payment intent ID and status
- [ ] Implement error handling for invalid states, using RFC7807 problem+json for conflicts (e.g., order not in payable state)
- [ ] Integrate with state machine for payment intent initialization
- [ ] Write unit and integration tests covering happy path, validation errors, auth failures, and business rule violations
- [ ] Ensure idempotency support via request headers
- [ ] Add audit logging for the creation event
- [ ] Verify integration with order.payment_status synchronization
- [ ] Test middleware application (auth, RBAC, throttles, input sanitizer, domain guards for payment)

## Technical Requirements

- Use Laravel controller (e.g., PaymentIntentController) and define route in api.php with proper versioning and content-negotiation
- Implement input validation using Laravel's FormRequest or Validator, including rules for required fields like amount (numeric >0), currency (ISO 4217), order_id (exists in orders table), and optional fields like customer_id, payment_method
- Handle business logic: Verify order exists and is in a payable state (e.g., confirmed, not already paid/cancelled); create payment_intent record linked to order; trigger any ledger entry for intent creation; use state machine to validate/enforce transition
- Authentication/authorization: Require JWT/session/API key auth; enforce Employee user type; apply RBAC checks via permissions (e.g., 'create-payment-intent'); include branch scope if applicable; optional 2FA and email verification
- Expected request/response format: Request body as JSON (e.g., {""order_id"": 123, ""amount"": 100.00, ""currency"": ""USD"", ""payment_method"": ""card""}); Response: 201 Created with JSON body (e.g., {""id"": 456, ""status"": ""pending"", ""client_secret"": ""pi_xxx_secret_xxx"" for Stripe-like integration}); Errors: 4xx/5xx with problem+json (e.g., 422 for validation, 403 for auth, 409 for state conflict)
- Ensure transactional consistency for database operations (e.g., DB::transaction); support soft deletes and UTC timestamps
- Integrate with observability: Add request-id tracing, audit_event logging, and metrics for endpoint performance
- Consider integrations: Prepare for webhook deliveries on intent creation; align with carrier/payment provider accounts if external (e.g., Stripe/PayPal intent creation)
- Follow Deshio conventions: EAV for any custom payment attributes; polymorphic attachments if notes added; strict referential integrity with orders table"
141,payment,Capture Payment,Capture authorized amount,api/payments/{id}/capture,post,Employee,Implement Capture Payment API Endpoint (api/payments/{id}/capture),"## Overview

Deshio is a Laravel-based ERP system for retail/omni-channel operations, featuring approximately 290 REST APIs built over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes (fields/features), media (product images), barcodes, pricing (price overrides), and promotions. Additional entities encompass stores/branches, customers with tags/blacklists, batch-centric inventory supporting reservations, adjustments, cycle counts, valuation, and ledgers.

The order domain manages order/order_item states (pending → confirmed → fulfilled|cancelled), assignment to stores, notes/attachments, promotions, taxes, and fraud flags. Fulfillment handles shipments (shipment/shipment_item) and inter-store dispatches (dispatch + tracking, scan events, POD) with transactional stock movements. Returns are processed via RMA (return/return_item), including receive/restock/scrap, refunds, and exchanges (exchange_order).

Payments follow an intent → payment capture/void lifecycle, with refund lifecycles and order.payment_status synchronization. Accounting involves transaction headers + ledger_entry lines for all movements, supporting reversals, reconciliation, and exports. Services include service/service_order with lifecycle and profitability tracking.

Integrations cover carriers & accounts, waybills/rates/tracking, webhooks with deliveries, and notification templates (email/SMS). Security and identity features include user/role/permission with abilities (role ↔ perm) and user_role (multi-role), sessions, email verification, password reset, TOTP MFA + backup codes, and API keys.

Observability and compliance encompass audit_event, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, and cache headers.

Reporting/analytics provide insights into revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, and activity. State machines ensure legal transitions for orders, order items, dispatch, shipments, returns, payments, and cycle counts, with conflicts returning RFC7807 problem+json responses.

APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC with soft deletes for archival, EAV for attributes, polymorphic notes/attachments, and strict referential links across junctions. The design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This issue focuses on implementing the ""Capture Payment"" API endpoint, which captures the authorized amount for a payment intent, updating the payment status, synchronizing with the associated order, and posting ledger entries for accounting reconciliation.

## API Specifications

- **Category:** payment
- **Title:** Capture Payment
- **Description:** Capture authorized amount
- **Route:** api/payments/{id}/capture
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint successfully captures the full authorized amount for the specified payment ID
- [ ] Supports partial capture if an amount is provided in the request body
- [ ] Updates payment status to 'captured' and synchronizes order.payment_status
- [ ] Posts transaction headers and ledger_entry lines for the capture movement
- [ ] Handles void/capture conflicts via state machine, returning RFC7807 problem+json on invalid transitions
- [ ] Applies RBAC checks to ensure only authorized employees can capture payments
- [ ] Includes audit_event logging for the capture action
- [ ] Validates input (e.g., payment exists, is in authorized state, amount <= authorized)
- [ ] Returns appropriate success response with updated payment details
- [ ] Handles errors (e.g., payment not found, insufficient authorization) with problem+json
- [ ] Unit and integration tests cover success, partial capture, invalid states, and authorization failures
- [ ] Endpoint respects middleware (auth, RBAC, throttles, idempotency, etc.)

## Technical Requirements

- Implement in a Laravel controller (e.g., PaymentController) with route defined in routes/api.php
- Use the Payment model to retrieve and update the payment by ID
- Integrate with payment intent state machine for transition validation (authorized → captured)
- Leverage Eloquent relationships to sync with Order model and update payment_status
- Post accounting entries using Transaction and LedgerEntry models, ensuring UTC timestamps and soft deletes compatibility
- Apply domain guards for payment-related operations
- Use Laravel's validation for request input (e.g., optional 'amount' field as numeric <= authorized_amount)
- Handle exceptions with custom error responses in RFC7807 format (problem+json)
- Ensure idempotency via request ID or similar to prevent duplicate captures
- Add comprehensive logging with request-id and audit_event for observability
- Support versioned API responses with content-negotiation

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- Enforce active user, email-verified, and 2FA checks via middleware
- RBAC: User must have a role with permission to 'capture payments' (e.g., via ability role ↔ perm mapping)
- Branch scope: Capture limited to payments associated with the user's scoped branches/stores
- Optional tenancy isolation if multi-tenant mode is enabled

## Expected Request/Response Format Considerations

- **Request:** POST to /api/payments/{id}/capture
  - Headers: Authorization (Bearer/JWT), Content-Type: application/json, X-Request-ID (for idempotency)
  - Body (optional): {""amount"": 100.00} – numeric value for partial capture; defaults to full authorized amount if omitted
  - Path param: {id} – UUID or integer ID of the payment

- **Response (Success - 200 OK):** JSON with updated payment object, including status: 'captured', captured_amount, and links to order/transaction
  - Example: {""data"": {""id"": ""uuid"", ""status"": ""captured"", ""captured_amount"": 100.00, ""order_id"": ""uuid""}}

- **Response (Error - e.g., 400/403/422):** RFC7807 problem+json
  - Example: {""title"": ""Invalid State"", ""detail"": ""Payment cannot be captured from current state"", ""type"": ""https://example.com/probs/state-invalid"", ""status"": 400}

- Validate MIME types and sanitize inputs; enforce JSON limits and CORS

## Relevant Business Logic

- Capture transitions payment from 'authorized' to 'captured' state via state machine; invalid transitions (e.g., already captured/voided) return errors
- If partial capture, update remaining authorized amount and allow subsequent captures up to original total
- Synchronize order.payment_status (e.g., to 'paid' if fully captured)
- Trigger ledger posting for financial movement, supporting reversals if needed
- Integrate with promotions/taxes for accurate amount calculation
- Handle fraud flags: Block capture if order has fraud flag set
- Ensure transactional consistency: Rollback on ledger post failure
- Notify via webhooks/email/SMS templates on successful capture
- Support refunds post-capture via separate endpoint, maintaining lifecycle integrity"
142,payment,Void Payment,Void an authorization,api/payments/{id}/void,post,Employee,Implement Void Payment API Endpoint (POST /api/payments/{id}/void),"## Overview

This GitHub issue is for implementing the 'Void Payment' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs built over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits.

Core entities include: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.

Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.

Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.

Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).

Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.

Services: service/service_order with lifecycle and profitability.

Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.

Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The 'Void Payment' endpoint specifically voids an authorization in the payment domain, updating the payment status, synchronizing with orders, and posting reversals to the accounting ledger.

## API Specifications

- **Category:** payment
- **Title:** Void Payment
- **Description:** Void an authorization
- **Route:** api/payments/{id}/void
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint voids a payment authorization only if it is in an eligible state (e.g., authorized but not captured)
- [ ] Updates payment status to 'voided' and synchronizes with associated order's payment_status
- [ ] Posts reversal entries to the accounting ledger (transaction header + ledger_entry lines)
- [ ] Handles state machine transitions for payments, rejecting invalid voids with RFC7807 problem+json errors
- [ ] Applies RBAC: Only authenticated employees with appropriate permissions can void payments
- [ ] Includes audit logging for the void action (audit_event)
- [ ] Supports idempotency to prevent duplicate voids
- [ ] Returns success response with updated payment details or 200 OK
- [ ] Validates input (payment ID exists and is voidable)
- [ ] Writes unit/integration tests covering success, invalid states, unauthorized access, and error scenarios
- [ ] Integrates with middleware stack (auth, RBAC, throttles, idempotency, input sanitizer, domain guards for payment)

## Technical Requirements

- Implement in Laravel: Define route in api.php, create or update PaymentsController with void method
- Use Eloquent models for Payment, Order, and Ledger entities; ensure soft deletes and UTC handling
- Leverage state machines for payment lifecycle (intent→authorized→voided/captured)
- Input validation: Ensure {id} is a valid UUID/integer; request body may be empty or include optional notes
- Error handling: Use RFC7807 for problems (e.g., 400 for invalid state, 403 for unauthorized, 404 for not found)
- Database transactions: Wrap void operation, ledger posting, and order sync in a transaction for consistency
- Observability: Generate request-id, log events, mask PII in logs, trigger audit_event
- Caching: Invalidate relevant caches (e.g., order payment status) post-void
- Testing: PHPUnit tests for controller, validation, state transitions, and edge cases like concurrent voids

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT/session/API key
- RBAC check: User must have role/permission allowing payment void (e.g., 'payments.void')
- Middleware: active user, email-verified, 2FA (if enabled), branch scope (if payment tied to branch)
- Multi-role support via user_role junction

## Expected Request/Response Format Considerations

- **Request:** POST to /api/payments/{id}/void; Body: Optional JSON { ""notes"": ""string"" } for void reason; Headers: Authorization, Content-Type: application/json, Idempotency-Key (optional)
- **Success Response (200 OK):** JSON { ""data"": { ""payment"": { ""id"": ""uuid"", ""status"": ""voided"", ""voided_at"": ""utc-timestamp"", ... } }, { ""message"": ""Payment voided successfully"" } }
- **Error Responses:** 400/422 for validation/state errors (RFC7807: { ""type"": ""uri"", ""title"": ""string"", ""status"": int, ""detail"": ""string"" }); 401 Unauthorized; 403 Forbidden; 404 Not Found
- Versioned: Use content-negotiation for API version; ETag for caching if applicable
- All responses in JSON; Dates in ISO 8601 UTC

## Relevant Business Logic

- Void only applies to authorized payments not yet captured; Attempting on captured/voided/refunded payments fails with state error
- Synchronize order.payment_status to 'voided' or trigger refund if partial; Update order totals if needed
- Accounting: Create reversal transaction header and ledger_entry lines negating the authorization amount; Ensure reconciliation compatibility
- Inventory/fulfillment impact: If void affects reservations, release them transactionally
- Notifications: Optionally trigger webhooks/email/SMS via notification templates for void events
- Compliance: Log for audits, mask sensitive payment data (PII masking); Support reversals in reporting (e.g., refund rates, revenue analytics)
- Conflicts: Use state machines to enforce legal transitions; Domain guards prevent invalid operations on fraud-flagged orders"
143,payment,List Payments,List payments by filters,api/payments,get,Admin,Implement List Payments API Endpoint (GET /api/payments),"## Overview

Deshio is a Laravel-based ERP system for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD that covers catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes (fields/features), media (product images), barcodes, pricing (price overrides), promotions; stores/branches; customers with tags/blacklists. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers.

The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to stores, notes/attachments, promotions, taxes, and fraud flags. Fulfillment covers shipments (shipment/shipment_item) and inter-store dispatches (dispatch + tracking, scan events, POD) with transactional stock movements. Returns handle RMAs (return/return_item), receiving/restocking/scrap, refunds, and exchanges (exchange_order).

Payments involve intent→payment capture/void lifecycles, refund lifecycles, and synchronization with order.payment_status. Accounting uses transaction headers + ledger_entry lines for all movements, including reversals and reconciliation/export. Services include service/service_order with lifecycles and profitability. Integrations cover carriers & accounts, waybills/rates/tracking, webhooks with deliveries, and notification templates (email/SMS).

Security & identity features user/role/permission with abilities (role↔perm) and user_role (multi-role), sessions, email verification, password reset, TOTP MFA + backup codes, and API keys. Observability & compliance include audit_event, logs, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, and cache headers.

Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, and activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC with soft deletes for archival, EAV for attributes, polymorphic notes/attachments, and strict referential links across junctions. The design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This issue is for implementing the 'List Payments' API endpoint in the payment category, which lists payments filtered by various criteria, aligning with the payments domain's intent→capture/void, refund lifecycles, and order synchronization.

## API Specifications

- **Route:** api/payments
- **Method:** get
- **Authentication:** Admin
- **Category:** payment

## Acceptance Criteria

- [ ] Implement the GET /api/payments endpoint to list payments with support for filters (e.g., by order ID, status, date range, customer, etc.)
- [ ] Ensure endpoint respects pagination, sorting, and search capabilities
- [ ] Add input validation for query parameters to prevent injection or invalid data
- [ ] Implement proper error handling, including RFC7807 problem+json for conflicts or invalid states
- [ ] Write unit and integration tests covering happy paths, edge cases, and authorization failures
- [ ] Verify synchronization with order.payment_status and ledger entries
- [ ] Ensure compliance with middleware stack, including RBAC checks for admin access
- [ ] Test for soft deletes, UTC handling, and PII masking in responses
- [ ] Document the endpoint in API specs with request/response examples

## Technical Requirements

- Use Laravel controller (e.g., PaymentController) and define route in api.php with appropriate middleware (auth, admin RBAC, throttles, etc.)
- Implement query builder or Eloquent for fetching payments, joining relevant entities like orders, customers, and ledgers
- Support filters via query parameters; use Laravel's validation and request classes
- Handle state machine legality for payment statuses (e.g., intent, captured, voided, refunded)
- Ensure transactional consistency for any related ledger postings or order updates
- Apply caching/etag if applicable, and include request-id for observability
- Use versioned content-negotiation and locale/tz awareness
- Integrate with audit_event logging for access

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT/session/API key
- Enforce RBAC: Users must have 'view payments' permission tied to their role(s)
- Apply branch scope if payments are store-specific
- Include checks for active user, email-verified, and 2FA if enabled
- Reject unauthorized access with 403 Forbidden and problem+json details

## Expected Request/Response Format Considerations

- **Request:** GET /api/payments?filter[order_id]=123&filter[status]=captured&filter[date_from]=2023-01-01&filter[date_to]=2023-12-31&page=1&per_page=20&sort=created_at:desc
  - Query params for filters, pagination (page, per_page), sorting
  - Validate inputs with Laravel rules (e.g., dates in ISO format, valid statuses)
- **Response:** 200 OK with JSON array of payments, each including id, order_id, amount, status, method, created_at, updated_at, and related data (e.g., customer summary, ledger summary)
  - Paginated structure: { data: [...], meta: { current_page, last_page, per_page, total } }
  - Use JSON:API or similar structure if standardized; include etag for caching
  - Errors: 400 for invalid params, 401/403 for auth issues, 422 for validation failures
  - Mask PII (e.g., partial customer info) per compliance

## Relevant Business Logic

- Payments link to orders; listing should reflect order.payment_status synchronization
- Support filtering by payment lifecycle stages (intent, capture, void, refund)
- Ensure idempotency for repeated requests and prevent replay attacks
- Trigger notifications (email/SMS) or webhooks if listing affects integrations
- Handle soft-deleted payments (exclude or optional include via filter)
- Align with accounting: Include aggregated ledger_entry impacts without exposing full details unless permitted
- Use state machines to validate filterable statuses; invalid combinations return errors
- Consider domain guards for payment-specific fraud checks or overrides"
144,shipment,Create Shipment,Create shipment for order,api/orders/{id}/shipments,post,Employee,Implement Create Shipment API Endpoint (POST /api/orders/{id}/shipments),"## Overview

This GitHub issue is for implementing the 'Create Shipment' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist.

Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain involves order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.

Fulfillment includes shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. This endpoint creates a shipment for a given order, enabling the fulfillment process by associating shipment items with order items, updating inventory via transactional movements, and driving state transitions via state machines for legality (e.g., order must be confirmed before shipment creation). Conflicts return RFC7807 problem+json.

Returns involve RMA (return/return_item), receive/restock/scrap, refunds, exchanges. Payments sync with order.payment_status. Accounting uses transaction headers + ledger_entry lines for movements, with reversals and reconciliation. Services, integrations (carriers, webhooks), security (RBAC, MFA), observability (audits, logs), middleware (auth, RBAC, throttles, idempotency), reporting/analytics, bulk operations, and data handling (UTC, soft deletes, EAV, polymorphic relations) all support deterministic admin assignment, safe reservations, and consistent ledger posting.

## API Specifications

- **Category:** shipment
- **Title:** Create Shipment
- **Description:** Create shipment for order
- **Route:** api/orders/{id}/shipments
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint creates a shipment associated with the specified order ID
- [ ] Validates that the order exists and is in a confirmed state (not pending, cancelled, or already fulfilled)
- [ ] Ensures the authenticated employee has RBAC permissions for shipment creation (e.g., role/permission checks via ability model)
- [ ] Handles shipment items linking to order items, with transactional stock movements (reservations/consumption) and ledger posting
- [ ] Updates order and order_item states to fulfilled via state machine, ensuring legal transitions
- [ ] Supports carrier integration (e.g., waybills, rates) if provided in request
- [ ] Returns RFC7807 problem+json for validation errors, unauthorized access, or state conflicts
- [ ] Implements middleware: auth (JWT/session/API key), active user, email-verified, 2FA, RBAC, branch scope, throttles, idempotency, input sanitizer
- [ ] Includes audit_event logging for the creation
- [ ] Add unit/integration tests for success, failure (e.g., invalid order state, insufficient stock), and edge cases (e.g., partial shipments)
- [ ] Verify soft deletes and referential integrity are maintained

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key.
- Employee must be active, email-verified, and pass 2FA if enabled.
- RBAC checks: User must have a role with permission for 'create shipment' action, scoped to the order's branch/store.
- Optional tenancy and domain guards (e.g., fraud checks) apply.
- Middleware enforces TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, and cache headers.

## Expected Request/Response Format Considerations

- **Request:** JSON payload with fields like: shipment_items (array of {order_item_id, quantity, batch_id}), carrier_id, tracking_number, notes, attachments (polymorphic). Use idempotency key for retries. Validate inputs with sanitizer and mime guards for uploads.
- **Response:** 201 Created with JSON representation of the created shipment (id, order_id, status, items, tracking, created_at in UTC). Include ETag for caching. Errors: 4xx/5xx with problem+json (title, detail, type per RFC7807).
- Data in UTC; support bulk if extended, but single shipment for now.

## Technical Requirements

- Implement in Laravel: Define route in api.php, create ShipmentController@store method.
- Use FormRequest for input validation (e.g., order existence, state, stock availability, branch scope).
- Integrate state machines for order/shipment transitions; ensure atomicity with DB transactions for stock movements and ledger entries.
- Handle inventory: Consume reservations, post to ledgers, trigger notifications/webhooks if applicable.
- Error handling: Domain guards for reservation/promo/override; replay defense if integrating providers.
- Observability: Log with request-id, audit_event; PII masking; health/metrics.
- Testing: PHPUnit for controller, validation, auth; feature tests for full flow including RBAC and state changes.
- Documentation: Add to API docs with examples; consider feature flags for rollout."
145,shipment,List Shipments,List order shipments,api/orders/{id}/shipments,get,Employee,Implement API: List Shipments for Order (GET /api/orders/{id}/shipments),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the 'List Shipments' endpoint. This endpoint retrieves shipments associated with a specific order, supporting the fulfillment domain which includes shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Core entities involved include orders with states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, and fraud flags. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. Data is stored in UTC, uses soft deletes for archival, EAV for attributes, polymorphic notes/attachments, and strict referential links. State machines drive legality of transitions for orders, shipments, and related entities; conflicts return RFC7807 problem+json. Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, and cache headers. Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, and activity. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

## API Specifications

- **Category:** shipment
- **Title:** List Shipments
- **Description:** List order shipments
- **Route:** api/orders/{id}/shipments
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint returns a list of shipments for the specified order ID
- [ ] Supports pagination, filtering, and sorting (e.g., by status, date, carrier)
- [ ] Handles cases where no shipments exist (empty list)
- [ ] Validates order ID existence and access permissions
- [ ] Returns appropriate HTTP status codes (200 for success, 404 for not found, 403 for unauthorized)
- [ ] Integrates with state machines to ensure only valid shipment states are listed
- [ ] Includes related data like shipment items, tracking info, and stock movements
- [ ] Add unit and integration tests covering happy path, edge cases, and errors
- [ ] Document the endpoint in API docs (e.g., OpenAPI/Swagger)
- [ ] Ensure compliance with observability: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag

## Technical Requirements

- Implement in Laravel controller (e.g., OrderShipmentController) with proper routes in api.php
- Use Eloquent models for shipment, shipment_item, order, and related entities (e.g., dispatch, tracking)
- Apply input validation for {id} parameter (UUID/integer) and any query params (e.g., ?page=1&status=shipped&limit=20)
- Leverage Laravel's pagination (LengthAwarePaginator) for responses
- Include proper error handling with RFC7807 problem+json for validation errors, not found, or conflicts
- Ensure transactional integrity for any stock movement queries
- Use scopes for branch-specific filtering if applicable
- Optimize queries with eager loading (e.g., with('items', 'tracking')) to avoid N+1 issues
- Support search/autosuggest if extended, but core is listing

## Authentication/Authorization Requirements

- Requires Employee authentication (JWT/session/API key)
- Enforce RBAC: user/role/permission with ability (role↔perm) and user_role (multi-role)
- Middleware: active user, email-verified, 2FA (TOTP MFA + backup codes), RBAC & permission checks, branch scope
- Employee must have permissions to view shipments for the order's store/branch
- Security & identity: sessions, email verification, password reset; API keys for integrations
- Optional tenancy isolation

## Expected Request/Response Format Considerations

- **Request:** GET /api/orders/{id}/shipments with optional query params (e.g., page, per_page, status, carrier_id, date_from, date_to)
- **Response:** JSON array of shipments, paginated:
  {
    ""data"": [
      {
        ""id"": ""uuid"",
        ""order_id"": ""uuid"",
        ""status"": ""pending|shipped|delivered|returned"",
        ""carrier"": { ""name"": ""string"", ""account_id"": ""uuid"" },
        ""tracking_number"": ""string"",
        ""ship_date"": ""2023-01-01T00:00:00Z"",
        ""items"": [ { ""product_id"": ""uuid"", ""quantity"": 1, ""batch_id"": ""uuid"" } ],
        ""stock_movements"": [ { ""type"": ""outbound"", ""ledger_entry_id"": ""uuid"" } ],
        ""notes"": [ polymorphic ],
        ""attachments"": [ polymorphic ]
      }
    ],
    ""meta"": { ""current_page"": 1, ""last_page"": 1, ""per_page"": 20, ""total"": 5 }
  }
- Use versioned content-negotiation (e.g., Accept: application/vnd.deshio.v1+json)
- Cache headers (ETag) for repeat requests
- Idempotency via request-id
- PII masking in logs/responses

## Relevant Business Logic

- Shipments tied to confirmed/fulfilled orders; list only accessible shipments based on order state
- Include inter-store dispatch if applicable (dispatch + tracking, scan events, POD)
- Transactional stock movements: reservations/consumption on shipment creation/fulfillment
- Integrate with returns (RMA: return/return_item, receive/restock/scrap, refunds, exchanges)
- Sync with payments (intent→payment capture/void; refund lifecycle; order.payment_status)
- Accounting: transaction headers + ledger_entry lines for movements; reversals; reconciliation/export
- Services: if shipment involves service_order, include lifecycle and profitability
- Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries
- Notifications: templates (email/SMS) on shipment events
- Fraud flag on order affects shipment visibility/actions
- State machine validations: ensure transitions (e.g., pending→shipped) are legal
- Soft deletes: exclude archived shipments unless specified
- EAV attributes for custom shipment fields
- Polymorphic notes/attachments
- Domain guards: order/payment/dispatch/reservation/promo/override/cycle-count/fraud checks"
146,shipment,Print Label,Generate/print labels,api/shipments/{id}/label,get,Employee,Implement GET /api/shipments/{id}/label - Print Shipment Label,"## Overview

This issue is for implementing the 'Print Label' API endpoint in the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD. The system covers catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.

Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.

Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.

Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).

Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.

Services: service/service_order with lifecycle and profitability.

Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.

Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint generates and prints labels for shipments, which are part of the fulfillment domain involving shipment/shipment_item, tracking, scan events, and POD, with transactional stock movements.

## API Specifications

- **Category:** shipment
- **Title:** Print Label
- **Description:** Generate/print labels
- **Route:** api/shipments/{id}/label
- **HTTP Method:** GET
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET endpoint to generate shipment labels
- [ ] Ensure the endpoint retrieves the shipment by ID and validates its existence and state
- [ ] Support label generation in a printable format (e.g., PDF or image)
- [ ] Include shipment details like shipment_item info, tracking, carrier, and addresses
- [ ] Add validation for shipment ID and employee permissions
- [ ] Handle errors with RFC7807 problem+json for invalid states or permissions
- [ ] Write unit and integration tests for success, failure, and edge cases (e.g., cancelled shipment)
- [ ] Ensure integration with state machines for shipment transitions
- [ ] Verify audit logging for label generation events
- [ ] Test middleware application including auth, RBAC, and branch scope

## Technical Requirements

- Use Laravel framework: Create a controller (e.g., ShipmentController) with a label method
- Define the route in api.php: Route::get('shipments/{id}/label', [ShipmentController::class, 'label'])->middleware(['auth:employee', 'rbac:shipment.view']);
- Implement input validation: Ensure {id} is a valid UUID or integer; check shipment exists and is in a printable state (e.g., confirmed or dispatched)
- Generate label: Use a library like TCPDF or Laravel Snappy for PDF generation, including shipment/shipment_item details, barcodes, and addresses
- Proper error handling: Return 404 for non-existent shipment, 403 for unauthorized access, 422 for invalid state, using RFC7807 format
- Observability: Log request-id, audit_event for label print, and metrics for endpoint usage
- Caching: Consider ETag for repeated requests if applicable
- Data integrity: Ensure UTC handling, soft deletes awareness, and referential integrity with related entities (e.g., orders, inventory)

## Authentication/Authorization Requirements

- Authentication: Requires Employee JWT/session or API key
- Authorization: RBAC check for permissions like 'shipment.view' or 'shipment.print'; multi-role support via user_role
- Additional checks: Active user, email-verified, 2FA if enabled; branch scope to ensure employee can access the shipment's store/branch
- Middleware stack: auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope

## Expected Request/Response Format Considerations

- **Request:** GET /api/shipments/{id}/label (no body; query params optional, e.g., ?format=pdf&size=4x6 for label specs)
- **Response:** Successful (200): Binary/PDF label file with Content-Type: application/pdf; include headers like Content-Disposition: attachment; filename=shipment-{id}-label.pdf
  Error responses: JSON with RFC7807 problem+json, e.g., { ""type"": ""https://problems.example.com/invalid-shipment-state"", ""title"": ""Shipment not printable"", ""status"": 422, ""detail"": ""Shipment is cancelled"" }
- Versioning: Support content-negotiation for API version (e.g., Accept: application/vnd.deshio.v1+json)
- Idempotency: GET is inherently idempotent; use request-id for logging

## Relevant Business Logic

- Shipment must be in a valid state (e.g., confirmed, dispatched) per state machine; prevent printing for pending, fulfilled, or cancelled
- Include details from related entities: order notes/attachments, shipment_item (with product barcodes, quantities), carrier tracking, POD if available
- Transactional: No stock movement on label print, but log audit_event; ensure consistency with ledger if integrated
- Integrations: Pull carrier info for waybills/rates; support attachments for custom label elements
- Compliance: PII masking if addresses contain sensitive data; soft deletes prevent access to archived shipments
- Edge cases: Handle inter-store dispatch labels differently; support bulk-like if extended, but single ID for now"
147,shipment,Track Shipment,Track shipment by id,api/shipments/{id}/tracking,get,Employee,Implement Track Shipment API Endpoint,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the 'Track Shipment' API endpoint. This endpoint allows tracking a shipment by its ID, providing visibility into shipment status, events, and logistics details.

Core entities in Deshio include: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.

Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.

Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.

Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).

Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.

Services: service/service_order with lifecycle and profitability.

Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.

Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint falls under the shipment category and supports fulfillment tracking with scan events and proof of delivery (POD).

## API Specifications

- **Category:** shipment
- **Title:** Track Shipment
- **Description:** Track shipment by id
- **Route:** api/shipments/{id}/tracking
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint returns shipment tracking details including status, scan events, and POD information for valid shipment IDs
- [ ] Endpoint requires Employee authentication and appropriate RBAC permissions for accessing shipment data
- [ ] Validate that the shipment ID exists and is accessible within the user's branch scope
- [ ] Handle cases where shipment is not found (return 404 with RFC7807 problem+json)
- [ ] Ensure response includes relevant business logic such as current state from state machine and associated dispatch/shipment_item data
- [ ] Implement caching/etag for performance if applicable, with proper cache headers
- [ ] Add audit_event logging for tracking requests
- [ ] Write unit and integration tests covering success, error, and authorization scenarios
- [ ] Ensure response data is in UTC and masks any PII as per compliance
- [ ] Verify integration with carriers for real-time tracking if shipment is dispatched

## Technical Requirements

- Use Laravel controller and routes to define the endpoint under the shipment category
- Implement input validation for the {id} path parameter (e.g., UUID or integer, ensure it's a valid shipment ID)
- Apply middleware stack: auth (JWT/session/API key for Employee), RBAC & permission checks (e.g., permission to view shipments), branch scope, throttles, idempotency if needed, input sanitizer
- Fetch shipment data from shipment and shipment_item models, including related dispatch, tracking events, and scan events
- Incorporate state machine to validate and include current shipment state (e.g., pending, in-transit, delivered)
- Handle errors with proper HTTP status codes and RFC7807 problem+json format for conflicts or invalid states
- Response format: JSON with shipment tracking details (e.g., status, timeline of events, estimated delivery, POD if available); consider including polymorphic attachments or notes if relevant
- Ensure transactional consistency for any related stock movements or ledger entries visibility in tracking
- Integrate with observability: log requests with request-id, add metrics for endpoint usage
- Support soft deletes: do not return tracking for soft-deleted shipments unless authorized
- Test for security: prevent unauthorized access to other branches' shipments, validate against fraud flags if applicable
- Consider webhooks for real-time updates, but this endpoint is polling-based GET"
148,shipment,Mark Delivered,Confirm delivery,api/shipments/{id}/delivered,post,Employee,Implement API: Mark Shipment Delivered (POST /api/shipments/{id}/delivered),"## Overview

Implement the 'Mark Delivered' API endpoint for the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations. This endpoint confirms the delivery of a shipment, updating its state and triggering related business processes such as inventory adjustments, ledger postings, and notifications. Deshio features ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors, inventory (batch-centric with reservations/adjustments), orders (with states like pending→confirmed→fulfilled), fulfillment (shipments/shipment_items with stock movements), returns (RMA), payments, accounting (transaction headers/ledger_entries), services, integrations (carriers/webhooks), security (RBAC/permissions/MFA), observability (audits/logs), and reporting/analytics. State machines ensure legal transitions for shipments, with conflicts returning RFC7807 problem+json. Data uses UTC, soft deletes, EAV attributes, polymorphic relations, and strict referential integrity. Middleware includes auth (JWT/session/API key), RBAC, branch scope, throttles, idempotency, sanitization, and guards for domains like shipments/reservations.

This endpoint falls under the shipment category, enabling deterministic fulfillment by confirming delivery, which may consume reservations, post ledger entries for stock/financial events, and integrate with carriers for tracking/POD (proof of delivery).

## API Specifications

- **Category:** shipment
- **Title:** Mark Delivered
- **Description:** Confirm delivery
- **Route:** api/shipments/{id}/delivered
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint responds to POST requests at /api/shipments/{id}/delivered with Employee authentication
- [ ] Validates shipment ID exists and is in a state eligible for delivery confirmation (e.g., 'in_transit' via state machine)
- [ ] Updates shipment status to 'delivered' and related shipment_items
- [ ] Triggers transactional stock movements (consume reservations, adjust inventory ledgers)
- [ ] Posts accounting entries (transaction header + ledger_entry lines) for delivery event
- [ ] Handles optional delivery details (e.g., POD upload, notes) if provided in request body
- [ ] Integrates with carrier tracking if applicable (update waybill status)
- [ ] Sends notifications/webhooks (e.g., delivery confirmation email/SMS via templates)
- [ ] Returns RFC7807 problem+json for invalid states/transitions or authorization failures
- [ ] Supports idempotency for repeated requests
- [ ] Includes audit_event logging for the delivery confirmation
- [ ] Unit/integration tests cover happy path, error cases (invalid ID/state/permissions), and edge cases (e.g., partial deliveries)
- [ ] Documentation updated with OpenAPI spec, including request/response examples
- [ ] Endpoint adheres to middleware stack: RequestId, auth, RBAC, branch scope, input sanitizer, domain guards (shipment/reservation)

## Technical Requirements

- Implement in Laravel: Add route to api.php, create/update ShipmentController with delivered() method
- Use Eloquent models for Shipment/ShipmentItem, with state machine (e.g., via laravel-statable or custom) to validate/enforce transition to 'delivered'
- Input validation: Request factory for optional body (e.g., {'notes': string, 'pod_attachment_id': uuid}), shipment ID as route param (UUID/int)
- Error handling: 404 for non-existent shipment, 403 for unauthorized (non-Employee or insufficient permissions), 422 for invalid state/body, 409 for idempotency conflicts
- Database transactions: Wrap state update, inventory adjustments (reservations consumption), ledger postings, and audit logging in a DB transaction for consistency
- Queueable jobs for heavy ops: e.g., Queue::push for notifications/webhooks/integrations to avoid blocking
- Caching/ETag: Invalidate relevant caches (e.g., order status, inventory levels) post-delivery
- Soft deletes: Respect soft-deleted shipments (prevent actions on deleted)
- Timezone/UTC: All timestamps in UTC, respect locale/tz middleware
- Bulk/related ops: If shipment has multiple items, process all; link to parent order for status sync (e.g., order to 'fulfilled')
- Feature flags: Optional toggle for advanced delivery features (e.g., signature required)
- Testing: PHPUnit tests for controller/service, including mocks for state machine, inventory service, ledger poster; coverage >90%

## Authentication/Authorization Requirements

- Requires Employee authentication (JWT/session/API key via auth middleware)
- Active user check, email-verified, optional 2FA (TOTP/backup codes)
- RBAC: User must have role/permission allowing shipment delivery (e.g., 'fulfill-shipments' ability via role↔perm junction)
- Branch scope: Employee scoped to relevant store/branch for the shipment
- Optional tenancy if multi-tenant setup
- API keys for integrations, with replay defense for webhooks

## Expected Request/Response Format Considerations

- **Request:** JSON body optional (e.g., {""notes"": ""Delivered to customer"", ""pod_media_id"": ""uuid""}); supports attachments polymorphic
- **Response:** 200 OK on success: {""data"": {""shipment"": {id, status: 'delivered', delivered_at: timestamp, ...}}, ""message"": ""Delivery confirmed""}
- **Errors:** 4xx/5xx with problem+json: e.g., {""title"": ""Invalid State"", ""detail"": ""Shipment not in transit"", ""status"": 422, ""type"": ""/errors/shipment-invalid-transition""}
- Content-negotiation: JSON only, versioned (e.g., /v1/), ETag for caching
- Limits: JSON size limits, throttles per user/IP

## Relevant Business Logic

- State machine: Only allow 'delivered' transition from valid prior states (e.g., 'out_for_delivery'); revert on failure
- Inventory: On delivery, consume reservations, adjust batch stock (per-unit optional), post to inventory ledger; handle inter-store dispatches if applicable
- Order sync: Update parent order/order_items to 'fulfilled', clear fraud flags if resolved, apply promos/taxes finalization
- Accounting: Create transaction header for delivery, add ledger_entry lines for stock valuation movements; support reversals if later returned
- Fulfillment integrations: Update carrier tracking, generate POD events, dispatch webhooks (e.g., order.fulfilled)
- Returns enablement: Set eligibility for RMA post-delivery (e.g., within window)
- Observability: Log audit_event with request-id, mask PII; metrics for delivery SLA/performance
- Conflicts: If stock insufficient or concurrent updates, rollback and error; ensure deterministic assignment
- Promotions/Pricing: Finalize any delivery-specific overrides or promo impacts on reporting
- Reporting: Update analytics (e.g., units delivered, dispatch performance, inventory aging)"
149,return,Create RMA,Initiate return request (RMA),api/returns,post,Employee,Implement Create RMA API Endpoint (POST /api/returns),"## Context about Deshio ERP

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.
Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

## Overview

The Create RMA endpoint initiates a return request (RMA) in the Deshio ERP system. This is part of the returns domain, handling RMA (return/return_item), receive/restock/scrap, refunds, and exchanges (exchange_order). It supports the overall ERP functionality for retail/omni-channel operations, ensuring proper state transitions via state machines and integration with inventory, orders, payments, and accounting.

## API Specifications

- **Category:** return
- **Title:** Create RMA
- **Description:** Initiate return request (RMA)
- **Route:** api/returns
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST /api/returns endpoint in Laravel controller
- [ ] Validate input data for creating an RMA, including order eligibility and return items
- [ ] Ensure authentication and authorization for Employee users with appropriate RBAC permissions
- [ ] Handle successful RMA creation with initial state (e.g., pending) and return the created resource
- [ ] Implement error handling for invalid requests, ineligible orders, or conflicts using RFC7807 problem+json format
- [ ] Integrate with state machines for return transitions and ensure referential integrity with orders/inventory
- [ ] Add unit and integration tests covering happy path, validation errors, authorization failures, and edge cases
- [ ] Document the endpoint in API specs, including request/response examples
- [ ] Verify middleware application (e.g., auth, RBAC, branch scope, input sanitizer)
- [ ] Ensure audit logging for RMA creation events
- [ ] Test idempotency for duplicate requests

## Technical Requirements

- Develop in Laravel framework: Define route in routes/api.php, create dedicated controller (e.g., ReturnController@store)
- Use Eloquent models for return and return_item entities, with relationships to order/order_item, customer, store/branch
- Implement input validation using FormRequest classes, covering required fields like order_id, return_items (with quantities, reasons), customer details, and optional notes/attachments
- Handle soft deletes and UTC timestamps for all entities
- Integrate with polymorphic notes/attachments if applicable
- Ensure transactional operations for creating return and related ledger entries (if initial posting required)
- Apply domain guards for returns, reservations, and fraud checks
- Use queues for any asynchronous notifications (e.g., email/SMS via templates)
- Support bulk creation if multiple items, with EAV for custom return attributes
- Include caching/etag headers and request-id tracing
- Write tests using PHPUnit, covering API responses, database state, and state machine transitions

## Authentication/Authorization Requirements

- Authentication: Required for Employee users via JWT, session, or API key middleware
- Authorization: RBAC checks via user/role/permission; Employee must have permissions for return creation (e.g., 'return.create' ability)
- Additional: Active user validation, email-verified, optional 2FA/TOTP, branch scope to ensure access to relevant store/branch
- Multi-role support via user_role junction; enforce branch-specific scoping for returns tied to orders

## Expected Request/Response Format Considerations

- **Request Format:** JSON body with idempotency key (optional). Expected fields: order_id (required, validated for fulfilled state and return window), return_items array (product_id, quantity, reason_code, condition), customer_id (optional, infer from order), store_id (for restock branch), notes (polymorphic), attachments (file uploads with mime guard). Use versioned content-negotiation and locale/tz headers.
- **Response Format:** JSON (201 Created) with created RMA object: id, order_id, status (pending), return_items array, timestamps, links (self, order). Include ETag for caching. Errors: 4xx/5xx with RFC7807 problem+json (title, detail, type, status).
- Considerations: Sanitize inputs, limit JSON size, support search/autosuggest for reasons/products, handle PII masking in logs.

## Relevant Business Logic

- Validate order eligibility: Must be confirmed/fulfilled, within return policy window, no fraud flag, items not already returned
- Create return entity in initial state (pending) via state machine; transition only on legal actions (e.g., receive/restock/scrap)
- For return_items: Ensure quantities <= ordered/shipped, support batch-centric inventory reservations if applicable
- Trigger ledger entries for potential reversals (stock movements on receive/restock, financial on refund/exchange)
- Integrate with payments for refund lifecycle sync and order.payment_status updates
- Support exchanges by linking to new exchange_order if specified
- Handle attachments/notes polymorphically; audit_event for creation
- Conflicts (e.g., insufficient stock for restock) return problem+json; ensure deterministic assignment to store/branch
- Post-creation: Potential webhooks for notifications, queue for profitability calculations if service-related
- Comply with observability: Log events, metrics for return rates, SLA on processing"
150,return,List RMAs,List return requests,api/returns,get,Employee,Implement List RMAs API Endpoint (GET /api/returns),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the 'List RMAs' API endpoint. This endpoint allows employees to list return requests (RMAs) in the return domain. Core entities include returns with RMA (return/return_item), supporting receive/restock/scrap, refunds, and exchanges (exchange_order). Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. Order domain involves states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, and fraud flags. Fulfillment includes shipments and inter-store dispatch with transactional stock movements. Payments sync with order.payment_status. Accounting uses transaction headers + ledger_entry lines for all movements. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential links. State machines drive legality of transitions, with conflicts returning RFC7807 problem+json. Middleware includes auth (JWT/session/API key), RBAC & permission checks, branch scope, throttles, idempotency, input sanitizer, and more. Reporting covers return/refund rates.

## API Specifications

- **Category:** return
- **Title:** List RMAs
- **Description:** List return requests
- **Route:** api/returns
- **HTTP Method:** GET
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint returns a paginated list of RMAs with relevant fields (e.g., id, status, order_id, customer_id, created_at, items summary)
- [ ] Supports query parameters for filtering (e.g., by status, date range, store/branch, customer), sorting, and pagination (e.g., ?page=1&per_page=20&status=pending&store_id=1)
- [ ] Handles authorization: Only authenticated employees with appropriate RBAC permissions (e.g., view_returns) can access
- [ ] Returns 200 OK with JSON array on success; 401 Unauthorized if not authenticated; 403 Forbidden if unauthorized; 400 Bad Request for invalid params
- [ ] Integrates with state machines to ensure only valid RMA states are listed
- [ ] Includes soft deletes handling (list only non-deleted RMAs)
- [ ] Supports search/autosuggest if applicable (e.g., by order number or customer)
- [ ] Write unit/integration tests covering happy path, edge cases (empty list, invalid filters), auth failures, and error responses in RFC7807 format
- [ ] Add API documentation (e.g., OpenAPI/Swagger annotations)
- [ ] Ensure performance: Use eager loading for relations (e.g., return_items, order, customer) to avoid N+1 queries

## Technical Requirements

- Implement in Laravel: Define route in api.php, create/use ReturnController with index method
- Use Eloquent models: Return (with hasMany ReturnItem, belongsTo Order, belongsTo Customer, etc.), apply scopes for branch scoping and soft deletes
- Input validation: Use FormRequest or Validator for query params (e.g., integer for ids, date formats, enum for statuses)
- Pagination: Use LengthAwarePaginator or simplePaginate for efficient querying
- Error handling: Throw/customize exceptions for auth, validation, and return Problem+json responses
- Middleware: Apply auth (sanctum/jwt), RBAC checks (via policies/gates), branch scope, throttles, idempotency if needed, input sanitizer
- Database: Query from returns table, join/filter based on ERD (normalized relations across junctions)
- Observability: Add audit_event logging for access, request-id tracing, PII masking for customer data
- Caching: Consider etag/cache headers for repeated lists if applicable
- Bulk/export: While this is list, ensure compatibility with bulk export patterns

## Authentication/Authorization Requirements

- Requires Employee authentication (JWT/session/API key)
- RBAC: User must have role/permission allowing view_returns (via ability role↔perm and user_role multi-role)
- Additional checks: Active user, email-verified, 2FA if enabled, branch scope (filter RMAs to user's branches/stores)
- Security: TLS/HSTS, CORS, JSON limits, versioned content-negotiation, locale/tz handling

## Expected Request/Response Format Considerations

- **Request:** GET /api/returns?filters (e.g., status=pending&from_date=2023-01-01&to_date=2023-12-31&store_id=1&page=1&per_page=50&sort=created_at.desc)
  - No body required
  - Validate params: status enum (e.g., pending, received, restocked, scrapped, refunded, exchanged), dates in YYYY-MM-DD, ids as integers
- **Response (200 OK):** JSON object with 'data' array of RMA objects, each including id, order_id, customer_id (masked PII), status, total_amount, created_at, updated_at, relations summary (e.g., items_count, shipment_id if linked); 'meta' for pagination (current_page, last_page, etc.); Use resources/ transformers for serialization
- **Error Responses:** 4xx/5xx with RFC7807 problem+json {type, title, status, detail, instance}
- Content-Type: application/json; Support ETag for caching

## Relevant Business Logic

- RMAs tied to orders: List only RMAs for confirmed/fulfilled orders, respecting order states and fraud flags
- Inventory impact: RMAs involve receive/restock/scrap with transactional stock movements and ledger postings
- Refunds/Exchanges: Filterable by linked payment_status, refunds lifecycle, or exchange_order creation
- State Machines: Ensure listed RMAs reflect valid transitions (e.g., pending→received→restocked|scrapped); Illegal states not exposed
- Branch/Store Assignment: Filter to user's scoped branches; Support multi-store visibility based on permissions
- Promotions/Taxes: Include promo impacts or tax reversals in RMA details if relevant
- Attachments/Notes: Optionally include polymorphic notes/attachments summary
- Compliance: Audit access events; Handle soft deletes for archival; UTC timestamps
- Integrations: Potential webhooks for RMA status changes; Notification templates for returns"
151,return,Get RMA,Get return details,api/returns/{id},get,Employee,Implement GET /api/returns/{id} for RMA Details,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the 'Get RMA' API endpoint. This endpoint retrieves detailed information for a specific Return Merchandise Authorization (RMA) in the returns domain. Core entities include returns/return_items with states for receive/restock/scrap, refunds, and exchanges (exchange_order). The system supports RMA lifecycle integrated with orders, inventory (batch-centric with reservations/adjustments), fulfillment (shipments/dispatches), payments (refunds/payment_status sync), and accounting (transaction headers/ledger_entries for movements/reversals). Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential links. State machines ensure legal transitions, returning RFC7807 problem+json for conflicts. Middleware includes TLS/HSTS, CORS, auth (JWT/session/API key), RBAC, branch scope, throttles, idempotency, input sanitizer, and domain guards.

## API Specifications

- **Category:** return
- **Title:** Get RMA
- **Description:** Get return details
- **Route:** api/returns/{id}
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint returns RMA details including return/return_item data, states (receive/restock/scrap), associated order/order_items, refunds/exchanges, notes/attachments, and linked inventory movements
- [ ] Handles valid RMA ID retrieval with proper serialization (JSON, versioned content-negotiation, etag caching)
- [ ] Returns 404 for non-existent ID, 403 for unauthorized access, and RFC7807 errors for conflicts (e.g., invalid state transitions)
- [ ] Integrates with RBAC: Employee must have permissions for returns domain, scoped to branch/store
- [ ] Includes audit_event logging for access, request-id tracing, and PII masking if applicable
- [ ] Supports search/autosuggest if extended, but core is single ID fetch
- [ ] Write unit/integration tests covering happy path, auth failures, invalid inputs, and edge cases (soft-deleted RMAs, concurrent access)
- [ ] Endpoint is throttled, idempotent, and guarded against replay/injection

## Technical Requirements

- Use Laravel controller (e.g., ReturnController@show) and register route in api.php with middleware stack: auth (JWT/session/API key), active user, email-verified, 2FA (if enabled), RBAC/permission checks (ability for 'view returns'), branch scope, throttles, idempotency, input sanitizer, domain guards (return/reservation/fraud)
- Implement input validation: {id} as UUID/integer, exists in returns table (soft delete aware)
- Fetch RMA with eager loading: return items, order, customer (tags/blacklist), payments (refunds), shipments/dispatches (tracking/POD), inventory ledgers (valuations/adjustments/cycle counts), promotions/taxes applied
- Response format: JSON with standard structure (data: {id, state, created_at (UTC), order_id, customer_id, items: [...], totals: {refund_amount, restock_qty}, attachments: [...], notes: [...], audit_events: [...] }), include links for related resources (order, shipment), meta for pagination if nested lists
- Error handling: Use Laravel exceptions, transform to problem+json for validation/state errors; log with request-id
- Ensure deterministic behavior: Safe reservation/consumption checks, consistent ledger posting on events; integrate with state machines for RMA transitions
- Observability: Health/metrics, queues for async (e.g., notifications), caching/etag for repeated fetches; support bulk export/reindex if scaled
- Security: TLS/HSTS, CORS, JSON limits, upload mime guard (if attachments fetched), provider signatures if webhooks involved
- Reporting tie-in: Enable analytics for return/refund rates, SLA on RMAs

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- RBAC: User must have role/permission for viewing returns (e.g., 'view-rma' ability linked to role), multi-role support via user_role
- Scope to branch/store: Employee access limited to assigned branches; global admin bypass
- Additional: Email verification, TOTP MFA + backup codes enforced pre-access; sessions with expiration

## Expected Request/Response Format Considerations

- **Request:** GET /api/returns/{id} (path param {id}: valid RMA identifier, e.g., UUID); optional query params for includes (e.g., ?include=order,items,payments) to control eager loading; headers: Accept: application/vnd.deshio.v1+json, Authorization: Bearer <token>, X-Request-ID, X-Branch-ID (for scoping)
- **Response (200 OK):** {
  ""data"": {
    ""id"": ""uuid"",
    ""type"": ""return"",
    ""attributes"": {
      ""state"": ""received|restocked|scrapped|refunded|exchanged"",
      ""order_id"": ""uuid"",
      ""customer_id"": ""uuid"",
      ""branch_id"": ""uuid"",
      ""created_at"": ""2023-01-01T00:00:00Z"",
      ""updated_at"": ""2023-01-01T00:00:00Z"",
      ""fraud_flag"": false,
      ""notes"": [...],
      ""totals"": {""subtotal"": 100.00, ""tax"": 10.00, ""refund"": 90.00, ""restock_qty"": 5}
    },
    ""relationships"": {
      ""order"": {""data"": {""id"": ""uuid"", ""type"": ""order""}},
      ""items"": [{""id"": ""uuid"", ""type"": ""return_item"", ""attributes"": {""product_id"": ""uuid"", ""quantity"": 2, ""reason"": ""defective"", ""disposition"": ""restock""}}],
      ""payments"": [{""id"": ""uuid"", ""type"": ""refund"", ""attributes"": {""amount"": 90.00, ""status"": ""completed""}}],
      ""shipments"": [...],
      ""attachments"": [{""id"": ""uuid"", ""type"": ""attachment"", ""url"": ""/api/attachments/uuid""}]
    }
  },
  ""links"": {""self"": ""/api/returns/{id}"", ""order"": ""/api/orders/{order_id}""},
  ""meta"": {""etag"": ""hash"", ""request_id"": ""uuid""}
}
- **Error Responses:** 401 Unauthorized, 403 Forbidden (RBAC/scope fail), 404 Not Found, 422 Unprocessable (invalid id), with problem+json: {""type"": ""https://example.com/probs/invalid-id"", ""title"": ""Invalid RMA ID"", ""detail"": ""..."", ""status"": 404}
- Locale/TZ: Response timestamps in UTC; support locale/tz middleware for display if needed

## Relevant Business Logic

- RMA tied to confirmed/fulfilled orders; supports returns for partial/full items with reasons (e.g., defective, wrong item)
- Lifecycle: Create RMA → Receive items (scan events) → Disposition (restock to inventory, scrap/adjustment, exchange creates new order) → Refund (payment void/capture sync, ledger posting)
- Inventory impact: Transactional stock movements (reservations consumed, ledgers updated for valuation); inter-store dispatch if needed
- Promotions/Taxes: Prorate on return; fraud flag propagation from order
- Accounting: Post reversals on refund/scrap; reconcile with payments
- Integrations: Webhooks for RMA state changes (deliveries/notifications via email/SMS templates); carriers for return shipments
- Compliance: Audit all accesses/changes; feature flags for enabling exchanges; backups/restore safe for RMAs
- Analytics: Track return rates, promo impact on returns, inventory aging from scrapped items"
152,return,Approve RMA,Approve requested return,api/returns/{id}/approve,post,Employee,Implement API: Approve RMA for Returns (POST /api/returns/{id}/approve),"## Overview

This GitHub issue is for implementing the 'Approve RMA' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD that covers catalog, orders, inventory, logistics, payments, RBAC, and audits.

Core entities include: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.

Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.

Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.

Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).

Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.

Services: service/service_order with lifecycle and profitability.

Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.

Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The 'Approve RMA' endpoint approves a requested return (RMA), transitioning its state via the state machine, potentially triggering inventory restock, refund processes, or exchanges. It falls under the 'return' category and ensures compliance with business rules for returns (receive/restock/scrap, refunds, exchanges).

## API Specifications

- **Category:** return
- **Title:** Approve RMA
- **Description:** Approve requested return
- **Route:** api/returns/{id}/approve
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint responds with 200 OK on successful approval of a valid RMA
- [ ] Endpoint returns 404 if the RMA with the given {id} does not exist
- [ ] Endpoint returns 403 if the authenticated employee lacks permission to approve RMAs
- [ ] State machine validates and transitions the RMA state to 'approved' only if the current state allows it (e.g., from 'requested')
- [ ] Upon approval, trigger relevant business logic: initiate restock for return_items, queue refund if applicable, update order.payment_status, post ledger entries for financial movements
- [ ] Handle conflicts or invalid transitions by returning RFC7807 problem+json with details
- [ ] Audit event is logged for the approval action, including request-id and user details
- [ ] Soft delete or archival considerations are respected if the RMA was previously soft-deleted
- [ ] Endpoint supports idempotency to prevent duplicate approvals
- [ ] Integration tests cover success, failure, permission denial, and state machine edge cases
- [ ] Documentation updated in API specs with request/response examples
- [ ] Endpoint respects middleware: auth, RBAC, branch scope, throttles, input sanitizer

## Technical Requirements

- Implement in Laravel: Define route in api.php, create or update ReturnController with approve method
- Use resource controller pattern for returns
- Integrate with Eloquent models: Return and ReturnItem, with relationships to Order, OrderItem, Inventory batches
- Leverage state machine package (e.g., spatie/laravel-model-states) for RMA state transitions (requested → approved → received/restocked/scraped, etc.)
- Ensure transactional integrity: Use DB transactions for state change, inventory adjustments, ledger postings, and payment updates
- Handle polymorphic notes/attachments if added during approval
- Apply domain guards for returns, reservations, and fraud checks
- Use UTC for all timestamps; respect soft deletes with withTrashed() if needed
- Add request logging and PII masking for compliance
- Implement caching/etag if applicable for RMA retrieval
- Queue heavy operations like notifications (email/SMS) or webhooks for refund/return updates
- Support bulk operations if extending to multiple RMAs in future

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- RBAC check: Employee must have role/permission allowing 'approve' action on returns (e.g., ability: return.approve)
- Verify active user, email-verified, and 2FA if enabled
- Branch scope: Approval limited to RMAs assigned to the employee's branch/store
- Optional tenancy if multi-tenant setup
- Permission denial returns 403 with problem+json

## Expected Request/Response Format Considerations

- **Request:** POST to /api/returns/{id}/approve; Body optional (e.g., JSON with notes or approval reason: {""notes"": ""string"", ""restock"": true})
- Validate {id} as UUID or integer; sanitize inputs
- No query params expected; use versioned content-negotiation (e.g., Accept: application/vnd.deshio.v1+json)
- **Response:** 200 OK with updated RMA JSON (include id, state, return_items with restock status, related order summary); or 202 Accepted if async processing (e.g., refund queued)
- Error responses: 4xx/5xx as problem+json (RFC7807) with type, title, detail, instance (request-id)
- Use ETag for conditional requests if RMA updated concurrently
- Limit JSON payload size via middleware

## Relevant Business Logic

- Approval transitions RMA state via state machine; illegal transitions forbidden
- For each return_item: If approved, reserve inventory for restock or process scrap/exchange
- Sync with order: Update order state to 'partial_fulfilled' or 'returned', apply refunds via payment intent capture/void
- Post accounting: Create transaction header + ledger_entry for return value, reversals if needed
- Handle promotions/taxes: Reverse applied promos, recalculate taxes on refund
- Fraud flag: If order had fraud, require additional approval or block
- Integrations: Trigger carrier returns if shipped; send notifications via templates
- Analytics: Update return/refund rates, inventory aging on restock
- Ensure deterministic stock movements and ledger consistency on approval event"
153,return,Reject RMA,Reject return,api/returns/{id}/reject,post,Employee,Implement Reject RMA API Endpoint (POST /api/returns/{id}/reject),"## Overview

Implement the Reject RMA API endpoint for the Deshio ERP system. This endpoint allows authenticated employees to reject a return merchandise authorization (RMA) request, updating its state and triggering relevant business processes such as notifications, audits, and ledger entries. Deshio is a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.

Core entities include: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

## API Specifications

- **Category:** return
- **Title:** Reject RMA
- **Description:** Reject return
- **Route:** api/returns/{id}/reject
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint rejects RMA only if current state allows transition (e.g., pending or approved but not yet processed)
- [ ] Updates RMA state to 'rejected' via state machine
- [ ] Handles authorization for employees with appropriate RBAC permissions
- [ ] Triggers audit event logging for the rejection action
- [ ] Sends notification to customer via email/SMS template if configured
- [ ] Posts reversal ledger entries if partial processing occurred
- [ ] Returns updated RMA details or success status on rejection
- [ ] Returns RFC7807 problem+json for invalid states, unauthorized access, or other errors
- [ ] Includes unit and integration tests covering success, failure, and edge cases
- [ ] Endpoint is protected by middleware (auth, RBAC, branch scope, idempotency, etc.)
- [ ] Documentation updated for API reference

## Technical Requirements

- Implement in Laravel: Define route in api.php, create or extend ReturnController with rejectRma method
- Use Eloquent models for return/return_item; integrate with state machine for transition validation
- Input validation: Optional request body for rejection reason (string, max 500 chars); validate {id} as existing RMA
- Error handling: 404 for non-existent RMA, 403 for unauthorized, 422 for invalid state/transition, 409 for conflicts
- Database transactions for state update, ledger posting, and audit logging to ensure consistency
- Soft delete handling if applicable; UTC timestamps
- Queue notifications and heavy processes (e.g., emails) asynchronously
- Observability: Log request-id, audit_event for rejection; PII masking for customer data

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- RBAC check: User must have role/permission allowing RMA rejection (e.g., 'return.reject' ability)
- Active user, email-verified, 2FA if enabled; branch scope to ensure employee can access the RMA's store/branch
- Middleware chain: auth → active user → email-verified → 2FA → RBAC & permission checks → branch scope

## Expected Request/Response Format Considerations

- **Request:** POST /api/returns/{id}/reject
  Body (optional JSON): {""reason"": ""string""} – free-text reason for rejection
  Headers: Authorization, Content-Type: application/json, Accept: application/json (versioned)
- **Success Response:** 200 OK with JSON: {""data"": {updated RMA object including id, state: 'rejected', reason, updated_at}}, or 204 No Content
- **Error Response:** RFC7807 problem+json, e.g., 403 {""type"": ""https://example.com/probs/unauthorized"", ""title"": ""Forbidden"", ""detail"": ""Insufficient permissions""}
- Versioned content-negotiation; JSON limits; idempotency via key if provided

## Relevant Business Logic

- Validate RMA eligibility for rejection using state machine (e.g., only from 'pending' or 'approved' states; prevent if shipment received or refund initiated)
- On rejection: Cancel any reservations/holds on inventory; reverse partial refunds if applicable; synchronize order.payment_status
- Trigger polymorphic notes/attachments for rejection reason; update return_item states accordingly
- Ensure transactional stock movements if restock was pending; post accounting ledger_entry for reversal
- Fraud flag consideration: If RMA had fraud flag, log additional audit details
- Compliance: Maintain referential integrity; support exchanges by not allowing rejection if exchange_order is linked
- Integrations: Potential webhook delivery for RMA state change; notification via templates"
154,return,Receive Items,Mark returned items received,api/returns/{id}/receive,post,Employee,Implement API: Receive Returned Items (POST /api/returns/{id}/receive),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue focuses on implementing the 'Receive Items' API endpoint in the return category. Deshio handles core entities like product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment covers shipments, inter-store dispatch with tracking, scan events, POD, and transactional stock movements. Returns involve RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments include intent→payment capture/void, refund lifecycle, order.payment_status synchronization. Accounting features transaction headers + ledger_entry lines for movements, reversals, reconciliation/export. Services include service/service_order with lifecycle and profitability. Integrations cover carriers & accounts, waybills/rates/tracking; webhooks; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm), user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data stored in UTC; soft deletes; EAV for attributes; polymorphic notes/attachments; strict referential links. Design enables deterministic admin assignment, safe reservation/consumption, consistent ledger posting on stock/financial events.

This endpoint marks returned items as received, updating the return state, handling restock/scrap logic, triggering stock movements, ledger entries, and potential refunds/exchanges.

## API Specifications

- **Category:** return
- **Title:** Receive Items
- **Description:** Mark returned items received
- **Route:** api/returns/{id}/receive
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint handles POST requests to mark return items as received
- [ ] Validates return ID exists and is in a receivable state (e.g., pending receipt)
- [ ] Updates return/return_item states via state machine, ensuring valid transitions
- [ ] Processes item receipt: restock to inventory (batch-centric), scrap if applicable, or exchange
- [ ] Triggers transactional stock movements, reservations release, and ledger postings
- [ ] Handles associated refunds if full receipt, synchronizes payment status
- [ ] Records audit events, logs, and request-id for observability
- [ ] Returns RFC7807 problem+json for conflicts/invalid states
- [ ] Supports idempotency to prevent duplicate receipts
- [ ] Integrates with notifications (email/SMS) for receipt confirmation
- [ ] Includes unit/integration tests covering happy path, errors, and edge cases (e.g., partial receipt)
- [ ] Documentation updated with request/response examples

## Technical Requirements

- Implement in Laravel: Define route in api.php, create controller method (e.g., ReturnController@receive)
- Use Eloquent models for return/return_item, integrate with inventory batch logic
- Apply middleware stack: auth (JWT/session/API key), RBAC checks, branch scope, throttles, idempotency, input sanitizer, domain guards
- Leverage state machines for return transitions; enforce legality
- Handle soft deletes, UTC timestamps, polymorphic relations (notes/attachments)
- Ensure referential integrity across junctions (e.g., to orders, inventory, payments)
- Use queues for async tasks like notifications, ledger posting if heavy
- Add caching/etag where applicable; PII masking in logs
- Input validation with Laravel Validator; output as JSON with versioned content-negotiation
- Error handling: HTTP status codes, problem+json for business errors
- Testing: Feature tests for endpoint, unit tests for business logic

## Authentication/Authorization Requirements

- Requires Employee authentication (JWT/session/API key)
- RBAC: User must have role/permission for return receipt (e.g., 'receive-returns' ability)
- Active user, email-verified, optional 2FA
- Branch scope: Employee scoped to relevant store/branch for the return
- Permission checks via middleware; deny unauthorized with 403

## Expected Request/Response Format Considerations

- **Request:** JSON body with optional fields like { ""items"": [{ ""id"": 1, ""quantity_received"": 2, ""condition"": ""restock|scrap"" }], ""notes"": ""string"", ""attachments"": [] } for partial/complete receipt; {id} in route is return ID
- **Validation:** Required: return ID; Optional: item quantities (must <= expected), condition enum
- **Response:** 200 OK on success: { ""return"": { ""id"": 1, ""status"": ""received"", ""received_at"": ""UTC"", ""stock_adjustments"": [] } }; 201 for created receipt events; Errors: 400 (invalid input), 404 (not found), 409 (conflict/state invalid), 422 (validation), 403 (unauthorized)
- Use content-negotiation for JSON; include cache headers, request-id

## Relevant Business Logic

- Validate return state allows receipt (e.g., from 'returned' to 'received')
- For each return_item: Update quantity received, determine action (restock: add to inventory batch, release reservation; scrap: adjust inventory down, ledger loss; exchange: create exchange_order)
- Full receipt may trigger refund (payment void/capture reverse), update order status to 'returned'
- Post ledger entries for stock/financial movements; handle reversals if needed
- Integrate with cycle counts/inventory valuation post-receipt
- Fraud flag check on return; blacklist customer if applicable
- Transactional: All or nothing (DB transactions for consistency)
- Analytics: Update return rates, inventory aging metrics post-receipt"
155,return,Restock Items,Return items to inventory,api/returns/{id}/restock,post,Employee,Implement Restock Items API Endpoint for Returns,"## Overview

This GitHub issue is for implementing the 'Restock Items' API endpoint in the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD. The system covers catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist.

Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.

Fulfillment involves shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns are handled via RMA (return/return_item), including receive/restock/scrap, refunds, and exchanges (exchange_order).

Payments cover intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting uses transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.

Services include service/service_order with lifecycle and profitability. Integrations encompass carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The 'Restock Items' endpoint specifically allows returning items to inventory as part of the returns process, updating inventory batches, reservations, and posting to ledgers transactionally.

## API Specifications

- **Category:** return
- **Title:** Restock Items
- **Description:** Return items to inventory
- **Route:** api/returns/{id}/restock
- **HTTP Method:** POST
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST endpoint at api/returns/{id}/restock that restocks return items to inventory
- [ ] Ensure the endpoint authenticates and authorizes Employee users with appropriate RBAC permissions (e.g., permission to restock returns)
- [ ] Validate that the return ID exists, is in a valid state for restocking (e.g., received but not yet restocked/scraped), and belongs to the user's branch scope
- [ ] Handle restocking business logic: update inventory (batch-centric, reservations, adjustments), post ledger entries for stock movements, trigger state machine transitions for return/return_item, and handle any associated refunds/exchanges if applicable
- [ ] Support optional request body for partial restocking (e.g., quantities per return_item), with validation for positive integers not exceeding returned quantities
- [ ] Return success response with updated return details and inventory status; use RFC7807 problem+json for errors (e.g., invalid state, insufficient permissions, inventory conflicts)
- [ ] Integrate middleware stack: auth (JWT/session/API key), RBAC & permission checks, branch scope, input sanitizer, domain guards (order/reservation/promo/override/cycle-count/fraud), idempotency, throttles
- [ ] Ensure transactional consistency: rollback on failures in inventory updates, ledger postings, or state transitions; audit events for restock actions
- [ ] Add comprehensive tests: unit tests for controller logic, integration tests for full flow including state machines and ledgers, error scenarios, and edge cases (e.g., soft-deleted returns, batch expiry)
- [ ] Document the endpoint in API specs, including request/response examples, with considerations for UTC timestamps, EAV attributes, and polymorphic relations
- [ ] Verify compatibility with reporting/analytics (e.g., update return rates, inventory aging) and observability (logs, metrics, audit_event)

## Technical Requirements

- Develop in Laravel: Create a dedicated controller (e.g., ReturnController@restock) and register route in api.php with {id} parameter binding to Return model
- Use FormRequest for input validation: Require return ID, optional JSON body with return_item IDs and quantities; sanitize inputs, enforce MIME types if attachments involved
- Implement business logic in service classes (e.g., ReturnService, InventoryService) to handle restocking: Query return/return_item, validate state via state machine, perform atomic DB transactions for inventory adjustments (reservations/consumption), ledger_entry creation, and return state updates
- Authorization: Use Gates/Policies for Employee role/permission checks; enforce branch scope to prevent cross-branch restocking
- Error handling: Catch domain exceptions (e.g., InvalidStateTransition), return 4xx/5xx with problem+json; log errors with request-id
- Request format: Accept JSON body like {""return_items"": [{""id"": 1, ""quantity"": 5}, ...]}; use content-negotiation for versioned API
- Response format: 200 OK with JSON {""return"": {...}, ""restocked_items"": [...], ""inventory_updates"": {...}}; include ETag for caching, timestamps in UTC
- Testing: PHPUnit tests covering happy path, validations, authorizations, transactions; mock state machines, inventory ledgers; aim for 80%+ coverage
- Integration: Ensure hooks for notifications (email/SMS on restock), webhooks if configured, and queueing for heavy operations like ledger reconciliation
- Security: Apply all middleware; mask PII in logs; validate referential integrity across junctions (e.g., return to order_item to product)
- Observability: Emit audit_event for restock action; track metrics (e.g., restock success rate, processing time); use request-id for tracing"
156,return,Create Exchange,Create exchange order,api/returns/{id}/exchange,post,Employee,Implement Create Exchange API Endpoint for Returns,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue focuses on implementing the 'Create Exchange' API endpoint. Deshio handles core entities like product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment covers shipments and inter-store dispatch with tracking and stock movements. Returns involve RMA (return/return_item), receive/restock/scrap, refunds, and exchanges (exchange_order). This endpoint specifically creates an exchange order from an existing return, enabling exchanges as part of the return lifecycle. Payments sync with order.payment_status, accounting uses transaction headers + ledger_entry for movements, reversals, and reconciliation. Services include service orders, integrations with carriers, webhooks, notifications. Security features user/role/permission, sessions, MFA, API keys. Observability includes audits, logs, PII masking. Middleware enforces TLS, CORS, auth (JWT/session/API key), RBAC, etc. Reporting covers revenue, LTV, returns, inventory, etc. State machines ensure legal transitions for orders, returns, payments; conflicts return RFC7807 problem+json. APIs support bulk operations, search, attachments, etc. Data in UTC, soft deletes, EAV for attributes, polymorphic relations, strict referential integrity. Design ensures deterministic assignment, safe reservations, consistent ledger posting.

This implementation must align with these principles, particularly for returns and exchanges, ensuring transactional stock movements, ledger updates, and state machine compliance.

## API Specifications

- **Category:** return
- **Title:** Create Exchange
- **Description:** Create exchange order
- **Route:** api/returns/{id}/exchange
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST endpoint to create an exchange order from a given return ID
- [ ] Validate input data, including return existence, eligibility for exchange, and required fields like new order items, customer details
- [ ] Handle business logic for exchange creation, including stock reservations, ledger entries, and state transitions (e.g., return to exchange_order)
- [ ] Ensure proper error handling with RFC7807 problem+json for invalid states, insufficient stock, or authorization failures
- [ ] Add unit and integration tests covering success, failure, and edge cases (e.g., cancelled returns, out-of-stock items)
- [ ] Document request/response schemas in OpenAPI/Swagger
- [ ] Verify integration with related domains: inventory (reservations/adjustments), orders (new exchange_order creation), payments (if applicable), and accounting (ledger postings)
- [ ] Confirm middleware application: auth, RBAC (employee permissions), branch scope, input sanitization, idempotency
- [ ] Test for soft deletes, UTC handling, and referential integrity
- [ ] Ensure exchanges support notes/attachments, promos, taxes, and fraud checks as per order domain

## Technical Requirements

- Use Laravel framework: Define route in api.php, create a dedicated controller method (e.g., ReturnController@exchange)
- Implement input validation using Form Requests or Validator, covering return ID, exchange details (items, quantities, pricing overrides, store assignment)
- Integrate state machines for return and exchange transitions; prevent illegal states (e.g., already fulfilled return)
- Handle transactions for atomicity: Create exchange_order, update return status, reserve/consume inventory batches, post ledger entries
- Support polymorphic relations for notes/attachments on the new exchange order
- Use EAV for any custom attributes on exchanged products
- Apply domain guards for reservations, promos, overrides, and fraud
- Include audit_event logging for the exchange creation
- Optimize with caching/etag where applicable; use request-id for tracing
- Ensure PII masking in logs if customer data is involved

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- RBAC check: Employee must have permissions for return management and order creation (e.g., role→perm mapping for 'exchange-return')
- Active user, email-verified, 2FA if enabled
- Branch scope: Employee must be scoped to the return's branch/store
- Optional tenancy if multi-tenant setup is active

## Expected Request/Response Format Considerations

- **Request:** JSON body with {return_id} in path; body includes exchange details e.g., {""items"": [{product_id, quantity, price_override}], ""store_id"", ""notes"", ""promos"", ""customer_id""}. Validate against return's original items for exchange eligibility. Support attachments upload with mime guard.
- **Response:** 201 Created with exchange_order JSON (id, status: pending, items, totals, payment_status); include links for related resources (e.g., shipment, payment intent). Errors: 400/403/404/422 with problem+json (title, detail, type per RFC7807).
- Consider bulk exchanges if multiple items; use idempotency keys to prevent duplicates.
- All dates in UTC; use content-negotiation for versioned responses.

## Relevant Business Logic

- Exchanges create a new order (exchange_order) linked to the original return; update return status (e.g., to 'exchanged')
- Validate stock availability: Reserve batches for exchange items, handle per-unit if applicable; trigger adjustments if needed
- Apply promotions, taxes, pricing overrides from original order where possible; sync fraud flag
- If exchange involves different store, initiate inter-store dispatch
- Post ledger entries for any financial movements (e.g., refund partial, new payment intent)
- Support receive/restock/scrap for returned items separately from exchange
- Ensure determinism: Admin assignment for online exchanges; consistent posting on stock/financial events
- Conflicts (e.g., insufficient stock) halt process and return error; use state machines for legality
- Integrate with payments: Create intent for exchange total, sync status
- Trigger notifications (email/SMS) via templates; webhook for external systems if configured"
157,return,Close RMA,Close return request,api/returns/{id}/close,post,Employee,Implement Close RMA API Endpoint (POST /api/returns/{id}/close),"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This issue is for implementing the 'Close RMA' API endpoint, which closes a return request (RMA) in the returns domain. Closing an RMA updates its state via the state machine, potentially triggering restock/scrap, refunds, exchanges, ledger postings, and audit events. Ensure integration with related entities like orders, inventory, payments, and accounting.

## API Specifications

- **Category:** return
- **Title:** Close RMA
- **Description:** Close return request
- **Route:** api/returns/{id}/close
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST /api/returns/{id}/close endpoint in Laravel controller
- [ ] Validate the RMA ID exists and is in a closable state (e.g., received, processed) using state machine
- [ ] Handle closing logic: update RMA state to closed, trigger restock/scrap if applicable, process refunds/exchanges, post ledger entries for financial movements, and create audit events
- [ ] Ensure transactional consistency for stock movements, payments, and accounting updates
- [ ] Add input validation for the request (e.g., optional reason for closure)
- [ ] Implement proper error handling: return RFC7807 problem+json for invalid states, unauthorized access, or conflicts
- [ ] Write unit and integration tests covering success, failure (invalid ID, wrong state, auth failure), and edge cases (e.g., associated shipments, partial returns)
- [ ] Verify middleware application: auth (Employee role), RBAC permissions, branch scope, idempotency, input sanitizer
- [ ] Confirm response includes updated RMA details or success message, with ETag for caching
- [ ] Test integration with related domains: inventory (restock ledgers), payments (refund synchronization), orders (status updates)

## Technical Requirements

- Use Laravel framework: Create or update ReturnController with closeRma method, register route in api.php with {id} parameter binding to Return model
- Implement state machine transition for RMA (return/return_item) to 'closed' state, enforcing legality and handling conflicts
- Integrate with polymorphic notes/attachments for closure notes; soft deletes if archival needed
- Ensure UTC timestamps for all updates; use EAV for any custom closure attributes
- Add observability: log audit_event, request-id tracing, PII masking for customer data in returns
- Handle bulk aspects if closing multiple items; support search/autosuggest for RMA ID if needed
- Include queueing for notifications (email/SMS templates) on closure, e.g., customer refund confirmation
- For reporting: Update analytics for return/refund rates, SLA metrics on RMA closure times

## Authentication/Authorization Requirements

- Authentication: Requires Employee user via JWT/session/API key
- Authorization: RBAC check for 'return.close' permission (via user/role/permission and ability model); multi-role support; active user, email-verified, optional 2FA
- Branch scope: Employee must have access to the RMA's assigned store/branch
- Middleware chain: auth → active user → email-verified → 2FA → RBAC & permission checks → branch scope

## Expected Request/Response Format Considerations

- **Request:** POST with optional JSON body { ""reason"": ""string"", ""notes"": ""string"" } or empty; validate ID as UUID/int, sanitize inputs
- **Response:** 200 OK with JSON { ""data"": { ""id"": ""uuid"", ""state"": ""closed"", ""updated_at"": ""utc"" }, ""message"": ""RMA closed successfully"" }; 404 for not found, 403 for unauthorized, 422 for validation errors, 409 for state conflicts (RFC7807 format)
- Use versioned content-negotiation, JSON limits, locale/tz handling; cache headers with ETag
- Polymorphic attachments: Allow optional file upload for closure evidence, with mime guard

## Relevant Business Logic

- RMA closure finalizes return/return_item lifecycle: receive/restock/scrap items, trigger refunds (payment void/capture sync), handle exchanges (create exchange_order), reverse stock reservations/movements via ledgers
- Transactional: All-or-nothing for stock/financial events; post accounting transaction headers + ledger_entry lines; support reversals if needed
- Fraud/domain guards: Check fraud flag on original order; prevent closure if ongoing shipments/dispatches
- Integrations: If carrier-involved, update tracking/POD; webhook deliveries for external systems (e.g., payment gateways)
- State machine: Only allow close from valid prior states (e.g., 'received'); conflicts return problem+json with transition details
- Compliance: Audit all changes; PII masking in logs; ensure idempotency for retry-safe closures"
158,refund,Create Refund,Refund full/partial,api/refunds,post,Employee,Implement Create Refund API Endpoint (POST /api/refunds),"## Overview

This GitHub issue is for implementing the 'Create Refund' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs built over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain handles order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, and fraud flags. Fulfillment involves shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns include RMA (return/return_item), receive/restock/scrap, refunds, and exchanges (exchange_order). Payments manage intent→payment capture/void; refund lifecycle; and order.payment_status synchronization. Accounting uses transaction headers + ledger_entry lines for all movements, reversals, and reconciliation/export. Services cover service/service_order with lifecycle and profitability. Integrations include carriers & accounts, waybills/rates/tracking; webhooks with deliveries; and notification templates (email/SMS). Security & identity features user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance include audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plans encompass TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The 'Create Refund' endpoint allows creating full or partial refunds, integrating with the payments and returns domains to handle refund lifecycles, update order payment statuses, and ensure transactional consistency with accounting ledgers.

## API Specifications

- **Category:** refund
- **Title:** Create Refund
- **Description:** Refund full/partial
- **Route:** api/refunds
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint accepts POST requests to /api/refunds and creates a new refund record for full or partial amounts
- [ ] Validates input including order ID, refund amount, reason, and associated payment intent
- [ ] Integrates with state machines to ensure valid transitions for payments and orders (e.g., only refund confirmed/fulfilled orders)
- [ ] Handles partial refunds by updating order.payment_status and creating ledger entries for reversals
- [ ] Triggers notifications (email/SMS) via templates if configured
- [ ] Supports attachments/notes polymorphic to refund entity
- [ ] Applies RBAC checks for employee permissions on refunds
- [ ] Returns RFC7807 problem+json for validation errors, unauthorized access, or invalid state transitions
- [ ] Includes audit_event logging for the refund creation
- [ ] Ensures idempotency for duplicate requests using request-id
- [ ] Tests cover successful full/partial refunds, error cases (e.g., insufficient payment amount), and integration with returns/RMA
- [ ] Endpoint is secured with middleware: auth (JWT/session/API key), RBAC & permission checks, branch scope, throttles, input sanitizer, domain guards (payment/refund)
- [ ] Data handling: UTC timestamps, soft deletes if applicable, PII masking in logs

## Technical Requirements

- Implement in Laravel: Define route in api.php, create RefundController with store method
- Use Laravel validation for request inputs (e.g., required order_id, numeric amount <= capturable_amount)
- Integrate with Eloquent models for Refund, Order, Payment, and LedgerEntry; ensure strict referential integrity
- Leverage state machines for refund/payment transitions; handle conflicts with Problem Details (RFC7807)
- Post refund events to queues for asynchronous processing (e.g., carrier integrations, notifications)
- Add unit/integration tests using PHPUnit, covering happy paths, edge cases, and middleware
- Include API documentation in OpenAPI/Swagger format
- Ensure compatibility with caching/etag, versioned content-negotiation, and locale/tz middleware
- Handle bulk scenarios if extending to multiple refunds, but focus on single creation
- Use transactions for atomicity in stock/financial movements tied to refunds (e.g., restock on returns)

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- Employee must be active, email-verified, and pass 2FA if enabled
- RBAC: User must have role with permission for 'create refund' ability, scoped to relevant branch/store
- Middleware chain: auth → active user → email-verified → 2FA → RBAC & permission checks → branch scope
- Unauthorized requests return 401/403 with problem+json

## Expected Request/Response Format Considerations

- **Request:** JSON body, e.g., {""order_id"": 123, ""amount"": 50.00, ""reason"": ""Customer return"", ""payment_intent_id"": ""pi_abc"", ""metadata"": {}}
  - Validate: order_id exists and is refundable, amount > 0 and <= remaining capturable, reason required
  - Optional: attachments array for polymorphic uploads (mime-guarded)
- **Response:** 201 Created with JSON, e.g., {""id"": 456, ""order_id"": 123, ""amount"": 50.00, ""status"": ""processed"", ""refund_id"": ""re_abc"", ""created_at"": ""2023-01-01T00:00:00Z""}
  - Include etag for caching, request-id header
  - Errors: 400 for validation, 422 for unprocessable (e.g., invalid state), 409 for conflicts
- Content negotiation: application/json, versioned (e.g., /api/v1/refunds)
- Idempotency: Use POST with idempotency-key header to prevent duplicates

## Relevant Business Logic

- Refunds tie into payment lifecycle: Capture/void intents, synchronize order.payment_status (e.g., to 'partially_refunded')
- For returns/RMA: Link refund to return_item if associated, handle restock/scrap/exchange impacts on inventory ledgers
- Accounting: Create transaction header + ledger_entry for refund reversal; ensure reconciliation
- Promotions/Taxes: Prorate refunds for applied promos/taxes; update promo impact analytics
- Fraud: Check order fraud flag; may block refunds
- Inventory: If tied to return, trigger reservations/adjustments/cycle counts
- Observability: Log audit_event, mask PII (e.g., customer details), track refund rates in analytics
- State Machines: Enforce legal transitions (e.g., refund only post-capture); use domain guards for consistency
- Integrations: Webhook deliveries for refund events; optional carrier refunds if applicable
- Edge Cases: Full refund closes payment; partial allows multiple; handle currency/exchange rates if multi-currency"
159,refund,List Refunds,List refunds,api/refunds,get,Admin,Implement List Refunds API Endpoint (GET /api/refunds),"## Overview

This GitHub issue is for implementing the 'List Refunds' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs built over a normalized ERD. The system covers domains including catalog (products/categories/vendors with attributes, media, barcodes, pricing, promotions), stores/branches, customers (with tags/blacklist), inventory (batch-centric with reservations, adjustments, cycle counts, valuation, ledgers), orders (order/order_item states from pending to confirmed/fulfilled/cancelled, assignment to store, notes/attachments, promos, taxes, fraud flags), fulfillment (shipments/shipment_items, inter-store dispatch with tracking/scan events/POD, transactional stock movements), returns (RMA with return/return_items, receive/restock/scrap, refunds, exchanges via exchange_order), payments (intent to payment capture/void, refund lifecycle, order.payment_status sync), accounting (transaction headers + ledger_entries for movements, reversals, reconciliation/export), services (service/service_order lifecycle and profitability), integrations (carriers/accounts, waybills/rates/tracking, webhooks, notification templates for email/SMS), security/identity (user/role/permission with abilities, multi-role user_roles, sessions, email verification, password reset, TOTP MFA + backup codes, API keys), observability/compliance (audit_events, logs, request-id, PII masking, health/metrics, queues, caching/etag), middleware (TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth via JWT/session/API key, active user, email-verified, 2FA, RBAC/permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards for order/payment/dispatch/reservation/promo/override/cycle-count/fraud, upload mime guard, provider webhook signatures + replay defense, cache headers), reporting/analytics (revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity), state machines for transitions (orders, items, dispatch, shipments, returns, payments, cycle counts with RFC7807 problem+json for conflicts), bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, strict referential links. Design supports deterministic admin assignment, safe reservation/consumption, consistent ledger posting on stock/financial events.

The 'List Refunds' endpoint retrieves a list of refunds, which are part of the payments and returns domains. Refunds follow a lifecycle tied to RMAs (returns), order.payment_status synchronization, and accounting ledger entries for reversals. This endpoint enables admins to view refund records, potentially including details like associated orders, amounts, statuses, and timestamps.

## API Specifications

- **Category:** refund
- **Title:** List Refunds
- **Description:** List refunds
- **Route:** api/refunds
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint returns a paginated list of refunds with relevant fields (e.g., id, order_id, amount, status, created_at, updated_at)
- [ ] Supports query parameters for filtering/sorting (e.g., ?status=processed&order_id=123&per_page=50&page=1)
- [ ] Handles authentication and authorization correctly, restricting to admin users with appropriate RBAC permissions
- [ ] Includes proper error handling for invalid requests (e.g., 400 for bad params, 401/403 for auth issues, 500 for server errors) using RFC7807 problem+json
- [ ] Response includes metadata for pagination (e.g., total, per_page, current_page)
- [ ] Integrates with state machines to ensure only valid refund states are listed
- [ ] Logs audit events for endpoint access
- [ ] Applies middleware stack (e.g., auth, RBAC, throttles, request-id, input sanitizer)
- [ ] Supports search/autosuggest if applicable (e.g., by order reference)
- [ ] Unit and integration tests cover happy path, edge cases, and errors
- [ ] Documentation updated in API specs (e.g., OpenAPI/Swagger)
- [ ] Performance optimized (e.g., eager loading relations, indexing on filters)

## Technical Requirements

- Implement in Laravel: Define route in api.php, create RefundController with index() method
- Use Eloquent models for Refund entity, with relations to Order, Payment, RMA, LedgerEntry
- Input validation using Form Requests (e.g., validate filters like status in enum, order_id as UUID/int)
- Pagination via LengthAwarePaginator or simplePaginate for efficiency
- Error handling: Use exceptions mapped to JSON responses with problem+json format
- Database: Ensure queries use soft deletes (withTrashed() if needed), UTC timestamps
- Caching: Apply etag/cache headers if data is cacheable
- Observability: Generate request-id, log accesses, mask PII (e.g., customer details if included)
- Testing: PHPUnit tests for controller, including mocking auth/RBAC
- Integration: Ensure consistency with refund lifecycle (e.g., sync with order.payment_status, post ledger entries on creation)

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC check: User must have 'view refunds' permission via role/permission abilities
- Additional guards: Active user, email-verified, 2FA if enabled, branch scope if refunds are scoped
- Middleware: Apply auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope

## Expected Request/Response Format Considerations

- **Request:** GET /api/refunds?status=processed&order_id=123&from_date=2023-01-01&to_date=2023-12-31&per_page=20&page=2
  - Headers: Accept: application/json, Authorization: Bearer <token>, X-Request-ID
- **Response (200 OK):** JSON array of refunds, e.g., {
  ""data"": [
    {
      ""id"": 1,
      ""order_id"": 123,
      ""amount"": 50.00,
      ""currency"": ""USD"",
      ""status"": ""processed"",
      ""method"": ""credit_card"",
      ""created_at"": ""2023-10-01T12:00:00Z"",
      ""updated_at"": ""2023-10-01T12:05:00Z""
    }
  ],
  ""meta"": {
    ""current_page"": 2,
    ""per_page"": 20,
    ""total"": 100
  }
}
- **Error Response (e.g., 403):** {
  ""type"": ""https://tools.ietf.org/html/rfc7231#section-6.5.3"",
  ""title"": ""Forbidden"",
  ""status"": 403,
  ""detail"": ""Insufficient permissions""
}
- Versioned: Support content-negotiation (e.g., /api/v1/refunds)
- Locale/TZ: Respect Accept-Language and X-Timezone headers for formatting

## Relevant Business Logic

- Refunds are linked to RMAs/returns and payments; list should include only finalized refunds (e.g., captured/voided intents)
- State machine validation: Ensure listed refunds adhere to legal transitions (e.g., pending → processed → completed)
- Accounting sync: Refunds trigger ledger entries and order.payment_status updates
- Fraud/domain guards: Flag suspicious refunds (e.g., high amounts, rapid returns)
- Soft deletes: Exclude deleted refunds unless ?include_trashed=1 (admin only)
- Bulk considerations: Support export if ?export=csv param added
- Conflicts: Return problem+json for invalid filters or concurrent modifications
- Integrations: Potential webhooks for refund events, notifications via templates"
160,refund,Get Refund,Refund details,api/refunds/{id},get,Admin,Implement GET /api/refunds/{id} for Refund Details,"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This issue is for implementing the 'Get Refund' API endpoint, which retrieves detailed information about a specific refund in the Deshio ERP system. Refunds are part of the payments and returns domain, linked to order.payment_status synchronization and refund lifecycle.

## API Specifications

- **Category:** refund
- **Title:** Get Refund
- **Description:** Refund details
- **Route:** api/refunds/{id}
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint returns comprehensive refund details including associated order, payment status, and ledger entries
- [ ] Handles valid refund ID and returns 200 OK with JSON response
- [ ] Returns 404 Not Found for non-existent refund ID
- [ ] Applies proper RBAC checks for Admin users only
- [ ] Includes audit logging for the request
- [ ] Supports soft deletes by excluding archived refunds or handling appropriately
- [ ] Integrates with state machine to ensure refund state is valid
- [ ] Add unit and integration tests covering success, error cases, and authorization
- [ ] Documentation updated with OpenAPI spec for this endpoint
- [ ] Endpoint is throttled and includes idempotency if applicable

## Technical Requirements

- Implement in Laravel using a dedicated controller (e.g., RefundController) with route in api.php
- Use Eloquent model for Refund entity, including relationships to Order, Payment, Return (RMA), and LedgerEntry
- Apply middleware stack: auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks (admin role required), branch scope if applicable
- Input validation: Ensure {id} is a valid UUID or integer via route model binding
- Error handling: Use RFC7807 problem+json for conflicts, 4xx/5xx responses with proper codes
- Response serialization: Use API resources to format JSON, masking PII if needed, with ETag for caching
- Database: Query in UTC, respect soft deletes with withTrashed() if needed for admins
- Observability: Generate request-id, log audit_event, integrate with queues if async processing required
- Testing: PHPUnit tests for controller, feature tests for full flow, cover business logic like refund lifecycle sync

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC: User must have admin role/permission for refund access (ability: role↔perm, user_role multi-role)
- Additional checks: Active user, email-verified, 2FA if enabled
- Branch scope: Limit to user's assigned branches if multi-tenant
- Secure against unauthorized access with domain guards for payment/refund

## Expected Request/Response Format Considerations

- **Request:** GET /api/refunds/{id} (path param {id} as UUID/integer; no body; query params optional for includes/fields if expanding)
- **Response (200 OK):** JSON object with refund details, e.g., {
  ""data"": {
    ""id"": ""uuid"",
    ""order_id"": ""uuid"",
    ""amount"": 100.00,
    ""status"": ""processed"",
    ""created_at"": ""2023-01-01T00:00:00Z"",
    ""relationships"": {
      ""order"": { ... },
      ""payment"": { ... },
      ""ledger_entries"": [ ... ]
    }
  }
}
- **Error Responses:** 401 Unauthorized, 403 Forbidden (non-admin), 404 Not Found, 422 Unprocessable (invalid id)
- Content negotiation: JSON only, versioned (e.g., /api/v1/), with cache headers/ETag
- All timestamps in UTC ISO format

## Relevant Business Logic

- Refunds tie into payments (intent→payment capture/void; refund lifecycle) and returns (RMA return/return_item, refunds, exchanges)
- Sync with order.payment_status on retrieval
- Include ledger_entry lines for financial movements and reversals
- State machine validation: Ensure refund state allows retrieval (e.g., not in invalid transition)
- Handle associations: Link to order/order_item, shipment if applicable, and accounting transaction headers
- Fraud flag or blacklist checks on related customer/order
- Polymorphic notes/attachments on refund if present
- Ensure transactional consistency with reservations/consumption if restock involved
- Reporting tie-in: Support analytics like return/refund rates"
161,refund,Cancel Refund,Cancel pending refund,api/refunds/{id}/cancel,post,Admin,Implement Cancel Refund API Endpoint (POST /api/refunds/{id}/cancel),"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint allows cancelling a pending refund in the Deshio ERP system, as part of the payments and returns domain. It handles the refund lifecycle, ensuring synchronization with order payment status and accounting ledgers.

## API Specifications

- **Category:** refund
- **Title:** Cancel Refund
- **Description:** Cancel pending refund
- **Route:** api/refunds/{id}/cancel
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint responds with 200 OK on successful cancellation of a pending refund
- [ ] Endpoint returns 404 if the refund ID does not exist
- [ ] Endpoint returns 400 if the refund is not in a pending state
- [ ] Update refund status to cancelled and synchronize with order.payment_status
- [ ] Post reversal entries to accounting ledgers for the cancelled refund
- [ ] Audit event logged for the cancellation action
- [ ] Unit tests cover happy path, error cases, and state validations
- [ ] Integration tests verify ledger postings and order status updates
- [ ] Endpoint respects RBAC permissions for admin users
- [ ] Response includes RFC7807 problem+json for errors

## Technical Requirements

- Implement in Laravel using a dedicated controller (e.g., RefundController) with the route defined in api.php
- Use state machine to validate and transition refund state from pending to cancelled
- Apply middleware stack: auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, throttles, idempotency, input sanitizer, domain guards (payment/refund)
- Handle soft deletes and UTC timestamps
- Ensure transactional consistency for status updates, ledger postings, and audit events
- Support idempotency to prevent duplicate cancellations
- Add ETag caching headers if applicable

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have role/permission allowing refund cancellation (e.g., 'refunds.cancel')
- Scope to branch if multi-branch context applies
- Verify active user, email verification, and 2FA

## Expected Request/Response Format Considerations

- **Request:** POST to /api/refunds/{id}/cancel; may include optional body for reason/notes (JSON: {""reason"": ""string""}); {id} is UUID or integer refund ID
- **Response:** 200 OK with JSON: {""message"": ""Refund cancelled successfully"", ""data"": {""refund"": {updated refund object}}}
- **Errors:** 4xx/5xx with RFC7807 problem+json, e.g., {""type"": ""https://example.com/probs/refund-not-pending"", ""title"": ""Refund not pending"", ""status"": 400, ""detail"": ""Refund must be in pending state to cancel""}
- Use versioned content-negotiation; JSON limits enforced

## Relevant Business Logic

- Only cancellable if refund is in pending state (pre-capture/processing); use state machine for transition legality
- On cancellation: Void any payment intent if applicable; reverse provisional ledger entries; update associated order.payment_status (e.g., to 'paid' if partial refund)
- Trigger notifications (email/SMS) via templates if configured
- Log audit_event with request-id, user ID, and action details; mask PII
- Ensure no stock movements or returns are affected; handle exchanges separately if linked
- Conflicts (e.g., concurrent modifications) return problem+json; support safe reservation/consumption patterns if inventory tied to refund"
162,transaction,Create Transaction,Record movement/financial entry,api/transactions,post,Employee,Implement POST /api/transactions for Creating Transactions,"## Overview

Deshio is a Laravel-based ERP system for retail/omni-channel operations, featuring approximately 290 REST APIs built over a normalized ERD that covers catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain handles order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, and fraud flags.

Fulfillment involves shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns are managed via RMA (return/return_item), including receive/restock/scrap, refunds, and exchanges (exchange_order).

Payments cover intent→payment capture/void; refund lifecycle; and order.payment_status synchronization. Accounting includes transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.

Services handle service/service_order with lifecycle and profitability. Integrations include carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint, categorized under 'transaction', allows recording movement/financial entries by creating transaction headers and associated ledger_entry lines, ensuring consistent accounting for all stock and financial events, including reversals and support for reconciliation/export.

## API Specifications

- **Category:** transaction
- **Title:** Create Transaction
- **Description:** Record movement/financial entry
- **Route:** api/transactions
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST /api/transactions endpoint to create transaction headers and ledger entries
- [ ] Ensure validation for required fields like transaction type, amount, related entity (e.g., order, inventory adjustment), and ledger lines
- [ ] Handle business logic for automatic ledger posting on stock/financial events, including reversals
- [ ] Integrate with state machines to validate transitions and return RFC7807 problem+json for conflicts
- [ ] Add unit and integration tests covering successful creation, validation errors, authorization failures, and edge cases like soft deletes or UTC handling
- [ ] Verify soft deletes for archival and polymorphic attachments/notes if applicable
- [ ] Ensure idempotency via middleware for safe retries
- [ ] Test reconciliation/export compatibility for created transactions
- [ ] Confirm audit_event logging and request-id tracing
- [ ] Document the endpoint in API specs with examples

## Technical Requirements

- Develop a Laravel controller (e.g., TransactionController) with a store method
- Define routes in api.php with proper middleware stack (auth, RBAC, throttles, idempotency, input sanitizer)
- Use Eloquent models for Transaction (header) and LedgerEntry (lines), with relationships to core entities like orders, inventory batches, payments
- Implement input validation using Form Requests, covering required fields, data types, referential integrity, and business rules (e.g., amount > 0, valid transaction type)
- Handle errors with standardized responses: success (201 Created with transaction ID), validation errors (422 with details), unauthorized (401), forbidden (403), and conflicts (409 with problem+json)
- Ensure database transactions for atomicity in creating headers and lines
- Leverage queues for any async processing (e.g., notifications or exports)
- Apply caching/etag if applicable for related data fetches
- Use UTC for all timestamps and handle locale/tz via middleware

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT/session/API key
- Enforce RBAC: Employee role with permissions for creating transactions (e.g., 'transaction.create')
- Apply branch scope to restrict to authorized stores/branches
- Check active user, email-verified, and 2FA if enabled
- Optional tenancy isolation
- Audit all actions with audit_event for compliance

## Expected Request/Response Format Considerations

- **Request:** JSON body with fields like: type (e.g., 'stock_movement', 'payment_capture'), amount, currency, related_id (e.g., order_id), related_type, ledger_lines array (each with account_id, debit/credit, description), notes (polymorphic), attachments (if applicable). Use strict validation for EAV attributes if needed.
- **Response:** 201 Created with JSON: { id, type, amount, status, created_at, ledger_entries: [{id, account, debit, credit, ...}], links: {self, related_entity} }. Include ETag for caching. Errors in problem+json format per RFC7807.
- Support bulk creation if extending to multiple transactions, but start with single for this endpoint.
- Ensure PII masking in logs/responses.

## Relevant Business Logic

- Transactions record all movements/financial entries, posting to ledger_entries automatically for events like order fulfillment, inventory adjustments, payments, returns, or reversals.
- Use state machines to enforce legal transitions (e.g., only confirmed orders can trigger fulfillment transactions).
- Maintain referential integrity with strict links to entities (e.g., order_id foreign key).
- Support reversals by creating opposing ledger entries.
- Synchronize with related domains (e.g., update order.payment_status on payment transactions).
- Enable export/reconciliation by including all necessary metadata (e.g., timestamps in UTC, audit trails).
- Handle conflicts (e.g., concurrent stock reservations) with domain guards and return detailed errors.
- Ensure deterministic behavior for admin assignments and safe consumption of reservations."
163,transaction,List Transactions,Filter by type/date/store,api/transactions,get,Employee,Implement List Transactions API Endpoint (GET /api/transactions),"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The List Transactions endpoint provides a way to retrieve a list of accounting transactions in the Deshio ERP system, filtered by type, date, and store. Transactions refer to accounting transaction headers + ledger_entry lines for all movements, including reversals, with support for reconciliation and export.

## API Specifications

- **Category:** transaction
- **Title:** List Transactions
- **Description:** Filter by type/date/store
- **Route:** api/transactions
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET /api/transactions endpoint in Laravel
- [ ] Support query parameters for filtering by transaction type, date range, and store/branch
- [ ] Ensure response includes paginated list of transaction headers with relevant ledger entries
- [ ] Add input validation for filters (e.g., valid types, date formats, store IDs)
- [ ] Implement proper error handling using RFC7807 problem+json for invalid requests or conflicts
- [ ] Write unit and integration tests covering happy path, edge cases (e.g., no results, invalid filters), and authentication
- [ ] Verify soft deletes are handled (exclude deleted transactions unless specified)
- [ ] Ensure data is returned in UTC and respects branch scope
- [ ] Add audit logging for endpoint access
- [ ] Document the endpoint in API specs with examples

## Technical Requirements

- Use Laravel controller (e.g., TransactionController@index) and define route in api.php with middleware stack
- Apply middleware: auth (JWT/session/API key), active user, RBAC & permission checks (employee role with transaction read permission), branch scope
- Implement query builder or Eloquent for fetching transactions with joins to ledger_entries, stores, etc.
- Support pagination (e.g., via Laravel's paginate() with ?page= and ?per_page=)
- Use EAV for any dynamic attributes; polymorphic relations for notes/attachments if applicable
- Cache headers and ETag support for performance
- Input validation with Laravel Form Requests: validate type enum, date as ISO 8601, store as UUID/int
- Response format: JSON array of transaction objects with fields like id, type, date, store_id, amount, status, ledger_entries[]
- Handle state machines if transitions affect visibility (e.g., only confirmed transactions)
- Ensure referential integrity and consistent ledger posting context
- Queues for any heavy reconciliation/export if triggered
- Observability: request-id, metrics for endpoint usage

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- RBAC: User must have role with permission to read transactions (e.g., 'transaction:read')
- Branch scope: Filter results to user's assigned branches/stores
- Optional: Email verification, 2FA enforcement based on user settings
- Idempotency and throttling applied via middleware

## Expected Request/Response Format Considerations

**Request:** GET /api/transactions?type=sale&date_from=2023-01-01&date_to=2023-12-31&store_id=123&page=1&per_page=50
- Query params: type (string enum: sale, refund, adjustment, etc.), date_from/date_to (ISO 8601 strings), store_id (int/UUID), optional sort/order
- No request body

**Response (200 OK):** 
{
  ""data"": [
    {
      ""id"": 1,
      ""type"": ""sale"",
      ""date"": ""2023-01-01T00:00:00Z"",
      ""store_id"": 123,
      ""amount"": 100.00,
      ""status"": ""posted"",
      ""ledger_entries"": [...],
      ""reversed"": false
    }
  ],
  ""meta"": { ""current_page"": 1, ""last_page"": 10, ... }
}

**Errors:** 4xx/5xx with RFC7807 format, e.g., 422 for validation errors, 403 for unauthorized, 429 for throttling

## Relevant Business Logic

- Transactions capture all financial/stock movements (orders, payments, inventory adjustments, returns, etc.) with ledger entries for debits/credits
- Filter by type (e.g., payment_capture, stock_adjustment, reversal); date in UTC; store for branch-specific views
- Respect soft deletes: exclude archived transactions
- Ensure determinism: consistent posting on events, no partial ledgers
- Support reversals: mark and link reversed transactions
- Analytics tie-in: Use for reporting revenue, refunds, etc.
- Conflicts (e.g., concurrent edits) resolved via state machines returning problem+json
- PII masking in logs/responses for compliance"
164,transaction,Get Transaction,Transaction details,api/transactions/{id},get,Employee,Implement GET /api/transactions/{id} for Transaction Details,"## Overview

Deshio is a Laravel-based ERP system for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment covers shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns handle RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments manage intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting involves transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services include service/service_order with lifecycle and profitability. Integrations cover carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint retrieves detailed information for a specific transaction in the accounting module, which includes transaction headers and associated ledger_entry lines for all movements, supporting reversals, reconciliation, and export functionalities.

## API Specifications

- **Category:** transaction
- **Title:** Get Transaction
- **Description:** Transaction details
- **Route:** api/transactions/{id}
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET endpoint to retrieve transaction details by ID
- [ ] Ensure the endpoint returns comprehensive transaction data including headers, ledger entries, and related movements
- [ ] Validate the {id} parameter as a valid transaction ID
- [ ] Handle cases where the transaction is not found (e.g., 404 response)
- [ ] Apply proper RBAC checks for employee authentication and authorization
- [ ] Include soft deletes handling to exclude archived transactions unless specified
- [ ] Support UTC timestamps and consistent data formatting
- [ ] Add unit and integration tests for successful retrieval, invalid ID, unauthorized access, and error scenarios
- [ ] Ensure response complies with RFC7807 for problem details in error cases
- [ ] Verify integration with middleware for auth, RBAC, request ID, and caching/etag

## Technical Requirements

- Use Laravel framework: Define the route in api.php, create a dedicated controller (e.g., TransactionController) with a show method
- Implement input validation for the {id} path parameter using Laravel's validation rules (e.g., required|exists:transactions,id)
- Query the transaction model, eager-loading related ledger_entries, reversals, and any polymorphic notes/attachments
- Handle business logic for transaction retrieval: Ensure referential integrity with strict links; apply branch scope if applicable; mask PII if present
- Proper error handling: Use Laravel exceptions for 404 (ModelNotFound), 403 (unauthorized), and custom RFC7807 JSON problems for conflicts
- Integrate with state machines if transaction state affects visibility (e.g., pending vs. reconciled)
- Optimize for performance: Use Eloquent relationships, caching where appropriate, and etag for conditional requests

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- Enforce RBAC: User must have a role with permission to view transactions (e.g., 'view-transactions' ability)
- Apply middleware stack: auth, active user, email-verified, 2FA (if enabled), RBAC & permission checks, branch scope
- For multi-role users, check against all assigned roles; deny if no matching permission
- Log audit_event for access attempts, including request-id for traceability

## Expected Request/Response Format Considerations

- **Request:** No body; path parameter {id} (UUID or integer). Query params optional for includes (e.g., ?include=ledger_entries,reversals) or filters if extended
- **Response:** JSON object with transaction details:
  {
    ""data"": {
      ""id"": ""uuid"",
      ""type"": ""transaction"",
      ""attributes"": {
        ""header_info"": {...},
        ""created_at"": ""UTC timestamp"",
        ""updated_at"": ""UTC timestamp""
      },
      ""relationships"": {
        ""ledger_entries"": [{...}],
        ""reversals"": [{...}],
        ""notes"": [{...}]  // polymorphic
      }
    }
  }
- Use JSON:API or similar structure for consistency; include EAV attributes if applicable
- Error responses: RFC7807 problem+json, e.g., {""title"": ""Not Found"", ""status"": 404, ""detail"": ""Transaction not found""}
- Headers: Etag for caching, X-Request-Id, Content-Type: application/json

## Relevant Business Logic

- Transactions represent accounting entries for stock/financial events (e.g., order fulfillment, payments, inventory adjustments)
- Ensure consistent ledger posting: Retrieve includes all related ledger_entry lines and verify balances
- Support reversals: If applicable, include reversal details and impact on reconciliation
- Integrate with domain guards: Prevent access to transactions involving fraud-flagged orders or unauthorized branches
- Handle soft deletes: Query withOnlyTrashed() if admin access, but default to active records
- Align with observability: Emit metrics for endpoint usage, log access with PII masking, and queue if heavy computation needed
- Business rules: Transactions are immutable post-posting; retrieval should not alter state; support export/reconciliation views"
165,transaction,Reverse Transaction,Create reversal entry,api/transactions/{id}/reverse,post,Admin,Implement Reverse Transaction API Endpoint (POST /api/transactions/{id}/reverse),"## Overview

This GitHub issue is for implementing the 'Reverse Transaction' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment covers shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns handle RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments involve intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting uses transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services include service/service_order with lifecycle and profitability. Integrations cover carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint allows creating a reversal entry for a transaction, ensuring consistent ledger posting, reversals, and compliance with state machine legality.

## API Specifications

- **Category:** transaction
- **Title:** Reverse Transaction
- **Description:** Create reversal entry
- **Route:** api/transactions/{id}/reverse
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST /api/transactions/{id}/reverse endpoint in Laravel
- [ ] Ensure the endpoint creates a reversal entry in the transaction header and ledger_entry lines
- [ ] Validate that the transaction exists and is reversible based on state machine rules
- [ ] Handle authorization for Admin users only, with RBAC permission checks
- [ ] Add input validation for any request body parameters (e.g., reversal reason)
- [ ] Implement proper error handling, returning RFC7807 problem+json for conflicts or invalid states
- [ ] Ensure transactional consistency for ledger posting and stock/financial event reversals
- [ ] Write unit and integration tests covering success, failure, and edge cases (e.g., non-reversible transactions, soft-deleted records)
- [ ] Verify UTC storage, soft deletes, and audit_event logging
- [ ] Test middleware integration (auth, RBAC, idempotency, domain guards)
- [ ] Document request/response formats in API specs
- [ ] Ensure compatibility with observability (logs, metrics) and compliance (PII masking)

## Technical Requirements

- Use Laravel controller (e.g., TransactionController@reverse) and define route in api.php with {id} parameter binding
- Implement input validation using Form Requests or Validator, including checks for transaction ID existence and reversibility
- Integrate with state machines to validate transition legality; prevent reversals on fulfilled or cancelled states if not allowed
- Handle business logic for reversals: create reversal transaction header, post opposing ledger_entry lines, trigger any related stock movements or payment synchronizations
- Apply soft deletes if applicable; use EAV for any attribute extensions; maintain referential integrity
- Support polymorphic attachments/notes for reversal records
- Ensure all operations are in UTC and transactional (database transactions for consistency)
- Add audit_event logging for the reversal action

## Authentication/Authorization Requirements

- Require Admin authentication via JWT/session/API key
- Enforce RBAC: User must have 'transaction.reverse' permission (or equivalent) via role/permission abilities
- Apply middleware stack: auth, active user, email-verified, 2FA, RBAC checks, branch scope if applicable
- Reject unauthorized requests with 403 Forbidden (RFC7807 format)

## Expected Request/Response Format Considerations

- **Request:** JSON body optional (e.g., {""reason"": ""string""} for reversal note); validate MIME types if attachments included
- **Path Parameter:** {id} as UUID or integer for transaction ID; sanitize input
- **Response:** 200 OK with JSON {""success"": true, ""reversal_id"": ""uuid"", ""message"": ""Reversal created""} on success; 404 if transaction not found; 422 for validation errors; 409 for state conflicts
- Use versioned content-negotiation, cache headers (no-cache for mutations), and ETag if applicable
- Return problem+json for errors per RFC7807, including request-id for tracing

## Relevant Business Logic

- Reversals must post consistent ledger entries opposing the original transaction lines, supporting reconciliation/export
- Integrate with accounting domain: handle reversals for stock movements, payments, or financial events
- Check for dependencies (e.g., cannot reverse if linked to fulfilled orders or shipments without proper state transition)
- Trigger notifications (email/SMS) via templates if configured for reversal events
- Ensure idempotency: Use idempotency keys to prevent duplicate reversals
- Comply with domain guards for transaction/payment/reservation/promo/override/fraud contexts
- Maintain ledger integrity across all movements; support valuation and aging reports post-reversal"
166,transaction,Export Journal,Export accounting journal,api/transactions/export,get,Admin,Implement Export Journal API Endpoint (transaction category),"## Overview

This issue is for implementing the 'Export Journal' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs built over a normalized ERD. The system covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes (fields/features), media (product images), barcodes, pricing (price overrides), and promotions; stores/branches; customers with tags/blacklists.

Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending → confirmed → fulfilled|cancelled), assignment to stores, notes/attachments, promotions, taxes, and fraud flags. Fulfillment handles shipments (shipment/shipment_item) and inter-store dispatches (dispatch + tracking, scan events, POD) with transactional stock movements. Returns manage RMAs (return/return_item), receiving/restocking/scrap, refunds, and exchanges (exchange_order).

Payments involve intent → payment capture/void; refund lifecycles; and order.payment_status synchronization. Accounting features transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services include service/service_order with lifecycles and profitability. Integrations cover carriers & accounts, waybills/rates/tracking; webhooks with deliveries; and notification templates (email/SMS).

Security & identity: user/role/permission with abilities (role ↔ perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The 'Export Journal' endpoint specifically allows exporting the accounting journal, which involves transaction headers and ledger_entry lines for all movements, including reversals and reconciliation/export features.

## API Specifications

- **Category:** transaction
- **Title:** Export Journal
- **Description:** Export accounting journal
- **Route:** api/transactions/export
- **HTTP Method:** GET
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET /api/transactions/export endpoint in Laravel
- [ ] Ensure the endpoint exports accounting journal data (transaction headers + ledger_entry lines) in a suitable format (e.g., CSV, PDF, or JSON for reconciliation/export)
- [ ] Support query parameters for filtering exports (e.g., date range, transaction types, branches/stores)
- [ ] Add input validation for any query parameters
- [ ] Handle authentication and authorization for Admin users only
- [ ] Implement proper error handling with RFC7807 problem+json for conflicts or invalid requests
- [ ] Write unit and integration tests covering successful exports, invalid inputs, unauthorized access, and edge cases (e.g., no data, large datasets)
- [ ] Ensure exports respect soft deletes and UTC timestamps
- [ ] Add audit_event logging for export actions
- [ ] Verify integration with state machines if any transitions are involved
- [ ] Test middleware stack including RBAC, throttles, and idempotency
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger)

## Technical Requirements

- Use Laravel controller (e.g., TransactionController) and define the route in api.php with proper versioning
- Leverage Eloquent models for transaction headers and ledger_entry lines; query with joins or relations for comprehensive export data
- Implement export logic using Laravel's response helpers (e.g., response()->stream() for file downloads) or packages like Maatwebsite/Excel for formatted outputs
- Apply domain guards for accounting-related validations
- Ensure consistent ledger posting integrity during export (read-only operation)
- Handle large exports with pagination or streaming to avoid memory issues
- Integrate with reporting/analytics for journal data (e.g., by date, store, movement type)
- Use caching/etag if applicable for repeated exports
- Follow Deshio's normalized ERD for data retrieval, including polymorphic relations if notes/attachments are included

## Authentication/Authorization Requirements

- Require Admin authentication via JWT, session, or API key
- Enforce RBAC: Only users with 'admin' role or specific permissions (e.g., 'export.journal') can access
- Include middleware for active user, email-verified, 2FA, and branch scope
- Reject unauthorized requests with 401/403 and appropriate error messages

## Expected Request/Response Format Considerations

- **Request:** GET with optional query params (e.g., ?from_date=YYYY-MM-DD&to_date=YYYY-MM-DD&type=movement&branch_id=1&format=csv). Use content-negotiation for response format (default: application/json, alternatives: text/csv, application/pdf).
- **Response:** On success (200), stream/download export file or return JSON array of journal entries with fields like id, date (UTC), transaction_type, headers, ledger_lines, amounts, reversals. Include metadata (e.g., total_records, export_date).
- **Errors:** 400 for invalid params (validation errors), 401/403 for auth issues, 422 for unprocessable entity, 500 for server errors. Use RFC7807 problem+json format.
- Ensure PII masking in exports if sensitive data is involved; add request-id header.

## Relevant Business Logic

- Export must capture all accounting movements (stock/financial events) with ledger postings, including reversals and reconciliations.
- Support bulk export aligned with Deshio's bulk import/export APIs.
- Ensure determinism: Exports should be consistent and auditable, tying back to audit_event logs.
- Handle state machine legality: If exports involve current states (e.g., pending vs. confirmed transactions), validate transitions implicitly via queries.
- Integrate with observability: Log export events, track performance metrics (e.g., export time for large journals), and support queues for async large exports if needed."
167,transaction,Reconcile Period,Lock & reconcile period,api/transactions/reconcile,post,Admin,Implement POST /api/transactions/reconcile for Period Reconciliation,"## Overview

This GitHub issue is for implementing the 'Reconcile Period' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint handles locking and reconciling accounting periods, ensuring accurate transaction headers and ledger entries for movements, reversals, and exports.

## API Specifications

- **Category:** transaction
- **Title:** Reconcile Period
- **Description:** Lock & reconcile period
- **Route:** api/transactions/reconcile
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST endpoint at /api/transactions/reconcile
- [ ] Ensure the endpoint locks the specified accounting period to prevent further transactions
- [ ] Perform reconciliation by verifying and balancing transaction headers and ledger_entry lines for all movements within the period
- [ ] Handle reversals and exports as part of the reconciliation process
- [ ] Add input validation for period details (e.g., start_date, end_date)
- [ ] Implement proper error handling with RFC7807 problem+json for conflicts or invalid states
- [ ] Write unit and integration tests covering successful reconciliation, locking failures, and edge cases like ongoing transactions
- [ ] Ensure the endpoint integrates with state machines for legality of transitions in accounting contexts
- [ ] Verify soft deletes and UTC data handling in reconciliation logic
- [ ] Test middleware application including auth, RBAC, and idempotency

## Technical Requirements

- Use Laravel controller and define routes in api.php with proper versioning
- Implement input validation using Laravel's Form Requests or Validator, including sanitization and domain guards for accounting operations
- Handle business logic for period locking (e.g., update period status to 'locked') and reconciliation (balance ledgers, post adjustments if needed)
- Integrate with EAV attributes if periods have custom fields; ensure polymorphic relations for any notes/attachments on reconciliation events
- Use queues for long-running reconciliation tasks if the period is large
- Add audit_event logging for the reconciliation action
- Implement caching/etag for related reporting data post-reconciliation
- Ensure transactional consistency for stock/financial events during reconciliation
- Follow middleware stack: auth (Admin role/permission check), RBAC, branch scope, throttles, idempotency

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have 'admin' role with permission for 'reconcile-period' ability
- Check active user, email-verified, and 2FA if enabled
- Branch scope: Ensure admin has access to the relevant branches/stores for the period

## Expected Request/Response Format Considerations

- **Request Body:** JSON with period details, e.g., {""period_id"": 123, ""start_date"": ""2023-01-01T00:00:00Z"", ""end_date"": ""2023-01-31T23:59:59Z"", ""notes"": ""Reconciliation notes""}. Validate required fields, dates in UTC, and prevent overlapping active periods
- **Response:** On success, 200 OK with JSON {""success"": true, ""reconciled_at"": ""2023-02-01T00:00:00Z"", ""summary"": {""balanced"": true, ""adjustments"": 0}}. On error, RFC7807 problem+json, e.g., 409 Conflict for locked or ongoing periods
- Support idempotency via key in header to allow safe retries
- Use content-negotiation for versioned responses; include request-id in headers

## Relevant Business Logic

- Reconciliation locks the period to ensure no further transactions can be posted, then verifies all ledger_entry lines against transaction headers for balance
- Handle reversals by identifying and correcting unmatched entries
- Integrate with reporting/analytics for post-reconciliation metrics like revenue accuracy or inventory valuation
- Ensure consistent ledger posting: Every stock/financial event in the period must be accounted for
- If conflicts arise (e.g., unconfirmed transactions), return detailed errors without proceeding
- Support exports: Optionally generate reconciliation reports or exports as part of the response or side-effect"
168,sales,List Sales,Sales entries joined to txns,api/sales,get,Employee,Implement List Sales API Endpoint (GET /api/sales),"## Overview

Implement the 'List Sales' API endpoint for the Deshio ERP system. This endpoint retrieves a list of sales entries joined with transaction data (txns), enabling retrieval of sales records along with associated accounting transactions. Deshio is a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment covers shipments/shipment_items and inter-store dispatch with tracking and stock movements. Returns handle RMA (return/return_item), refunds, exchanges. Payments manage intent→payment capture/void, refunds, and order.payment_status sync. Accounting involves transaction headers + ledger_entry lines for all movements, reversals, reconciliation/export. Services include service/service_order lifecycle. Integrations cover carriers, webhooks, notifications. Security features user/role/permission with RBAC, sessions, email verification, password reset, TOTP MFA, API keys. Observability includes audit_event, logs, PII masking, health/metrics. Middleware enforces TLS/HSTS, CORS, auth (JWT/session/API key), RBAC checks, branch scope, throttles, idempotency, sanitization, domain guards. Reporting/analytics cover revenue/orders by store/product, LTV/AOV, returns, inventory aging, promo impact. State machines ensure legal transitions for orders, shipments, returns, payments; conflicts return RFC7807 problem+json. APIs support bulk import/export, search, attachments, reindex, backups, feature flags. Data uses UTC, soft deletes, EAV for attributes, polymorphic notes/attachments, strict referential links. Design supports deterministic admin assignment, safe reservations, consistent ledger posting on stock/financial events.

This endpoint falls under the sales category and is crucial for retrieving sales data linked to accounting transactions for reporting and analytics.

## API Specifications

- **Category:** sales
- **Title:** List Sales
- **Description:** Sales entries joined to txns
- **Route:** api/sales
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint returns a paginated list of sales entries joined with transaction data
- [ ] Supports query parameters for filtering, sorting, and pagination (e.g., ?page=1&filter[date_from]=2023-01-01)
- [ ] Handles authentication for Employee users with appropriate RBAC permissions
- [ ] Returns 200 OK with JSON array of sales objects including txn details on success
- [ ] Returns 401 Unauthorized if not authenticated
- [ ] Returns 403 Forbidden if user lacks permissions
- [ ] Returns 422 Unprocessable Entity for invalid query parameters
- [ ] Implements proper error handling with RFC7807 problem+json for conflicts
- [ ] Includes audit logging for endpoint access
- [ ] Unit and integration tests cover happy path, edge cases, and errors
- [ ] Documentation updated in API specs (e.g., OpenAPI/Swagger)
- [ ] Performance optimized for large datasets with efficient joins and indexing

## Technical Requirements

- Use Laravel framework: Define route in api.php, create SalesController with index() method
- Implement Eloquent queries to join sales entities with transaction headers and ledger_entry lines
- Apply middleware stack: RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, throttles, idempotency, input sanitizer, cache headers
- Use soft deletes and UTC timestamps; handle EAV attributes if sales include product features
- Ensure referential integrity in joins across sales, orders, payments, and accounting entities
- Support search/autosuggest if extended; consider bulk export capabilities
- Integrate with state machines if sales transitions are involved (e.g., order fulfillment states)
- Add observability: Log requests with request-id, audit_event for access, PII masking in responses
- Handle polymorphic relations for notes/attachments on sales if applicable

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- Enforce RBAC: User must have role/permission allowing access to sales data (e.g., view_sales permission)
- Apply branch scope: Limit results to user's assigned stores/branches
- Optional tenancy if multi-tenant setup
- Verify active user, email-verified, and 2FA if enabled
- Use domain guards for sales-related operations (e.g., fraud flag checks)

## Expected Request/Response Format Considerations

- **Request:** GET /api/sales with optional query params (e.g., filter by date, store_id, status; sort by amount, date; paginate with page, per_page)
- **Response:** 200 OK with JSON: { ""data"": [ { ""id"": 1, ""date"": ""2023-01-01T00:00:00Z"", ""amount"": 100.00, ""txn_id"": 123, ""ledger_entries"": [...], ""order_id"": 456, ... } ], ""meta"": { ""current_page"": 1, ""last_page"": 10, ... } }
- Error responses: RFC7807 problem+json, e.g., { ""type"": ""https://example.com/probs/out-of-credit"", ""title"": ""Insufficient Funds"", ""status"": 403, ""detail"": ""Sales access denied"" }
- Use content-negotiation for JSON; set cache headers (ETag); enforce JSON limits

## Relevant Business Logic

- Sales entries represent completed order fulfillments or service orders with financial impact
- Join to txns includes transaction headers and ledger_entry lines for revenue recognition, taxes, promos, refunds
- Filter by order states (e.g., fulfilled), payment_status, store/branch, customer tags/blacklist
- Support analytics: Include aggregates for revenue, units sold, AOV; consider promo impact, return rates
- Ensure deterministic ledger posting: Every sales record triggers consistent accounting entries
- Handle reservations/consumption in inventory if sales involve stock movements
- Conflicts (e.g., insufficient permissions, invalid date range) trigger state machine validation and error responses
- Integrate with reporting: Enable queries for revenue by store/product/user, LTV, SLA metrics"
169,sales,Sales By User,Sales by salesperson,api/sales/by-user,get,Admin,Implement Sales By User API Endpoint (Sales Category),"## Overview

This GitHub issue is for implementing the 'Sales By User' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain handles states (pending→confirmed→fulfilled|cancelled), assignments, notes/attachments, promos, taxes, fraud flags. Fulfillment involves shipments, inter-store dispatches with tracking and POD. Returns manage RMAs, restocking, refunds, exchanges. Payments include intents, captures, voids, refunds, and synchronization. Accounting tracks transactions, ledgers, reversals, reconciliations. Services handle service orders with lifecycle and profitability. Integrations support carriers, waybills, rates, tracking, webhooks, notifications. Security includes user/role/permission with abilities, sessions, email verification, password reset, TOTP MFA, API keys. Observability covers audits, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, webhook signatures, cache headers. Reporting/analytics include revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines ensure legal transitions for orders, items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, strict referential links. Design supports deterministic admin assignment, safe reservations, consistent ledger posting.

The 'Sales By User' endpoint retrieves sales data by salesperson, fitting into the sales reporting/analytics for revenue by user.

## API Specifications

- **Category:** sales
- **Title:** Sales By User
- **Description:** Sales by salesperson
- **Route:** api/sales/by-user
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET /api/sales/by-user endpoint in Laravel controller
- [ ] Ensure endpoint requires Admin authentication and RBAC permissions
- [ ] Add input validation for query parameters (e.g., user ID, date ranges, filters)
- [ ] Handle pagination, sorting, and searching for sales data
- [ ] Integrate with order and payment entities to calculate sales metrics (e.g., revenue, units, orders by user)
- [ ] Return data in JSON format with proper structure, including totals and breakdowns
- [ ] Implement error handling for invalid inputs or unauthorized access using RFC7807 problem+json
- [ ] Write unit and integration tests covering happy paths, edge cases, and auth failures
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger)
- [ ] Ensure compliance with middleware (e.g., throttling, idempotency, caching/etag)
- [ ] Verify integration with reporting/analytics for user-based sales (LTV/AOV, activity)
- [ ] Test state machine compatibility for order/payment states in sales calculations

## Technical Requirements

- Use Laravel for controller, routes, and Eloquent models querying orders, order_items, payments, and users
- Leverage normalized ERD for joins across entities (e.g., user→order→payment)
- Implement query builder for efficient filtering by user, date ranges, store/branch scope
- Support bulk/export capabilities if extended for reporting
- Use UTC timestamps; handle locale/tz via middleware
- Apply soft deletes filter to exclude archived data
- Ensure transactional consistency for any related ledger postings in sales context
- Add observability: audit_event logging for endpoint access, request-id tracing
- Optimize for performance with caching/etag and indexes on user/order fields

## Authentication/Authorization Requirements

- Requires Admin role with specific permissions (e.g., view_sales_reports, view_user_data)
- Use JWT/session/API key auth via middleware
- Enforce active user, email-verified, 2FA checks
- Apply RBAC & permission checks; branch scope if multi-tenant
- Domain guards for order/payment access in sales data
- PII masking for customer data in responses

## Expected Request/Response Format Considerations

- **Request:** GET /api/sales/by-user?user_id=123&start_date=2023-01-01&end_date=2023-12-31&store_id=456&paginate=20&sort=total_desc
  - Query params: user_id (required, integer), date ranges (ISO format), filters (store, product, etc.), pagination/sorting options
  - Versioned via content-negotiation (e.g., Accept: application/vnd.deshio.v1+json)

- **Response:** 200 OK with JSON array/object:
  {
    ""data"": [
      {
        ""user_id"": 123,
        ""user_name"": ""John Doe"",
        ""total_orders"": 50,
        ""total_revenue"": 15000.00,
        ""total_units"": 200,
        ""period"": ""2023"",
        ""breakdown"": [...]  // e.g., by month/store
      }
    ],
    ""meta"": { ""total"": 1, ""per_page"": 20, ""current_page"": 1 }
  }
  - Errors: 4xx/5xx with problem+json (e.g., 401 Unauthorized, 403 Forbidden, 422 Validation Error)
  - Use ETag for caching; include Link headers for pagination

## Relevant Business Logic

- Calculate sales based on confirmed/fulfilled orders assigned to the user/salesperson
- Include applied promotions, taxes, refunds in net revenue
- Sync with payment_status for captured payments only
- Handle fraud flags to exclude suspicious sales if flagged
- Support analytics metrics: revenue by user, AOV, order counts
- Ensure deterministic calculations aligning with accounting ledgers
- Respect state machines: only include orders in valid states (e.g., not pending/cancelled)
- Filter by branch/store scope for multi-location visibility
- Optional: Integrate with customer tags/blacklist for sales insights"
170,sales,Sales By Store,Sales grouped by store,api/sales/by-store,get,Admin,Implement Sales By Store API Endpoint (GET /api/sales/by-store),"## Overview

This GitHub issue is for implementing the 'Sales By Store' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. Order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment covers shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns include RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments involve intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting features transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services include service/service_order with lifecycle and profitability. Integrations cover carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint provides sales data grouped by store, fitting into the reporting/analytics module for insights like revenue/orders/units by store.

## API Specifications

- **Category:** sales
- **Title:** Sales By Store
- **Description:** Sales grouped by store
- **Route:** api/sales/by-store
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET /api/sales/by-store endpoint in Laravel
- [ ] Ensure the endpoint returns sales data grouped by store (e.g., revenue, orders, units) with support for query parameters like date ranges, filters
- [ ] Add input validation for query parameters (e.g., dates in UTC, store IDs)
- [ ] Integrate RBAC checks for Admin role/permission
- [ ] Handle errors with RFC7807 problem+json format for conflicts or invalid states
- [ ] Write unit and integration tests covering happy path, edge cases (e.g., no data, invalid dates), and authentication failures
- [ ] Ensure response includes proper caching/etag headers and request-id tracing
- [ ] Verify compatibility with middleware stack (auth, RBAC, branch scope, throttles, etc.)
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger)

## Technical Requirements

- Use Laravel controller (e.g., SalesController) and define route in api.php with 'admin' middleware group
- Query sales data from relevant entities (orders, order_items, payments, ledger_entries) aggregated by store/branch, respecting soft deletes and UTC timestamps
- Support query parameters: e.g., ?from_date=YYYY-MM-DD&to_date=YYYY-MM-DD&store_ids[]=1&group_by=store (infer based on reporting needs; include filters for product/category/vendor if applicable)
- Implement business logic for sales calculation: sum revenue (considering promos, taxes, refunds), count orders/units, handle payment_status synchronization and ledger postings
- Use Eloquent queries or DB raw for efficient grouping/aggregation; consider caching for performance
- Integrate state machines if filtering by order states (e.g., confirmed/fulfilled)
- Ensure transactional consistency for any related data reads

## Authentication/Authorization Requirements

- Require Admin authentication via JWT/session/API key
- Enforce RBAC: User must have 'admin' role or specific permission (e.g., 'view_sales_reports')
- Apply branch scope if multi-tenant; check active user, email-verified, and 2FA if enabled
- Use middleware for auth, RBAC & permission checks

## Expected Request/Response Format Considerations

- **Request:** GET with optional query params (e.g., from_date, to_date, store_ids). Use JSON limits and input sanitizer middleware.
- **Response:** JSON array/object of sales groups by store, e.g., {""stores"": [{""id"":1, ""name"":""Store A"", ""revenue"":1234.56, ""orders"":10, ""units"":50}, ...]}. Include metadata like total_count, pagination if large datasets. Use versioned content-negotiation (e.g., Accept: application/vnd.deshio.v1+json). Errors: RFC7807 problem+json (e.g., 400 for invalid dates, 403 for unauthorized).
- Handle locale/tz for date params; store/process in UTC.

## Relevant Business Logic

- Aggregate sales from order fulfillment (confirmed→fulfilled states), excluding cancelled/returned items post-refund
- Account for promotions, price_overrides, taxes in revenue calc; sync with payment_status and ledger_entries for accuracy
- Support analytics metrics: revenue by store, orders/units, potentially LTV/AOV/return rates if filtered
- Ensure PII masking in logs/audits; log audit_event for access
- Conflicts (e.g., invalid date range) trigger state machine checks or domain guards, returning structured errors"
171,sales,Sales By Product,Sales grouped by product,api/sales/by-product,get,Admin,Implement Sales By Product API Endpoint (GET /api/sales/by-product),"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint provides sales data grouped by product, enabling reporting and analytics on product performance within the Deshio ERP system.

## API Specifications

- **Category:** sales
- **Title:** Sales By Product
- **Description:** Sales grouped by product
- **Route:** api/sales/by-product
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET /api/sales/by-product endpoint in Laravel
- [ ] Ensure endpoint returns sales data grouped by product, including relevant metrics like quantity sold, revenue, etc.
- [ ] Add input validation for query parameters (e.g., date range, store filters)
- [ ] Implement proper authentication and authorization checks
- [ ] Write unit and integration tests covering success, error, and edge cases
- [ ] Ensure response complies with Deshio API standards (e.g., JSON structure, error formats per RFC7807)
- [ ] Add documentation for the endpoint in API docs
- [ ] Verify integration with reporting/analytics features (e.g., by store/product)
- [ ] Test for performance with large datasets, considering caching/etag

## Technical Requirements

- Use Laravel controller and define route in api.php
- Leverage Eloquent models for orders, order_items, products, and related entities
- Implement query builder for grouping sales by product, joining necessary tables (e.g., orders, order_items, products)
- Support query parameters for filtering (e.g., ?start_date=YYYY-MM-DD&end_date=YYYY-MM-DD&store_id=1)
- Handle soft deletes and UTC timestamps appropriately
- Integrate with middleware stack: auth (JWT/API key), RBAC permission checks, branch scope, throttles, input sanitizer
- Use state machines if needed for order states in sales calculations
- Ensure transactional consistency for any underlying data queries
- Add audit_event logging for endpoint access
- Optimize for observability: request-id, metrics, caching headers

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have admin role with permissions for sales reporting access
- Apply branch scope if multi-branch filtering is used
- Include active user, email-verified, and optional 2FA checks via middleware
- Return 401/403 errors with RFC7807 problem+json for unauthorized access

## Expected Request/Response Format Considerations

- **Request:** GET /api/sales/by-product?start_date=YYYY-MM-DD&end_date=YYYY-MM-DD&store_id=integer&product_id=integer (optional filters for date range, store, product)
- **Response:** 200 OK with JSON array of objects, e.g., [{ ""product_id"": 1, ""product_name"": ""Item"", ""quantity_sold"": 10, ""total_revenue"": 100.00, ""avg_price"": 10.00 }], paginated if large
- Include metadata like total_count, filters_applied
- Error responses: 400 for invalid params, 422 for validation errors, 500 for server issues, all in problem+json format
- Content negotiation for versioned API, locale/tz handling

## Relevant Business Logic

- Calculate sales based on confirmed/fulfilled order states, excluding cancelled/returned items
- Group by product, aggregating from order_items with applied promos, taxes, price_overrides
- Consider inventory batches if per-unit tracking affects sales valuation
- Integrate with accounting ledger_entries for accurate revenue figures
- Handle fraud flags or blacklisted customers by excluding from totals
- Ensure deterministic results with UTC data and consistent ledger posting
- Support analytics metrics like units sold, revenue by product/store, aligning with reporting features (e.g., promo impact, LTV/AOV)"
172,purchase,List Purchase-Orders,Paginated purchase-orders,api/purchase-orders,get,Admin,Implement GET /api/purchase-orders - List Paginated Purchase Orders,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD, implement the API endpoint to list paginated purchase orders. Deshio covers catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, ledgers. Order domain includes states (pending→confirmed→fulfilled|cancelled), assignment, notes/attachments, promos, taxes, fraud. Fulfillment involves shipments, inter-store dispatch with tracking, scan events, POD, and stock movements. Returns handle RMA, restock/scrap, refunds, exchanges. Payments include intent→capture/void, refunds, synchronization. Accounting uses transaction headers + ledger entries, reversals, reconciliation. Services cover service orders with lifecycle and profitability. Integrations include carriers, waybills, tracking, webhooks, notifications. Security features user/role/permission with multi-role, sessions, email verification, password reset, TOTP MFA, API keys. Observability includes audit_event, logs, PII masking, health/metrics, queues, caching. Middleware encompasses TLS/HSTS, CORS, RequestId, JSON limits, versioned negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC, branch scope, tenancy, throttles, idempotency, sanitizer, domain guards, upload guards, webhook signatures, cache headers. Reporting covers revenue/orders/units, LTV/AOV, returns, SLA, dispatch, inventory aging, price history, cycle accuracy, promo impact, activity. State machines ensure legal transitions for orders/items, dispatch, shipments, returns, payments, cycle counts; conflicts use RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups, feature flags, maintenance. Data in UTC, soft deletes, EAV attributes, polymorphic notes/attachments, strict referential links. Design supports deterministic admin assignment, safe reservation/consumption, consistent ledger posting.

This endpoint focuses on the purchase category, retrieving a paginated list of purchase orders, which likely integrate with vendors, inventory batches, and accounting ledgers for procurement and stock inflows.

## API Specifications

- **Category:** purchase
- **Title:** List Purchase-Orders
- **Description:** Paginated purchase-orders
- **Route:** api/purchase-orders
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint returns paginated list of purchase orders in JSON format
- [ ] Supports standard pagination parameters (e.g., page, per_page)
- [ ] Includes filtering/sorting options relevant to purchase orders (e.g., by vendor, status, date)
- [ ] Handles authentication and authorization for admin users only
- [ ] Returns appropriate HTTP status codes (200 for success, 401/403 for auth errors, 422 for validation)
- [ ] Integrates with state machines for order states if applicable
- [ ] Includes audit logging for endpoint access
- [ ] Passes unit/integration tests for happy path, edge cases, and errors
- [ ] Documentation updated with OpenAPI spec or similar
- [ ] Performance optimized for large datasets with proper indexing

## Technical Requirements

- Implement in Laravel using a dedicated controller (e.g., PurchaseOrderController@index)
- Define route in api.php with proper middleware stack: auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks for admin role, branch scope if applicable, throttles, input sanitizer
- Use Eloquent models for purchase orders, relating to vendors, products, inventory batches, and ledgers
- Pagination via Laravel's LengthAwarePaginator or similar, with meta for total/pages
- Input validation using Form Requests for query params (e.g., filters, pagination)
- Error handling with RFC7807 problem+json for conflicts/invalid states
- Soft deletes handled in queries; UTC timestamps
- Integration with observability: request-id, audit_event logging, caching/etag if read-heavy
- Tests: PHPUnit for controller, feature tests for full flow, mocking auth/RBAC
- Consider bulk/export capabilities if extending list functionality

## Authentication/Authorization Requirements

- Requires admin authentication via JWT, session, or API key
- RBAC check: User must have admin role/permission (ability: role↔perm, user_role multi-role)
- Enforce active user, email-verified, and 2FA (TOTP + backup codes) via middleware
- Branch scope if purchase orders are store-specific
- Optional tenancy isolation

## Expected Request/Response Format Considerations

- **Request:** GET /api/purchase-orders?page=1&per_page=20&filter[status]=pending&sort=created_at.desc
  - Query params: pagination (page, per_page), filters (vendor_id, status, date_range), search (q for autosuggest)
  - No request body
- **Response:** 200 OK with JSON
  {
    ""data"": [
      {
        ""id"": 1,
        ""vendor_id"": 123,
        ""status"": ""pending"",
        ""total_amount"": 1000.00,
        ""items"": [...],
        ""created_at"": ""2023-01-01T00:00:00Z"",
        // other fields: notes, attachments (polymorphic), ledger entries
      }
    ],
    ""meta"": {
      ""current_page"": 1,
      ""last_page"": 10,
      ""per_page"": 20,
      ""total"": 200
    }
  }
- Errors: 401 Unauthorized, 403 Forbidden (non-admin), 422 Unprocessable (invalid filters)
- Content negotiation: versioned, JSON only, with cache headers/etag

## Relevant Business Logic

- Purchase orders represent procurement from vendors, transitioning states (e.g., pending→confirmed→received) via state machines for legality
- Integrate with inventory for batch reservations/adjustments on receipt, ledger posting for financial movements
- Support attachments/notes, promos/taxes if applicable, fraud flags
- Ensure referential integrity with products/categories/vendors
- On list, compute derived fields like total_amount, aging if reporting-integrated
- Conflicts (e.g., invalid state filters) return problem+json
- Align with overall ERP: stock movements transactional, accounting reversals possible, audit for compliance"
173,purchase,Create Purchase-Order,Create purchase-order,api/purchase-orders,post,Admin,Implement Create Purchase-Order API Endpoint,"## Overview

This issue covers the implementation of the Create Purchase-Order API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint allows admins to create a new purchase order, likely involving vendors, products, quantities, and integration with inventory and accounting ledgers for incoming stock.

## API Specifications

- **Category:** purchase
- **Title:** Create Purchase-Order
- **Description:** Create purchase-order
- **Route:** api/purchase-orders
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST /api/purchase-orders endpoint in the Laravel controller
- [ ] Ensure the endpoint requires Admin authentication and authorization via RBAC
- [ ] Validate incoming request data for required fields (e.g., vendor_id, items with product_id and quantity, store/branch assignment)
- [ ] Create the purchase order entity with initial state (e.g., pending) and link to relevant core entities like vendors, products, and inventory batches
- [ ] Trigger business logic for reservations or ledger entries if applicable for incoming purchases
- [ ] Handle state machine transitions for the purchase order lifecycle
- [ ] Return a successful response with the created purchase order details (201 Created)
- [ ] Implement error handling for validation failures, unauthorized access, or business rule violations using RFC7807 problem+json format
- [ ] Integrate with middleware stack including auth, RBAC checks, input sanitization, and idempotency
- [ ] Write unit tests for controller logic, validation, and business rules
- [ ] Write integration tests for end-to-end flow including database interactions and ledger posting
- [ ] Ensure observability: log audit events, request IDs, and metrics for the endpoint
- [ ] Document the API in OpenAPI/Swagger with request/response schemas

## Technical Requirements

- Use Laravel framework: Define route in api.php, create or extend PurchaseOrderController with store() method
- Implement input validation using Form Requests or Validator facade, covering fields like vendor_id (required, exists in vendors table), items array (with product_id, quantity, unit_price), expected_delivery_date, notes
- Ensure transactional database operations for creating purchase_order, purchase_order_items, and any linked ledger_entries or inventory adjustments
- Follow Deshio patterns: Use Eloquent models with soft deletes, UTC timestamps, and polymorphic relations for notes/attachments
- Integrate with existing services: Link to vendor entity, product catalog with attributes/barcodes/pricing, store/branch for assignment
- Apply domain guards for purchase/reservation/override if relevant to incoming stock
- Handle bulk creation if multiple items; support attachments upload with mime guarding
- For response: Return JSON with purchase_order data, including ID, state, total_amount, and embedded items/vendor details; use etag/caching headers
- Error responses: 401 Unauthorized, 403 Forbidden (non-Admin), 422 Unprocessable Entity for validation, 409 Conflict for idempotency or business conflicts

## Authentication/Authorization Requirements

- Authentication: JWT, session, or API key as per middleware
- Authorization: Restrict to Admin users via RBAC (user_role with admin role/permission for 'create-purchase-order')
- Additional checks: Active user, email-verified, 2FA if enabled, branch scope for store-specific purchases
- Audit all access with audit_event logging

## Expected Request/Response Format Considerations

- **Request:** JSON body, e.g., {""vendor_id"": 1, ""store_id"": 1, ""items"": [{""product_id"": 123, ""quantity"": 10, ""unit_price"": 5.99}], ""expected_delivery_date"": ""2023-12-01"", ""notes"": ""Urgent order""}
- Content negotiation: Accept application/json, versioned API (e.g., /v1/api/purchase-orders)
- Validation: Required fields, numeric quantities/prices, date formats, referential integrity (vendor/product/store exist)
- **Response (Success):** 201 Created, JSON: {""id"": 456, ""vendor"": {""id"":1, ""name"":""Vendor Name""}, ""state"": ""pending"", ""total_amount"": 59.90, ""items"": [...], ""created_at"": ""2023-11-01T00:00:00Z""}
- **Response (Error):** RFC7807 format, e.g., {""type"": ""https://example.com/probs/validation-error"", ""title"": ""Validation Error"", ""status"": 422, ""detail"": ""Invalid quantity"", ""violations"": [...]}
- Support idempotency keys in headers to prevent duplicate creations

## Relevant Business Logic

- Purchase orders initiate procurement from vendors, updating inventory ledgers upon receipt (future endpoints)
- Use state machines for transitions (e.g., pending → confirmed → received | cancelled)
- Calculate totals with taxes/promos if applicable; post to accounting transaction headers + ledger_entry lines
- Ensure deterministic assignment to stores/branches; support batch-centric inventory for incoming items
- Integrate with promotions/pricing overrides; flag for fraud if anomalous
- On creation, reserve or anticipate stock movements; trigger notifications (email/SMS) via templates
- Maintain strict referential integrity across junctions (e.g., purchase_order ↔ vendor, purchase_order_item ↔ product)
- Comply with overall design: Consistent ledger posting on stock/financial events, PII masking if customer data involved (unlikely for purchases)"
174,purchase,Get Purchase-Order,Get by id,api/purchase-orders/{id},get,Admin,Implement GET /api/purchase-orders/{id} for Purchase Orders,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the 'Get Purchase-Order' API endpoint. This endpoint retrieves a specific purchase order by ID, supporting core entities like product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. While the order domain focuses on sales (order/order_item states: pending→confirmed→fulfilled|cancelled), purchase orders handle procurement from vendors. Fulfillment involves shipments, inter-store dispatch with tracking and POD, transactional stock movements. Returns via RMA, payments with intent→capture/void and refunds, accounting with transaction headers + ledger_entry lines, reversals, reconciliation/export. Services, integrations (carriers, webhooks, notifications), security (user/role/permission, JWT/session/API key, TOTP MFA), observability (audit_event, logs, PII masking), middleware (TLS/HSTS, CORS, auth, RBAC, throttles, idempotency, input sanitizer), reporting/analytics (revenue, LTV/AOV, inventory aging, promo impact), state machines for transitions, bulk import/export, search, attachments, backups, EAV for attributes, polymorphic notes/attachments, strict referential links, deterministic assignment, safe reservation/consumption, consistent ledger posting. Data in UTC, soft deletes, feature flags, system maintenance.

This endpoint falls under the 'purchase' category, enabling admin users to fetch purchase order details by ID for procurement management.

## API Specifications

- **Category:** purchase
- **Title:** Get Purchase-Order
- **Description:** Get by id
- **Route:** api/purchase-orders/{id}
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint returns the full purchase order details by ID, including related entities like vendor, items, pricing, and status
- [ ] Handles non-existent ID with 404 error in RFC7807 problem+json format
- [ ] Supports soft deletes; does not return deleted records unless specified
- [ ] Integrates with state machines for order status legality
- [ ] Includes audit trail if applicable (e.g., audit_event for retrieval)
- [ ] Applies branch scope and RBAC checks for admin access
- [ ] Returns data in UTC with proper serialization (e.g., dates, EAV attributes)
- [ ] Add unit/integration tests covering success, error cases, auth failures
- [ ] Document the endpoint in API docs with examples
- [ ] Ensure compatibility with middleware stack (auth, validation, throttling, idempotency)

## Technical Requirements

- Implement in Laravel controller (e.g., PurchaseOrderController@show) and define route in api.php with {id} parameter binding
- Use Eloquent model for PurchaseOrder with relationships (e.g., hasMany items, belongsTo vendor, polymorphic notes/attachments)
- Input validation: Ensure {id} is a valid UUID or integer via route model binding and validator
- Proper error handling: Use try-catch for database errors, return standardized errors (e.g., 422 for invalid ID, 403 for unauthorized)
- Response: JSON with purchase order data, including nested resources (items with product/category links, pricing with overrides/promos, inventory batches if applicable)
- Follow Deshio standards: Request ID, caching/ETag, content-negotiation (versioned), locale/tz handling, PII masking if customer data involved
- Integrate with ledger posting if retrieval triggers any accounting sync
- Use queues/caching where performance-critical (e.g., eager load relations to avoid N+1)
- Security: Enforce admin role/permission via middleware (RBAC & permission checks, active user, email-verified, 2FA if enabled)

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Middleware chain: auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks (e.g., 'view-purchase-orders' permission), branch scope
- Reject unauthorized access with 401/403, including domain guards for purchase/fraud if applicable
- Optional tenancy if multi-tenant setup

## Expected Request/Response Format Considerations

- **Request:** GET /api/purchase-orders/{id} (no body; {id} as path param, e.g., UUID)
- **Response (200 OK):** JSON object with purchase order fields (id, vendor_id, store_id, status, items array with product/quantity/price, total, notes/attachments, created_at/updated_at in UTC, EAV attributes)
  Example:
  {
    ""data"": {
      ""id"": ""uuid"",
      ""vendor"": { ... },
      ""items"": [ { ""product"": { ... }, ""quantity"": 10, ""price"": 100.00 } ],
      ""status"": ""pending"",
      ""total"": 1000.00
    }
  }
- **Errors:** RFC7807 problem+json, e.g., 404: { ""type"": ""https://example.com/errors/not-found"", ""title"": ""Not Found"", ""detail"": ""Purchase order not found"" }
- Headers: Include ETag for caching, X-Request-Id, rate limiting

## Relevant Business Logic

- Purchase orders manage procurement: states similar to sales orders (pending→confirmed→fulfilled|cancelled), assignment to store/branch, notes/attachments, taxes, potential fraud flag
- Link to inventory for incoming stock (batch-centric reservations/adjustments), vendor catalog/products with attributes/media/barcodes/pricing/promos
- On retrieval, ensure referential integrity (strict links to junctions), handle soft deletes
- State machine validates status; conflicts return problem+json
- Sync with accounting ledger on fulfillment (transaction headers + entries for stock/financial movements)
- Support integrations (e.g., carrier rates if shipped), notifications (email/SMS templates)
- Analytics tie-in: Track purchase performance, vendor reliability, inventory aging from purchases
- Ensure deterministic admin assignment, safe stock consumption on receipt"
175,purchase,Update Purchase-Order,Update by id,api/purchase-orders/{id},put,Admin,Implement Update Purchase-Order API Endpoint (PUT /api/purchase-orders/{id}),"## Overview

This GitHub issue is for implementing the 'Update Purchase-Order' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs built over a normalized ERD. The system covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, and fraud flags. Fulfillment involves shipments, inter-store dispatches with tracking and scan events. Returns handle RMAs, restocking, refunds, and exchanges. Payments manage intents, captures, voids, refunds, and order synchronization. Accounting uses transaction headers and ledger entries for movements, reversals, and reconciliation. Services include service orders with lifecycle and profitability. Integrations cover carriers, waybills, rates, tracking, webhooks, and notifications. Security features user/role/permission with multi-role support, sessions, email verification, password reset, TOTP MFA, API keys. Observability includes audit events, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC/permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures, cache headers. Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines ensure legal transitions for orders, dispatches, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, strict referential links. Design supports deterministic admin assignment, safe reservation/consumption, consistent ledger posting.

The endpoint allows updating a purchase order by ID, fitting into the purchase category for procurement-related operations, likely involving vendors, inventory batches, and ledger postings.

## API Specifications

- **Category:** purchase
- **Title:** Update Purchase-Order
- **Description:** Update by id
- **Route:** api/purchase-orders/{id}
- **HTTP Method:** put
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the PUT endpoint to update purchase order by ID
- [ ] Validate input data, including required fields like order items, vendor, quantities, and status
- [ ] Ensure updates respect state machine transitions (e.g., pending→confirmed) and business rules for inventory reservations/adjustments
- [ ] Handle authentication and authorization for Admin users only, with RBAC permission checks
- [ ] Return the updated purchase order in JSON format on success (HTTP 200)
- [ ] Return appropriate errors (e.g., 404 for not found, 422 for validation, RFC7807 problem+json for conflicts) with proper error handling
- [ ] Integrate with audit logging, ledger postings for any stock/financial changes, and soft deletes if applicable
- [ ] Write unit and integration tests covering happy path, validation errors, unauthorized access, and state transitions
- [ ] Ensure idempotency and throttling support via middleware
- [ ] Document the endpoint in API specs, including request/response schemas

## Technical Requirements

- Use Laravel framework: Create a controller (e.g., PurchaseOrderController@update) and define the route in api.php with {id} parameter binding
- Implement input validation using Form Requests or Validator, covering fields like order items (quantities, batches), vendor_id, store_id, status, notes/attachments, taxes, promos
- Apply middleware stack: auth (JWT/API key), RBAC (admin role/permission), branch scope, input sanitizer, domain guards (e.g., for inventory/reservation/promo)
- Handle business logic: Use state machines for purchase order transitions; trigger ledger entries for value changes; polymorphic attachments if updated; ensure referential integrity with vendors/inventory
- Request format: JSON body with partial updates (e.g., {""status"": ""confirmed"", ""items"": [{...}]}); support EAV attributes if applicable
- Response format: JSON of updated purchase order (include id, status, items, totals, timestamps); use ETag/caching headers; problem+json for errors
- Database: UTC storage, soft deletes; query by ID with eager loading for relations (e.g., items, vendor)
- Error handling: 404 if ID not found; 403 unauthorized; 409 conflicts (e.g., invalid state transition); log audit events
- Testing: PHPUnit tests for controller, validation, auth; feature tests for full flow; mock services for ledgers/notifications
- Observability: Add request-id tracing, queue jobs if async (e.g., notifications), metrics for endpoint performance

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have 'admin' role or specific permission (e.g., 'purchase-orders.update')
- Additional checks: Active user, email-verified, 2FA if enabled; branch scope to prevent cross-branch updates
- Reject if user lacks permission, returning 403 with problem+json

## Expected Request/Response Format Considerations

- **Request:** PUT /api/purchase-orders/{id} with JSON body (e.g., {""vendor_id"": 1, ""status"": ""confirmed"", ""items"": [{""product_id"": 123, ""quantity"": 10, ""batch_id"": null}]}); Content-Type: application/json; optional multipart for attachments
- **Response (Success):** 200 OK, JSON: {""id"": 456, ""status"": ""confirmed"", ""vendor"": {...}, ""items"": [...], ""total"": 1000.00, ""updated_at"": ""2023-...""}
- **Response (Error):** 4xx/5xx with problem+json: {""title"": ""Validation Error"", ""status"": 422, ""detail"": ""Invalid status transition"", ""type"": ""/errors/validation""}
- Versioning: Use content-negotiation (e.g., Accept: application/vnd.deshio.v1+json); locale/tz from headers
- Idempotency: Support Idempotency-Key header for safe retries

## Relevant Business Logic

- Updates must validate against ERD: Link to valid vendor/store; handle batch-centric inventory (reservations/adjustments on item updates)
- State machine: Enforce legal transitions (e.g., cannot update fulfilled order); conflicts trigger domain guards
- Financial/Stock Impact: On update, post ledger entries for price/quantity changes; synchronize with inventory ledgers; handle taxes/promos recalculations
- Integrations: If status changes to confirmed, trigger vendor notifications (email/SMS via templates); optional webhooks for purchase events
- Compliance: Mask PII in logs; audit all updates; support reversals if needed; ensure transactional consistency for stock movements
- Edge Cases: Partial updates (use merge); handle attachments polymorphically; prevent fraud flags or overrides without permission; bulk considerations if extending to multiple items"
176,purchase,Delete Purchase-Order,Delete by id,api/purchase-orders/{id},delete,Admin,Implement DELETE /api/purchase-orders/{id} Endpoint,"## Overview

This GitHub issue covers the implementation of the Delete Purchase-Order API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD. Core entities include product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain encompasses order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flags. Fulfillment involves shipments, inter-store dispatch with tracking and scan events. Returns handle RMA, receive/restock/scrap, refunds, exchanges. Payments manage intent→payment lifecycle, refunds, and synchronization. Accounting uses transaction headers + ledger_entry lines, reversals, reconciliation/export. Services include service/service_order with lifecycle and profitability. Integrations cover carriers, waybills/rates/tracking; webhooks; notification templates. Security features user/role/permission with abilities, sessions, email verification, password reset, TOTP MFA, API keys. Observability includes audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware stack: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines ensure legal transitions for orders, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links. Design supports deterministic admin assignment, safe reservation/consumption, consistent ledger posting.

This endpoint allows admins to delete a specific purchase order by ID, likely using soft deletes to maintain audit trails.

## API Specifications

- **Category:** purchase
- **Title:** Delete Purchase-Order
- **Description:** Delete by id
- **Route:** api/purchase-orders/{id}
- **HTTP Method:** delete
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint returns 204 No Content on successful deletion of a valid purchase order ID
- [ ] Endpoint returns 404 Not Found if the purchase order ID does not exist
- [ ] Endpoint returns 403 Forbidden if the user lacks admin permissions
- [ ] Soft delete is applied to the purchase order, preserving audit logs and referential integrity
- [ ] State machine validates that the purchase order is in a deletable state (e.g., not confirmed or fulfilled)
- [ ] Input validation ensures {id} is a valid UUID or integer
- [ ] Proper error handling with RFC7807 problem+json for conflicts or invalid states
- [ ] Unit and integration tests cover success, failure, and edge cases
- [ ] Documentation updated with endpoint details, including request/response examples
- [ ] Middleware applied: auth, RBAC, branch scope, throttles, idempotency
- [ ] Audit event logged for the deletion action
- [ ] Ledger entries reversed or marked if applicable to purchase order movements

## Technical Requirements

- Implement in Laravel: Add route to api.php, create or extend PurchaseOrderController with destroy method
- Use Eloquent model for PurchaseOrder with softDeletes trait
- Apply Request validation for {id} parameter (e.g., exists in purchase_orders table)
- Integrate state machine to check legality of deletion transition
- Handle related entities: Cascade soft deletes or detach associations (e.g., purchase_order_items, attachments, notes)
- Ensure transactional integrity for any stock or ledger impacts from reversal
- Response: No body for 204; use problem+json for errors (e.g., { ""type"": ""https://example.com/probs/state-invalid"", ""title"": ""Deletion not allowed"", ""detail"": ""Purchase order is confirmed"" })
- Testing: PHPUnit tests for controller, including mocked auth and state checks
- Observability: Log request-id, audit_event with user and target ID

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC check: User must have 'purchase-order.delete' permission or equivalent admin role
- Middleware: auth, active user, email-verified, 2FA (if enabled), RBAC & permission checks, branch scope (if purchase order scoped to branch)
- Optional: Tenancy isolation if multi-tenant setup

## Expected Request/Response Format Considerations

- **Request:** DELETE /api/purchase-orders/{id} (path param {id} as UUID/integer; no body expected, but support idempotency-key header if provided)
- **Success Response (204):** Empty body
- **Error Responses:** 400 Bad Request (invalid ID format), 403 Forbidden (insufficient perms), 404 Not Found (non-existent ID), 409 Conflict (invalid state), 422 Unprocessable Entity (validation fails)
- All responses in JSON; errors as RFC7807 problem+json
- Headers: Cache-Control: no-store; ETag if applicable; X-Request-Id echoed
- Versioned: Support content-negotiation for API version (e.g., Accept: application/vnd.deshio.v1+json)

## Relevant Business Logic

- Deletion should only succeed if purchase order is in pending/draft state; use state machine for validation
- Soft delete to comply with archival and audit requirements; do not hard delete to preserve referential integrity
- Trigger audit_event for deletion, including user, timestamp, and reason if provided
- If purchase order has associated inventory reservations or ledger entries, reverse them transactionally
- Prevent deletion if linked to shipments, payments, or returns; return conflict error
- Ensure UTC handling and locale/tz awareness in logs
- Integrate with domain guards for purchase/reservation/promo/override checks if relevant
- Post-deletion, update any related reports/analytics caches or triggers reindex if needed"
177,purchase,Receive Purchase,Receive PO to batch,api/purchase-orders/{id}/receive,post,Admin,Implement Receive Purchase API: Receive PO to Batch,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue covers implementing the 'Receive Purchase' API endpoint. This endpoint allows receiving a purchase order (PO) into inventory batches, supporting core entities like product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The endpoint integrates with order domain states, fulfillment (shipments, dispatches), returns (RMA), payments, accounting (transaction headers + ledger_entry lines), services, integrations (carriers, webhooks, notifications), security (user/role/permission, sessions, MFA, API keys), observability (audit_event, logs, PII masking), middleware (TLS, CORS, auth, RBAC, throttles, etc.), reporting/analytics, state machines for transitions, bulk operations, and data standards (UTC, soft deletes, EAV, polymorphic relations). Design ensures deterministic admin assignment, safe reservation/consumption, and consistent ledger posting on stock/financial events.

The endpoint receives a PO to update inventory batches, handling stock movements transactionally with audit trails, error handling via RFC7807 problem+json, and state machine-driven legality checks.

## API Specifications

- **Category:** purchase
- **Title:** Receive Purchase
- **Description:** Receive PO to batch
- **Route:** api/purchase-orders/{id}/receive
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint handles POST requests to receive a specific purchase order into inventory batches
- [ ] Validates PO existence, state (e.g., pending/confirmed), and admin permissions
- [ ] Processes receipt: creates/updates batches, adjusts inventory ledgers, handles reservations/adjustments
- [ ] Supports partial/complete receipts with quantities, batch details, and quality checks (e.g., scrap)
- [ ] Integrates with accounting: posts ledger entries for stock/financial movements, supports reversals
- [ ] Triggers audits, notifications (email/SMS), and webhooks if applicable
- [ ] Handles errors: invalid PO, insufficient permissions, conflicts via state machines, using RFC7807 problem+json
- [ ] Includes idempotency support via middleware
- [ ] Adds unit/integration tests covering success, edge cases (partial receipt, over-receipt), and errors
- [ ] Documentation updated with request/response examples and business rules
- [ ] Endpoint adheres to middleware stack: auth (JWT/session/API key), RBAC, branch scope, input sanitizer, etc.

## Technical Requirements

- Implement in Laravel: Define route in api.php, create controller method (e.g., PurchaseOrderController@receive)
- Use request validation: Custom Request class for parameters like quantities, batch_ids, received_date, notes
- Business logic: Leverage state machines for PO transitions (e.g., pending → received); transactional DB operations for inventory updates, ledger postings
- Integrate with ERD: Update purchase_order, inventory_batch, stock_ledger; polymorphic attachments/notes if needed
- Error handling: Throw ValidationException, or custom exceptions mapped to problem+json; soft deletes for archival
- Observability: Generate audit_event, request-id; PII masking; health/metrics integration
- Reporting: Ensure receipt data feeds into analytics (e.g., inventory aging, valuation)
- Caching/Performance: Use ETag, queues for heavy ops like notifications; versioned API

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC checks: User must have 'purchase.receive' permission via role→permission mapping; multi-role support
- Additional guards: Active user, email-verified, 2FA (TOTP + backup codes), branch scope (if multi-tenant)
- Middleware chain: Auth → ActiveUser → EmailVerified → TwoFactor → RBAC/Permission → BranchScope → Throttles → Idempotency

## Expected Request/Response Format Considerations

- **Request:** JSON body with fields like {""quantities"": [{""product_id"": 1, ""received_qty"": 10, ""batch_id"": null, ""condition"": ""good""}], ""received_date"": ""2023-01-01T00:00:00Z"", ""notes"": ""Received in full"", ""attachments"": [file_ids]}
  - Validate: Required PO id in path, quantities match PO items, UTC timestamps, mime types for attachments
  - Optional: Partial receipts, over/under tolerances, serial/batch tracking

- **Response:** 200 OK on success with updated PO details {""id"": 123, ""status"": ""received"", ""received_items"": [...], ""ledger_entries"": [...]}
  - 201 Created if new batches generated
  - 400 Bad Request for validation errors
  - 403 Forbidden for auth/RBAC failures
  - 404 Not Found for invalid PO
  - 409 Conflict for state machine violations
  - All errors in problem+json format; successful responses with cache headers
  - Content negotiation: JSON, versioned (e.g., /v1/)

## Relevant Business Logic

- Receipt triggers: Inventory batch creation/update (batch-centric), stock reservations/consumption, cycle count implications
- Transactional: Atomic updates across purchase_order, order_items, inventory, ledgers; rollback on failure
- State transitions: PO from 'confirmed' to 'received'/'partially_received'; invalid transitions return errors
- Integrations: Post to accounting ledger (headers + lines), trigger shipments/dispatches if needed, update vendor/pricing
- Edge cases: Handle returns/exchanges linkages, promotions/taxes impacts, fraud flags, low stock alerts
- Compliance: All events audited; data in UTC; referential integrity enforced; supports bulk receipts via iterations
- Deterministic: Safe stock movements, consistent postings; optional EAV for custom receipt attributes"
178,purchase,Cancel Purchase,Cancel PO,api/purchase-orders/{id}/cancel,post,Admin,Implement Cancel Purchase Order API Endpoint,"## Overview

This GitHub issue is for implementing the 'Cancel Purchase' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD that covers catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flags. Fulfillment involves shipments and inter-store dispatches with tracking and stock movements. Returns handle RMAs, refunds, exchanges. Payments manage intents, captures, voids, refunds. Accounting uses transaction headers and ledger entries for movements, reversals, reconciliations. Services include service orders with lifecycle and profitability. Integrations cover carriers, webhooks, notifications. Security features user/role/permission with multi-role support, sessions, email verification, password reset, TOTP MFA, API keys. Observability includes audit events, logs, PII masking, health/metrics, queues, caching. Middleware encompasses TLS/HSTS, CORS, auth (JWT/session/API key), RBAC, branch scope, throttles, idempotency, sanitizers, domain guards, webhook signatures. Reporting/analytics cover revenue, LTV/AOV, returns, inventory aging, promo impact. State machines ensure legal transitions for orders, dispatches, etc., with RFC7807 errors. APIs support bulk operations, search, attachments, reindex, backups, feature flags. Data uses UTC, soft deletes, EAV for attributes, polymorphic relations, strict referential integrity. Design supports deterministic assignments, safe reservations, consistent ledger posting.

The endpoint allows admins to cancel a purchase order (PO), integrating with inventory, accounting, and state machine logic to handle cancellations legally, update statuses, reverse any commitments, and log audits.

## API Specifications

- **Category:** purchase
- **Title:** Cancel Purchase
- **Description:** Cancel PO
- **Route:** api/purchase-orders/{id}/cancel
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint handles POST requests to cancel a specific purchase order by ID
- [ ] Validates that the PO exists and is in a cancellable state (e.g., pending or confirmed, per state machine)
- [ ] Updates PO status to 'cancelled' and triggers related business logic (e.g., reverse reservations, ledger reversals)
- [ ] Returns success response with updated PO details or appropriate error if invalid
- [ ] Implements proper error handling for non-existent PO, unauthorized access, or illegal state transition (RFC7807 problem+json)
- [ ] Includes unit/integration tests covering happy path, edge cases (e.g., already cancelled, fulfilled PO), and auth failures
- [ ] Adds API documentation in OpenAPI/Swagger format
- [ ] Ensures compatibility with middleware (auth, RBAC, throttles, idempotency)
- [ ] Logs audit events for cancellation actions
- [ ] Handles soft deletes and referential integrity for related entities (e.g., PO items, vendor links)

## Technical Requirements

- Use Laravel framework: Define route in api.php, create dedicated controller method (e.g., PurchaseOrderController@cancel)
- Implement input validation using Form Requests or Validator facade (e.g., require valid {id} as UUID/int)
- Leverage Eloquent models for PurchaseOrder entity, assuming relations to vendors, items, inventory batches
- Integrate with state machine for legal transitions; if invalid, throw ValidationException with problem+json
- Use transactions for atomicity: Update PO status, reverse ledger entries, release reservations, notify via webhooks if applicable
- Apply middleware stack: Auth (JWT/API key), Admin role check via RBAC, branch scope if PO is store-specific, idempotency for retry safety
- Response: JSON with HTTP 200 for success (include cancelled PO summary), 404 for not found, 403 for unauthorized, 422 for validation/state errors
- Caching/ETag: Invalidate any related caches (e.g., vendor outstanding POs)
- Queues: Offload heavy tasks like notifications or ledger postings to jobs
- Testing: PHPUnit tests with factories for POs in various states, mock state machine, assert DB changes and responses

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC check: User must have 'purchase.cancel' permission (or equivalent role→permission mapping)
- Active user validation, email-verified, optional 2FA
- Branch scope: If PO is assigned to a branch, ensure user has access to that branch
- Idempotency: Use request ID to prevent duplicate cancellations

## Expected Request/Response Format Considerations

- **Request:** POST to /api/purchase-orders/{id}/cancel
  - Body: Optional JSON payload for reason/notes (e.g., {""reason"": ""Vendor delay"", ""notes"": ""...""}), or empty for simple cancel
  - Headers: Authorization, Content-Type: application/json, X-Request-Id for idempotency
  - Validation: {id} must be valid PO identifier; if body provided, validate reason as string (max 255 chars)

- **Response:**
  - Success (200): {""data"": {""id"": ""uuid"", ""status"": ""cancelled"", ""cancelled_at"": ""UTC timestamp"", ""reason"": ""...""}, ""message"": ""Purchase order cancelled successfully""}
  - Error (422): RFC7807 problem+json, e.g., {""title"": ""Invalid State"", ""detail"": ""PO cannot be cancelled once fulfilled"", ""type"": ""https://problems.deshio.com/states/invalid-transition""}
  - Not Found (404): Standard Laravel error JSON
  - Unauthorized (403): {""message"": ""Admin access required""}

- All timestamps in UTC; use content-negotiation for versioned responses; sanitize inputs to prevent injection

## Relevant Business Logic

- State Machine: Only allow cancellation from states like 'pending' or 'confirmed'; block if 'fulfilled', 'cancelled', or 'in-progress' (dispatch/shipment initiated)
- Inventory Impact: Release any reserved batches/stock for PO items; post reversal ledger entries for committed value
- Accounting: Create reversal transaction header with ledger lines negating original PO commitments; ensure reconciliation
- Notifications: Trigger email/SMS to vendor/buyer via templates; webhook delivery if integrated
- Audits: Log audit_event with user ID, PO ID, before/after states, reason; mask PII if applicable
- Relations: Update polymorphic notes/attachments if cancellation adds them; handle EAV attributes for custom PO fields
- Conflicts: If concurrent updates (e.g., via cycle count or dispatch), use optimistic locking or return conflict error
- Integrations: If carrier/waybill linked, void or notify; sync with promotions/pricing overrides if affected
- Soft Deletes: Mark related items as soft-deleted if needed, but keep PO for archival/reporting
- Reporting: Update aggregates for vendor performance, inventory aging, revenue projections"
179,service,List Services,Paginated services,api/services,get,Employee,Implement GET /api/services - List Paginated Services,"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This issue is for implementing the 'List Services' API endpoint in the service category, which provides paginated access to services in the Deshio ERP system. Services include service/service_order with lifecycle and profitability, integrated with other domains like orders, inventory, and payments.

## API Specifications

- **Category:** service
- **Title:** List Services
- **Description:** Paginated services
- **Route:** api/services
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET /api/services endpoint to return paginated list of services
- [ ] Support pagination parameters (e.g., page, per_page) with default sensible values
- [ ] Ensure response includes relevant service fields like id, name, description, lifecycle status, profitability metrics, and relations to service_orders
- [ ] Apply proper filtering, sorting, and searching if applicable based on service domain
- [ ] Handle soft deletes by excluding archived services unless specified
- [ ] Integrate with state machines for service lifecycle validation
- [ ] Add unit and integration tests covering happy path, edge cases (e.g., empty list, large pagination), and error scenarios
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger)
- [ ] Verify compliance with middleware stack including auth, RBAC, and caching/etag

## Technical Requirements

- Use Laravel controller (e.g., ServiceController@list) and define route in api.php with proper versioning and content-negotiation
- Implement pagination using Laravel's LengthAwarePaginator or similar, with UTC timestamps and EAV attribute handling for service features
- Leverage Eloquent models for Service entity, including relations to service_orders, polymorphic notes/attachments, and junctions to other entities like products/vendors
- Apply input validation for query parameters (e.g., page, per_page, filters) using Form Requests or Validator
- Use proper error handling with RFC7807 problem+json for conflicts, including state machine legality checks
- Ensure transactional consistency for any related ledger postings or inventory movements if services impact stock/finances
- Integrate with observability: audit_event logging, request-id tracing, PII masking in responses
- Support bulk/search aspects if extended, but focus on basic paginated list
- Use queues/caching where appropriate for performance, with etag for conditional requests

## Authentication/Authorization Requirements

- Require Employee authentication via JWT/session/API key
- Enforce RBAC: Users must have permission to view services (e.g., role↔perm mapping for 'view_service')
- Apply branch scope if services are store-specific
- Include middleware for active user, email-verified, 2FA (TOTP MFA + backup codes), and throttles
- Optional tenancy isolation if multi-tenant setup

## Expected Request/Response Format Considerations

- **Request:** GET /api/services?page=1&per_page=20&filter[status]=active&sort=name (JSON API compliant, with query params for pagination/filtering/sorting)
- **Response:** 200 OK with JSON array of services, e.g., {""data"": [{id: 1, name: ""Service Name"", description: ""..."", status: ""active"", profitability: {...}, service_orders: [...]}, ""meta"": {""current_page"": 1, ""last_page"": 10, ...}} – Use RFC7807 for errors (e.g., 401 Unauthorized, 403 Forbidden, 422 Validation Error)
- Ensure responses use versioned content-negotiation, locale/tz handling, and cache headers
- Mask PII in service/customer-related data

## Relevant Business Logic

- Services are part of the service domain with lifecycle (e.g., pending→confirmed→fulfilled) driven by state machines; list only valid states
- Include profitability calculations based on associated service_orders, payments, and accounting ledger_entries
- Handle relations to core entities like products/categories/vendors, inventory batches, and promotions
- Support integrations like notifications (email/SMS templates) and reporting (e.g., service revenue/activity analytics)
- Ensure deterministic handling for assignments, reservations, and ledger postings on service events
- Conflicts (e.g., invalid state transitions) return problem+json details"
180,service,Create Service,Create service,api/services,post,Admin,Implement Create Service API Endpoint (POST /api/services),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue focuses on implementing the 'Create Service' API endpoint. Deshio handles core entities like product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flags. Fulfillment covers shipments, inter-store dispatch with tracking and scan events. Returns involve RMA with receive/restock/scrap, refunds, exchanges. Payments manage intent→capture/void, refunds, and synchronization. Accounting uses transaction headers + ledger entries for movements, reversals, reconciliation/export. Services include service/service_order with lifecycle and profitability. Integrations handle carriers, waybills, rates, tracking, webhooks, notifications. Security features user/role/permission, sessions, email verification, password reset, TOTP MFA, API keys. Observability includes audit_event, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware encompasses TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines ensure legality of transitions for orders, items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links. Design enables deterministic admin assignment, safe reservation/consumption, consistent ledger posting.

This endpoint allows admins to create a new service entity, which is part of the service domain supporting service/service_order with lifecycle management and profitability calculations.

## API Specifications

- **Category:** service
- **Title:** Create Service
- **Description:** Create service
- **Route:** api/services
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST /api/services endpoint to create a new service record
- [ ] Ensure the endpoint requires Admin authentication and performs RBAC/permission checks
- [ ] Validate input data according to service entity schema (e.g., required fields like name, description, pricing)
- [ ] Handle successful creation by returning the created service with appropriate HTTP 201 status
- [ ] Implement error handling for validation failures, unauthorized access, and conflicts using RFC7807 problem+json
- [ ] Integrate with state machines if applicable for initial service lifecycle state
- [ ] Ensure audit logging for the creation event
- [ ] Write unit and integration tests covering happy path, validation errors, auth failures, and edge cases
- [ ] Document the endpoint in API specs with request/response examples
- [ ] Verify compatibility with middleware stack (e.g., auth, throttling, input sanitization)

## Technical Requirements

- Use Laravel framework: Define route in api.php, create a dedicated controller method (e.g., ServiceController@store)
- Implement input validation using Form Requests or Validator facade, covering service attributes (e.g., EAV for custom fields)
- Persist to database with soft deletes enabled; use UTC timestamps
- Trigger any related events, such as audit_event logging, notification webhooks if configured, and ledger posting for profitability setup
- Apply domain guards for service creation (e.g., check branch scope, prevent duplicates)
- Support polymorphic attachments/notes if service allows
- Ensure idempotency for repeated requests via unique identifiers
- Integrate with caching/etag for response optimization
- Handle file uploads (e.g., service media) with mime type guards

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce active user, email-verified, and 2FA checks via middleware
- RBAC: User must have role/permission allowing service creation (e.g., 'create-service' ability)
- Branch scope: Restrict to user's assigned branches if multi-tenancy/branching applies
- Reject unauthorized requests with 401/403 status and problem+json details

## Expected Request/Response Format Considerations

- **Request:** JSON body with service details, e.g., {""name"": ""string"", ""description"": ""string"", ""pricing"": {...}, ""attributes"": {...} (EAV), ""branch_id"": integer}
  - Use content-negotiation for JSON input; apply locale/tz middleware
  - Support bulk creation if extended, but focus on single for now
  - Sanitize inputs and limit JSON size

- **Response:** On success (201 Created): JSON of created service, e.g., {""id"": integer, ""name"": ""string"", ..., ""created_at"": ""UTC datetime""} with ETag header
  - On error (400/401/403/409): RFC7807 problem+json, e.g., {""title"": ""Validation Error"", ""detail"": ""Name is required"", ""status"": 400}
  - Include request-id in all responses for observability

## Relevant Business Logic

- Service creation initializes a service/service_order lifecycle (e.g., start in 'pending' state via state machine)
- Calculate initial profitability based on pricing/promotions; post to accounting ledger if financial
- Link to related entities like categories/vendors if applicable
- Apply fraud flags or reservations if service involves inventory
- Ensure referential integrity with strict links (e.g., to branch/store)
- Trigger notifications (email/SMS) via templates if creation warrants it
- Support feature flags for optional behaviors (e.g., enable/disable certain attributes)
- Handle conflicts (e.g., duplicate service name per branch) with state machine validation"
181,service,Get Service,Get by id,api/services/{id},get,Employee,Implement GET /api/services/{id} for Service Retrieval,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue covers implementing the 'Get Service' endpoint. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint retrieves a specific service by its ID, aligning with the service domain which handles service/service_order lifecycles and profitability calculations.

## API Specifications

- **Category:** service
- **Title:** Get Service
- **Description:** Get by id
- **Route:** api/services/{id}
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint returns a single service object when valid ID is provided
- [ ] Endpoint handles non-existent ID with appropriate 404 error (RFC7807 problem+json)
- [ ] Authentication requires Employee role with RBAC permission checks
- [ ] Response includes service details, lifecycle state, and related profitability data
- [ ] Input validation ensures {id} is a valid UUID or integer
- [ ] Unit and integration tests cover success, error, auth failure, and permission denial cases
- [ ] Middleware stack applied: auth, RBAC, request-id, etc.
- [ ] Soft-deleted services are not returned; use withTrashed if needed for admin
- [ ] Audit event logged for access
- [ ] Response respects caching/etag and branch scope if applicable

## Technical Requirements

- Implement in Laravel controller (e.g., ServiceController@show)
- Define route in api.php with middleware groups for auth and permissions
- Use Eloquent model for Service with relationships (e.g., service_orders, profitability metrics)
- Apply state machine checks if service lifecycle affects visibility
- Input validation via FormRequest or route model binding
- Error handling: 404 for not found, 403 for unauthorized, 422 for invalid input
- Response serialization using API resources for consistent JSON structure
- Ensure UTC handling and PII masking in response
- Integrate with observability: log requests, metrics for endpoint performance

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT/session/API key
- RBAC: User must have role/permission allowing service read access (e.g., 'service.view')
- Additional checks: active user, email-verified, 2FA if enabled, branch scope for multi-branch services
- Use middleware: auth, active-user, email-verified, 2fa, rbac-permission, branch-scope

## Expected Request/Response Format Considerations

- **Request:** GET /api/services/{id} (no body; {id} path param, validated as required/UUID or integer)
- **Response (200 OK):** JSON object with service data, e.g., {
  ""data"": {
    ""id"": ""uuid"",
    ""name"": ""Service Name"",
    ""description"": ""..."",
    ""lifecycle_state"": ""active"",
    ""profitability"": {...},
    ""created_at"": ""UTC timestamp"",
    ""updated_at"": ""UTC timestamp"",
    ""relationships"": {...} // e.g., service_orders
  }
}
- **Error Responses:** RFC7807 problem+json, e.g., 404: {""type"": ""https://example.com/probs/not-found"", ""title"": ""Service not found"", ""status"": 404}
- Content negotiation: JSON only, versioned if applicable, with ETag for caching
- Include links for related resources (e.g., self, service_orders)

## Relevant Business Logic

- Retrieve service from database, including soft deletes consideration (default exclude trashed)
- Apply service lifecycle: Ensure state machine allows view (e.g., not in invalid transition)
- Calculate/load profitability on-the-fly or via accessor if tied to service_orders
- Handle relationships: Eager load service_orders for efficiency
- Enforce domain guards: Prevent access if fraud flag or other conflicts
- Post access: Log audit_event for compliance; trigger notifications if service state requires (e.g., via webhooks)
- Integrate with reporting: Endpoint usage contributes to activity analytics
- Ensure transactional consistency if service links to inventory/orders/payments"
182,service,Update Service,Update by id,api/services/{id},put,Admin,Implement Update Service API Endpoint (PUT /api/services/{id}),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD, this issue covers implementing the 'Update Service' API endpoint. Deshio handles core entities like product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.

Order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment covers shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint allows updating a service by its ID, fitting into the service domain which includes service/service_order with lifecycle and profitability.

## API Specifications

- **Category:** service
- **Title:** Update Service
- **Description:** Update by id
- **Route:** api/services/{id}
- **HTTP Method:** put
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the PUT /api/services/{id} endpoint to update a service record by ID
- [ ] Ensure the endpoint requires Admin authentication and proper RBAC checks
- [ ] Add input validation for update fields, handling partial updates where applicable
- [ ] Implement proper error handling, including 404 for non-existent IDs and RFC7807 problem+json for conflicts or invalid states
- [ ] Write unit and integration tests covering success, validation failures, auth errors, and state machine transitions
- [ ] Verify integration with service lifecycle, ensuring updates respect state machines and trigger necessary events (e.g., audit logs, notifications)
- [ ] Confirm soft deletes and UTC handling for updated timestamps
- [ ] Test for idempotency and middleware compliance (e.g., throttling, sanitization)

## Technical Requirements

- Use Laravel controller and routes: Define in api.php routes file with resource routing or explicit PUT route
- Implement in a dedicated ServiceController or similar, using Eloquent models for service entity
- Input validation: Use Form Requests or Validator for fields like name, description, price, status, etc.; support partial updates via merge or fill
- Proper error handling: Return JSON responses with appropriate HTTP codes; use exceptions for auth/perm failures
- Database: Ensure updates use transactions if involving related entities (e.g., service_order); handle EAV attributes if applicable
- Middleware: Apply auth, RBAC, branch scope, input sanitizer, and domain guards
- Observability: Log audit_event for updates; include request-id and PII masking
- State machines: Validate update against service lifecycle transitions

## Authentication/Authorization Requirements

- Requires Admin role with specific permissions for service updates (e.g., 'service.update')
- Enforce via middleware: auth (JWT/session/API key), active user, email-verified, 2FA if enabled, RBAC & permission checks
- Branch scope: Ensure admin has access to the service's associated branch/store
- Optional tenancy if multi-tenant setup is active

## Expected Request/Response Format Considerations

- **Request:** JSON body with updatable fields (e.g., {""name"": ""Updated Name"", ""description"": ""New desc"", ""price"": 100.00}); {id} as URL param (UUID or integer)
- **Response:** 200 OK with updated service JSON (include relevant fields like id, name, status, updated_at); use ETag for caching if applicable
- **Errors:** 401 Unauthorized, 403 Forbidden, 404 Not Found, 422 Unprocessable Entity (validation), 409 Conflict (state machine violation); all in RFC7807 problem+json format
- Content negotiation: Versioned API response; JSON limits and sanitization applied

## Relevant Business Logic

- Updates should trigger ledger entries if financial fields change (e.g., price); sync with profitability calculations for service_orders
- Respect service lifecycle: Use state machines to prevent invalid transitions (e.g., can't update completed service)
- Handle polymorphic relations: Update notes/attachments if provided
- Ensure referential integrity: Validate links to vendors, categories, or other entities
- Post-update: Fire events for webhooks, notifications (email/SMS templates), and analytics (e.g., activity logs)
- Compliance: Mask PII in logs; support feature flags for endpoint behavior"
183,service,Delete Service,Delete by id,api/services/{id},delete,Admin,Implement DELETE /api/services/{id} Endpoint for Service Deletion,"## Overview

This GitHub issue is for implementing the 'Delete Service' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs built over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes (fields/features), media (product images), barcodes, pricing (price overrides), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain handles order/order_item states (pending → confirmed → fulfilled|cancelled), assignment to stores, notes/attachments, promos, taxes, and fraud flags. Fulfillment includes shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns manage RMA (return/return_item), receive/restock/scrap, refunds, and exchanges (exchange_order). Payments cover intent → payment capture/void; refund lifecycle; and order.payment_status synchronization.

Accounting features transaction headers + ledger_entry lines for all movements; reversals; and reconciliation/export. Services include service/service_order with lifecycle and profitability. Integrations handle carriers & accounts, waybills/rates/tracking; webhooks with deliveries; and notification templates (email/SMS). Security & identity include user/role/permission with ability (role ↔ perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; and API keys.

Observability & compliance cover audit_event, log, request-id, PII masking, health/metrics, queues, and caching/etag. Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, and cache headers.

Reporting/analytics include revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, and activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, and cycle counts; conflicts return RFC7807 problem+json.

APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. The design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The 'Delete Service' endpoint allows administrators to delete a service by its ID. This operation should perform a soft delete to maintain data integrity, especially considering potential links to service_orders and profitability tracking. Ensure that deletion respects business rules, such as preventing deletion if active service_orders exist, and logs the event for audits.

## API Specifications

- **Category:** service
- **Title:** Delete Service
- **Description:** Delete by id
- **Route:** api/services/{id}
- **HTTP Method:** delete
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the DELETE endpoint at /api/services/{id}
- [ ] Require Admin authentication and authorization via RBAC (user must have permission to delete services)
- [ ] Validate that the {id} is a valid UUID or integer identifier for the service
- [ ] Perform a soft delete on the service entity if it exists and no active service_orders are linked
- [ ] Return 204 No Content on successful deletion
- [ ] Return 404 Not Found if the service does not exist
- [ ] Return 403 Forbidden if the user lacks permission or if the service cannot be deleted due to business constraints (e.g., active orders)
- [ ] Return 422 Unprocessable Entity for invalid input (e.g., malformed ID)
- [ ] Log an audit_event for the deletion action
- [ ] Handle errors using RFC7807 problem+json format
- [ ] Ensure idempotency and apply relevant middleware (e.g., auth, RBAC, throttles, input sanitizer)
- [ ] Write unit and integration tests covering success, failure, and edge cases
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger)
- [ ] Verify compatibility with state machines and ledger posting if applicable

## Technical Requirements

- Use Laravel framework: Define the route in api.php or services routes file
- Implement in a dedicated ServiceController (e.g., delete method)
- Use Eloquent model for Service with soft deletes enabled
- Apply Laravel validation (e.g., via FormRequest) for the ID parameter
- Integrate with RBAC: Check user permissions via Gate/Policy for 'delete' on services
- Consider branch scope if services are scoped to stores/branches
- Handle transactions to ensure atomicity, especially for related ledger_entries or audit_events
- Response format: No body for 204; use problem+json for errors with request-id
- Request format: Path parameter {id}; no body expected
- Ensure UTC handling and EAV attributes are preserved in soft delete
- Add caching/etag considerations if the service is cached
- Test for middleware stack: auth (JWT/API key), RBAC, permission checks, etc.
- Include queueing if deletion triggers async tasks (e.g., notifications or webhooks)"
184,service-order,Create Service Order,Create intake,api/service-orders,post,Employee,Implement POST /api/service-orders: Create Service Order,"## Overview

This GitHub issue is for implementing the 'Create Service Order' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits.

Core entities include: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.

Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.

Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.

Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).

Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.

Services: service/service_order with lifecycle and profitability.

Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.

Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint creates an intake for a service order, initiating the service/service_order lifecycle with profitability tracking, integrated with orders, inventory, payments, and accounting.

## API Specifications

- **Category:** service-order
- **Title:** Create Service Order
- **Description:** Create intake
- **Route:** api/service-orders
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST /api/service-orders endpoint in Laravel controller
- [ ] Ensure authentication requires Employee role via RBAC
- [ ] Validate input data for service order creation, including links to core entities like customers, stores, and services
- [ ] Handle state machine initialization for service_order lifecycle (e.g., pending state)
- [ ] Integrate with inventory reservations if applicable, and post ledger entries for any financial implications
- [ ] Support attachments/notes polymorphic relations
- [ ] Return RFC7807 problem+json for validation errors or state conflicts
- [ ] Add unit/integration tests covering success, validation failures, unauthorized access, and business logic
- [ ] Document request/response schemas in OpenAPI/Swagger
- [ ] Ensure middleware stack includes auth, RBAC checks, branch scope, idempotency, and input sanitization
- [ ] Verify soft deletes and UTC handling for created records
- [ ] Test integration with payments, accounting, and notifications if triggered on creation

## Technical Requirements

- Use Laravel controller and routes: Define route in api.php, create ServiceOrderController@store method
- Input validation: Use FormRequest for rules on fields like customer_id, store_id, service details, notes; support EAV attributes
- Proper error handling: 4xx for validation/auth, 5xx for server issues; use problem+json format
- Business logic: Initialize service_order with default state via state machine; link to order domain if related; trigger audit_event; optional profitability calculation setup; ensure transactional consistency with inventory/payments
- Authentication/authorization: JWT/session/API key; require active Employee user with email-verified and 2FA if enabled; RBAC permission for service-order:create; branch scope enforcement
- Expected request/response format: JSON; Request: {customer_id, store_id, service_type, description, attachments?, ...}; Response: 201 with created service_order JSON (id, state, timestamps, relations); Include etag for caching
- Database: Create record in service_orders table; enforce referential integrity; use soft deletes
- Observability: Log request-id, audit creation event; queue any async tasks like notifications
- Integrations: Potential webhooks for service order creation; support feature flags for endpoint behavior
- Testing: PHPUnit tests for controller, validation, auth; feature tests for full flow; cover edge cases like invalid states or missing permissions
- Security: Sanitize inputs, guard against PII exposure; apply throttles and idempotency keys"
185,service-order,List Service Orders,Filter by status/date,api/service-orders,get,Employee,Implement List Service Orders API Endpoint (GET /api/service-orders),"## Context about Deshio ERP

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.
Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

## Overview

Implement the 'List Service Orders' API endpoint for the Deshio ERP system. This endpoint allows authenticated employees to retrieve a list of service orders, filtered by status and date. Service orders represent the service domain with lifecycles and profitability tracking, integrated with the broader ERP entities like orders, inventory, and accounting. The implementation must adhere to Laravel best practices, include proper middleware for security and observability, and handle state machine-driven transitions where applicable.

## API Specifications

- **Category:** service-order
- **Title:** List Service Orders
- **Description:** Filter by status/date
- **Route:** api/service-orders
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint returns a paginated list of service orders in JSON format
- [ ] Supports filtering by status (e.g., pending, confirmed, fulfilled) via query parameter
- [ ] Supports filtering by date range (e.g., created_at, updated_at) via query parameters
- [ ] Includes optional search and sorting capabilities
- [ ] Handles soft deletes by excluding archived records unless specified
- [ ] Returns RFC7807 problem+json for invalid filters or unauthorized access
- [ ] Implements caching with ETag headers for performance
- [ ] Logs audit events for all requests
- [ ] Unit and integration tests cover happy path, edge cases, and errors
- [ ] Documentation updated with OpenAPI spec

## Technical Requirements

- Use Laravel controller (e.g., ServiceOrderController@index) and define route in api.php
- Leverage Eloquent for querying service/service_order models, with relationships to related entities (e.g., users, stores, ledger entries)
- Implement input validation using Form Requests for query parameters (status array, date_from, date_to, etc.)
- Apply middleware stack: auth (JWT/session/API key), RBAC permission checks for 'view service orders', branch scope if applicable, throttles, input sanitizer
- Use state machines to ensure only valid statuses are filterable
- Handle pagination with Laravel's LengthAwarePaginator, including meta for total count
- Support bulk operations considerations for future scalability
- Integrate with observability: request-id, metrics, queues if async processing needed
- Ensure data in UTC, PII masking in responses (e.g., customer details)
- Error handling: 401 for unauth, 403 for unauthorized, 422 for invalid params, 500 for server errors

## Authentication/Authorization Requirements

- Requires 'Employee' authentication via JWT, session, or API key
- RBAC: User must have a role with permission to view service orders (ability: role→perm mapping)
- Additional checks: active user, email-verified, 2FA if enabled, branch scope to limit to assigned stores/branches
- Multi-role support via user_role junctions

## Expected Request/Response Format Considerations

- **Request:** GET /api/service-orders?status[]=pending&status[]=confirmed&date_from=2023-01-01&date_to=2023-12-31&page=1&per_page=20
  - Query params: status (array), date_from (date), date_to (date), search (string), sort_by (string), sort_dir (asc/desc)
- **Response:** 200 OK with JSON array of service orders, including id, status, created_at, updated_at, profitability metrics, related entities (e.g., customer summary, service details)
  - Structure: { ""data"": [...], ""meta"": { ""current_page"": 1, ""total"": 100, ... } }
  - Use resource classes for transformation, include media/attachments polymorphically if relevant
  - Cache headers: ETag, Last-Modified based on query params

## Relevant Business Logic

- Service orders follow a lifecycle (e.g., pending→confirmed→fulfilled|cancelled) driven by state machines; filters must respect valid transitions
- Integrate with profitability calculations from accounting ledger_entries
- Link to core entities: assign to stores/branches, reference customers/tags, include notes/attachments
- Ensure transactional consistency with inventory/reservations if services involve stock movements
- Support promotions/taxes/fraud flags if applicable to service orders
- Post ledger entries for financial events; handle reversals/refunds in lifecycle
- Observability: Track SLA for service order fulfillment in reporting/analytics"
186,service-order,Get Service Order,Service order details,api/service-orders/{id},get,Employee,Implement GET /api/service-orders/{id} for Service Order Details,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the 'Get Service Order' API endpoint. This endpoint retrieves detailed information for a specific service order.

Core entities in Deshio include: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.

Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.

Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.

Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).

Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.

Services: service/service_order with lifecycle and profitability.

Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.

Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint falls under the service-order category and provides service order details, including lifecycle states and profitability calculations.

## API Specifications

- **Category:** service-order
- **Title:** Get Service Order
- **Description:** Service order details
- **Route:** api/service-orders/{id}
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET endpoint to retrieve service order details by ID
- [ ] Ensure the endpoint returns comprehensive service order data, including lifecycle states, profitability, associated services, notes/attachments, and related entities (e.g., customers, stores, payments)
- [ ] Validate that the service order ID exists and is accessible; return 404 if not found
- [ ] Handle soft deletes appropriately (e.g., exclude deleted records or handle archival)
- [ ] Apply state machine logic to ensure only valid states are exposed
- [ ] Include proper error handling for unauthorized access, invalid inputs, or conflicts using RFC7807 problem+json
- [ ] Add unit and integration tests covering success, error cases, authentication, and business logic
- [ ] Verify response includes EAV attributes, polymorphic relations, and UTC timestamps
- [ ] Ensure endpoint respects middleware stack: auth, RBAC, branch scope, throttles, etc.
- [ ] Test for PII masking in responses and audit logging of the request
- [ ] Confirm integration with reporting/analytics if applicable (e.g., profitability metrics)

## Technical Requirements

- Use Laravel framework: Create a dedicated controller (e.g., ServiceOrderController) with a show method
- Define the route in api.php: Route::get('/service-orders/{id}', [ServiceOrderController::class, 'show'])->middleware(['auth:employee', 'rbac:view_service_orders']);
- Implement input validation for {id} as a required UUID or integer
- Use Eloquent models for service/service_order with relationships to orders, payments, inventory, etc.
- Leverage state machines for lifecycle validation
- Apply domain guards for service orders, reservations, and financial postings
- Ensure transactional consistency for any related ledger entries or stock movements
- Use caching/etag for performance if applicable, with cache headers
- Handle versioned content-negotiation and locale/tz in responses
- Integrate with observability: request-id, audit_event logging, metrics

## Authentication/Authorization Requirements

- Requires Employee authentication (JWT/session/API key)
- Enforce RBAC: User must have permission to view service orders (e.g., role↔perm via ability)
- Check active user, email-verified, 2FA if enabled
- Apply branch scope to ensure employee can only access service orders in their scoped branches/stores
- Optional tenancy if multi-tenant setup is active
- Use middleware for auth, RBAC & permission checks

## Expected Request/Response Format Considerations

- **Request:** No body; path parameter {id} (e.g., UUID or integer). Query params optional for includes (e.g., ?include=services,customer,payments) to eager-load relations.
- **Response:** JSON object with service order details:
  {
    ""data"": {
      ""id"": ""uuid"",
      ""state"": ""pending|confirmed|fulfilled|cancelled"",
      ""customer_id"": ""uuid"",
      ""store_id"": ""uuid"",
      ""services"": [...],
      ""profitability"": { ""revenue"": 100.00, ""cost"": 80.00, ""margin"": 20.00 },
      ""notes"": [...],
      ""attachments"": [...],
      ""payments"": [...],
      ""created_at"": ""2023-01-01T00:00:00Z"",
      ""updated_at"": ""2023-01-01T00:00:00Z""
    }
  }
- Use RFC7807 for errors: { ""type"": ""https://example.com/probs/out-of-credit"", ""title"": ""Insufficient funds"", ... }
- Ensure responses are in UTC, with proper JSON limits and sanitizer
- Support bulk-like includes but single record

## Relevant Business Logic

- Service orders follow a lifecycle (e.g., pending→confirmed→fulfilled|cancelled) driven by state machines; validate transitions and expose current state
- Calculate profitability based on associated services, payments, inventory costs, and promotions
- Link to core entities: customers, stores/branches, payments (intent→capture), accounting ledger entries
- Handle notes/attachments polymorphically; support EAV for custom attributes
- Ensure deterministic assignment, safe reservations/consumption, and ledger posting on events
- Integrate with fulfillments (shipments/dispatches if applicable), returns (RMA), and reporting (e.g., LTV/AOV, SLA for service orders)
- Conflicts (e.g., invalid state) return problem+json; maintain referential integrity across junctions
- Support integrations like notifications (email/SMS templates) and webhooks for state changes"
187,service-order,Update Service Order,Update fields/status,api/service-orders/{id},put,Employee,Implement PUT /api/service-orders/{id} for Updating Service Orders,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD, implement the Update Service Order API endpoint. This endpoint allows updating fields and status of a service order in the service domain.

Deshio ERP Context:
Deshio covers catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint fits into the services domain, enabling updates to service orders with state machine-driven status transitions and profitability calculations.

## API Specifications

- **Category:** service-order
- **Title:** Update Service Order
- **Description:** Update fields/status
- **Route:** api/service-orders/{id}
- **HTTP Method:** put
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint responds to PUT requests on /api/service-orders/{id} with valid authentication
- [ ] Allows updating service order fields (e.g., notes, attachments, custom attributes via EAV)
- [ ] Handles status updates via state machine, validating legal transitions and rejecting invalid ones with RFC7807 problem+json
- [ ] Triggers relevant business logic: profitability recalculation, ledger postings for financial impacts, notifications (email/SMS), and audit events
- [ ] Supports polymorphic notes/attachments and strict referential integrity
- [ ] Applies middleware: auth, RBAC/permission checks, branch scope, input sanitization, idempotency, throttles
- [ ] Returns appropriate HTTP status codes: 200 for success, 404 for not found, 422 for validation errors, 403 for unauthorized
- [ ] Includes request-id, caching/etag headers, and logs with PII masking
- [ ] Handles soft deletes and UTC timestamps
- [ ] Unit and integration tests cover happy path, invalid transitions, auth failures, and edge cases (e.g., concurrent updates)
- [ ] Documentation updated with OpenAPI spec including request/response examples

## Technical Requirements

- Implement in Laravel: Add route to api.php, create/update ServiceOrderController with update method
- Use Eloquent models for service/service_order, integrating with related entities (e.g., orders, inventory for reservations)
- Input validation: Use Form Requests for request body (JSON with fields like status, notes, etc.), sanitize inputs, validate id as UUID/int
- Error handling: Return RFC7807 problem+json for state machine conflicts, validation errors; use exceptions for 404/403
- State machine integration: Use Laravel FSM or similar to manage service_order lifecycle transitions, ensuring atomicity with DB transactions
- Business logic: On update, recalculate profitability; post to accounting ledger if financial changes; trigger webhooks/notifications if status changes; update analytics/reporting views
- Database: Ensure updates respect soft deletes, referential integrity; use UTC; optimistic locking for concurrency
- Middleware: Apply full stack including auth (JWT/API key for Employee), RBAC (check permissions for service-order update), branch scope
- Performance: Use queues for heavy tasks (e.g., notifications); caching where applicable with etag

## Authentication/Authorization Requirements

- Requires Employee authentication (JWT/session/API key)
- RBAC: User must have role/permission allowing service-order updates (e.g., 'service-order:update' ability)
- Additional checks: Active user, email-verified, 2FA if enabled; branch scope to prevent cross-branch updates
- Audit: Log audit_event on successful updates with request-id

## Expected Request/Response Format Considerations

- **Request:** JSON body with updatable fields (e.g., {""status"": ""in_progress"", ""notes"": ""Updated notes"", ""attachments"": [...] }); {id} as path param (existing service_order ID)
- **Headers:** Authorization, Content-Type: application/json, X-Request-ID, If-Match for etag
- **Response (Success - 200):** JSON with updated service_order (minimal or full, per spec), e.g., {""id"": ""uuid"", ""status"": ""in_progress"", ""updated_at"": ""utc""}
- **Response (Error):** RFC7807 problem+json, e.g., {""type"": ""https://example.com/probs/state-invalid"", ""title"": ""Invalid Transition"", ""status"": 422, ""detail"": ""Cannot transition from pending to fulfilled""}
- Versioned: Use content-negotiation for API version; locale/tz from headers
- Idempotency: Support key in header/body to prevent duplicate updates

## Relevant Business Logic

- Service orders follow lifecycle managed by state machines; updates must validate transitions (e.g., pending → in_progress → completed)
- On status change: Trigger profitability calc (revenue - costs), ledger entries for accounting, stock movements if applicable, notifications via templates
- Integrations: If update affects fulfillment/logistics, sync with shipments/dispatch; handle refunds/exchanges if linked to orders
- Compliance: Mask PII in logs; ensure reversals possible via audit trail; feature flags for optional behaviors
- Conflicts: Use domain guards for reservation/promo/override; transactional consistency across entities"
188,service-order,Cancel Service Order,Cancel service job,api/service-orders/{id}/cancel,post,Employee,Implement Cancel Service Order API Endpoint,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue focuses on implementing the 'Cancel Service Order' API endpoint. Deshio handles core entities like product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment covers shipments and inter-store dispatch with tracking and stock movements. Returns involve RMA, refunds, exchanges. Payments handle intent→payment capture/void and refunds. Accounting uses transaction headers + ledger_entry for movements, reversals, reconciliation/export. Services include service/service_order with lifecycle and profitability. Integrations cover carriers, webhooks, notifications. Security & identity: user/role/permission with abilities, sessions, MFA, API keys. Observability: audit_event, logs, PII masking, health/metrics. Middleware: TLS/HSTS, CORS, auth (JWT/session/API key), RBAC, throttles, etc. Reporting/analytics: revenue, LTV/AOV, inventory aging, etc. State machines drive transitions for orders, dispatch, etc., with RFC7807 errors. APIs support bulk import/export, search, attachments, etc. Data in UTC, soft deletes, EAV, polymorphic relations, deterministic assignments, safe reservations, consistent ledger posting.

This endpoint allows cancelling a service job in the service-order category, updating the service_order lifecycle state via state machine, ensuring transactional integrity for stock/financial events, audits, and related ledgers.

## API Specifications

- **Category:** service-order
- **Title:** Cancel Service Order
- **Description:** Cancel service job
- **Route:** api/service-orders/{id}/cancel
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint responds to POST requests at /api/service-orders/{id}/cancel
- [ ] Validates that the service order exists and is in a cancellable state (e.g., pending or confirmed, per state machine)
- [ ] Performs cancellation via state machine transition, updating service_order status to 'cancelled'
- [ ] Handles related business logic: reverse reservations, post ledger entries for reversals, trigger notifications/webhooks if applicable
- [ ] Returns success response with updated service order details or confirmation
- [ ] Returns appropriate RFC7807 problem+json errors for invalid states, permissions, or conflicts
- [ ] Includes audit_event logging for the cancellation action
- [ ] Unit and integration tests cover happy path, edge cases (e.g., already cancelled, non-existent ID), and error scenarios
- [ ] Documentation updated with request/response examples and error codes
- [ ] Endpoint is secured behind Employee authentication and RBAC permissions

## Technical Requirements

- Implement in Laravel: Add route to api.php, create or extend ServiceOrderController with cancel method
- Use state machine for service_order lifecycle transitions to ensure legality
- Input validation: Ensure {id} is a valid UUID/integer; optional request body for reason/notes if needed (polymorphic attachments)
- Proper error handling: 404 for non-existent order, 403 for unauthorized, 409 for invalid state, 422 for validation errors
- Integrate with middleware stack: auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, throttles, idempotency, input sanitizer
- Ensure transactional consistency: Use DB transactions for state update, ledger posting, inventory adjustments, audit logs
- Response: JSON with HTTP 200 OK on success, including updated service_order (status: 'cancelled', timestamps); use ETag/caching headers if applicable
- Soft delete or archival considerations if cancellation leads to archival
- Observability: Log request-id, audit_event with PII masking; queue any async tasks (e.g., notifications)

## Authentication/Authorization Requirements

- Requires Employee authentication (JWT/session/API key)
- RBAC: User must have role/permission allowing service order cancellation (e.g., ability: 'service-order.cancel')
- Branch scope: Employee must be scoped to the service_order's branch/store
- Optional: Tenancy if multi-tenant setup; active user, email-verified, 2FA enforcement

## Expected Request/Response Format Considerations

- **Request:** POST /api/service-orders/{id}/cancel
  - Path param: {id} - Service order ID (UUID/integer)
  - Body: Optional JSON { ""reason"": ""string"", ""notes"": ""string"" } for cancellation details (attach polymorphic notes)
  - Headers: Authorization (Bearer/JWT), Content-Type: application/json, Accept: application/json

- **Success Response (200 OK):** 
  {
    ""data"": {
      ""id"": ""uuid"",
      ""status"": ""cancelled"",
      ""updated_at"": ""utc-timestamp"",
      // other service_order fields
    },
    ""message"": ""Service order cancelled successfully""
  }

- **Error Responses:**
  - 401 Unauthorized: Missing/invalid auth
  - 403 Forbidden: Insufficient permissions or scope
  - 404 Not Found: Service order not found
  - 409 Conflict: Cannot cancel (invalid state)
  - 422 Unprocessable Entity: Validation error (RFC7807 problem+json)

All times in UTC; use versioned content-negotiation, locale/tz handling.

## Relevant Business Logic

- State machine validates transition to 'cancelled' from eligible states (e.g., pending/confirmed); prevents from fulfilled/completed
- On cancel: Reverse any reservations/adjustments, post reversal ledger entries for profitability accounting
- Trigger notifications (email/SMS via templates) to customer/assigned users
- Sync with related domains: If linked to order/payment, update statuses; handle refunds if payments captured
- Audit trail: Create audit_event with user_id, action='cancel', changes diff
- Conflicts (e.g., concurrent updates) return 409 with problem details
- Ensure deterministic admin assignment and safe consumption of resources
- Integrate with reporting: Update metrics for service order cancellations, SLA impacts"
189,service-order,Add Service Note,Add internal note,api/service-orders/{id}/notes,post,Employee,Implement API: Add Service Note to Service Orders,"## Overview

This GitHub issue is for implementing the 'Add Service Note' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs built over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, audits, services, integrations, security, observability, and reporting/analytics.

Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The service domain involves service/service_order with lifecycle and profitability. Orders have states (pending→confirmed→fulfilled|cancelled), assignments, notes/attachments, promos, taxes, and fraud flags. Fulfillment includes shipments and inter-store dispatches with tracking and stock movements. Returns handle RMAs, restocking, refunds, and exchanges. Payments manage intents, captures, voids, refunds, and synchronization. Accounting uses transaction headers and ledger entries for movements, reversals, and reconciliation. Integrations support carriers, waybills, tracking, webhooks, and notifications. Security features user/role/permission with multi-roles, sessions, email verification, password reset, TOTP MFA, API keys. Observability includes audits, logs, PII masking, health/metrics, queues, caching. Middleware enforces TLS/HSTS, CORS, auth (JWT/session/API key), RBAC, branch scope, throttles, idempotency, sanitization, and more. Reporting covers revenue, LTV/AOV, returns, SLA, inventory aging, and promo impact. State machines ensure legal transitions with RFC7807 error responses. APIs support bulk operations, search, attachments, reindexing, backups, feature flags. Data uses UTC, soft deletes, EAV for attributes, polymorphic notes/attachments, strict referential integrity. Design supports deterministic assignments, safe reservations, and consistent ledger posting.

The 'Add Service Note' endpoint specifically allows authenticated employees to add an internal note to a service order, leveraging polymorphic notes for attachments and notes across entities.

## API Specifications

- **Category:** service-order
- **Title:** Add Service Note
- **Description:** Add internal note
- **Route:** api/service-orders/{id}/notes
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST endpoint at api/service-orders/{id}/notes to add an internal note to a service order
- [ ] Ensure the endpoint requires Employee authentication and appropriate RBAC permissions (e.g., permission to add notes to service orders)
- [ ] Validate that the service order {id} exists and is accessible to the authenticated user (considering branch scope and active status)
- [ ] Handle polymorphic note creation, associating the note with the service order entity
- [ ] Support note content in the request body, with optional fields like type (internal), attachments if applicable
- [ ] Return a 201 Created response with the created note details on success
- [ ] Return appropriate RFC7807 problem+json errors for invalid inputs, unauthorized access, non-existent service order, or state machine conflicts
- [ ] Implement input validation for note content (e.g., required, max length, sanitization)
- [ ] Add unit and integration tests covering happy path, validation errors, auth failures, and edge cases (e.g., soft-deleted orders)
- [ ] Ensure the endpoint integrates with middleware stack: auth, RBAC checks, branch scope, input sanitizer, idempotency if applicable
- [ ] Log audit events for note creation, with request-id tracing and PII masking if needed
- [ ] Verify compatibility with state machines for service_order lifecycle (e.g., notes allowable in current state)
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger) including request/response schemas

## Technical Requirements

- Use Laravel framework: Define route in api.php or service-routes.php with proper middleware (auth:employee, rbac:service-order.notes.create, branch.scope)
- Create or extend a ServiceOrderNoteController with a store method
- Utilize Eloquent models: ServiceOrder (with id), Note (polymorphic, morphTo 'notable' relation to ServiceOrder)
- Implement request validation using FormRequest class: e.g., 'content' => 'required|string|max:5000'
- Handle soft deletes: Ensure query scopes exclude soft-deleted service orders unless authorized
- Error handling: Use Laravel exceptions, transform to RFC7807 format via custom exception handler
- Response format: JSON with created note resource (id, content, created_at, user_id, notable_type/id), following JSON:API or similar standards
- Database: Ensure UTC timestamps, referential integrity for user_id (creator) and notable_id
- Integration: Trigger audit_event on creation; optional queue for notifications if note triggers alerts
- Testing: PHPUnit tests for controller, validation, auth; feature tests simulating API calls with Sanctum/JWT
- Observability: Add metrics for endpoint usage, integrate with request-id middleware for tracing

## Authentication/Authorization Requirements

- Authentication: Requires Employee role via JWT, session, or API key
- Authorization: RBAC check for permission 'service-order.notes.create' assigned to user's roles; enforce active user, email-verified, optional 2FA
- Scope: Branch scope middleware to ensure user can only add notes to service orders in accessible branches/stores
- Security: Apply throttles, idempotency keys for duplicate prevention, input sanitization to prevent XSS/SQLi

## Expected Request/Response Format Considerations

- **Request:** JSON body, e.g., {""content"": ""Internal note about service issue"", ""type"": ""internal"" (optional)}; {id} as URL param (UUID or integer)
- **Response (201):** {""data"": {""id"": 123, ""content"": ""..."", ""created_at"": ""2023-..."", ""user"": {""id"": 456, ""name"": ""...""}, ""notable"": {""type"": ""service_order"", ""id"": 789}}}
- **Errors:** 401 Unauthorized, 403 Forbidden (RBAC/scope), 404 Not Found (order), 422 Unprocessable Entity (validation), 409 Conflict (state machine)
- Content negotiation: Versioned API (e.g., /v1/), locale/tz from headers, ETag/caching headers if read-heavy
- Attachments: If extended, support file uploads with mime guard, store polymorphically

## Relevant Business Logic

- Notes are internal-only for employees; visible based on RBAC and branch access
- Integrate with service_order lifecycle: Allow notes in states like pending, confirmed, etc., via state machine guards
- On creation, post to audit ledger if note impacts profitability or requires tracking
- Ensure transactional: Note creation should atomic with any related events (e.g., no partial saves)
- Support for future extensions: Bulk notes, search notes via /notes?notable=service_order&id=...
- Compliance: Mask PII in notes if customer data included; soft-delete notes on order archival"
190,service-order,Complete Service,Mark as completed,api/service-orders/{id}/complete,post,Employee,Implement Complete Service API Endpoint for Service Orders,"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This issue is for implementing the 'Complete Service' API endpoint in the service-order category. This endpoint marks a service order as completed, updating its lifecycle state and triggering associated business processes like profitability calculations, ledger postings, and notifications.

## API Specifications

- **Category:** service-order
- **Title:** Complete Service
- **Description:** Mark as completed
- **Route:** api/service-orders/{id}/complete
- **Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST endpoint at api/service-orders/{id}/complete
- [ ] Validate that the service order exists and is in a valid state for completion (e.g., not already completed or cancelled)
- [ ] Update the service order state to 'completed' using the state machine
- [ ] Trigger business logic including ledger postings for profitability, notifications (email/SMS via templates), and any audit events
- [ ] Ensure transactional consistency for stock/financial movements if applicable
- [ ] Handle unauthorized access or invalid states with appropriate RFC7807 problem+json errors
- [ ] Add comprehensive unit and integration tests covering success, failure, and edge cases
- [ ] Document the endpoint in API specs, including request/response examples
- [ ] Verify middleware integration (auth, RBAC, branch scope, etc.)
- [ ] Confirm observability: log events, request-id tracing, and metrics

## Technical Requirements

- Develop in Laravel: Create a controller method in ServiceOrderController (or similar) and register the route in routes/api.php
- Use Laravel's resource routing where possible, ensuring versioned content-negotiation
- Implement input validation (e.g., via FormRequest) for the {id} parameter and any optional request body
- Apply domain guards for service orders, ensuring idempotency and sanitizer middleware
- Integrate with state machine for legal transitions; revert or error on conflicts
- Use Eloquent models for service/service_order, handling soft deletes and UTC timestamps
- Post events to queues for notifications and webhooks if completion triggers deliveries
- Ensure polymorphic relations (notes/attachments) are preserved
- Add caching/etag support and proper cache headers

## Authentication/Authorization Requirements

- Require Employee authentication via JWT, session, or API key middleware
- Enforce active user, email-verified, and 2FA checks
- Implement RBAC: User must have role/permission allowing service order completion (e.g., via ability checks in user_role)
- Apply branch scope to ensure the employee can only complete service orders assigned to their branch/store
- Optional tenancy isolation if multi-tenant setup is enabled
- Throttle requests and validate idempotency keys to prevent duplicates

## Expected Request/Response Format Considerations

- **Request:** POST to /api/service-orders/{id}/complete. Expect JSON body (optional: e.g., {""notes"": ""Completion notes""} for polymorphic attachments). Validate {id} as UUID/integer. Use content-negotiation for JSON input.
- **Response:** On success, return 200 OK with JSON representation of the updated service order (including state, profitability metrics, ledger entries). Use 204 No Content if no body needed. Include ETag for caching.
- **Errors:** Return 4xx (e.g., 400 for invalid state, 401/403 for auth/RBAC issues, 404 for not found) or 5xx in problem+json format per RFC7807, with request-id. Mask PII in logs.
- All data in UTC; support locale/tz from headers.

## Relevant Business Logic

- Leverage state machine to validate and transition service_order lifecycle to 'completed' (similar to order fulfillment states: pending→confirmed→fulfilled)
- On completion, calculate profitability and post to accounting ledger (transaction header + ledger_entry lines); handle reversals if needed
- Trigger notifications using templates (email/SMS) for stakeholders (e.g., customer, assigned employee)
- If service order involves inventory/services, ensure reservations are consumed and stock movements are ledgered transactionally
- Audit the event in audit_event table; flag for reporting (e.g., service SLA, activity analytics)
- Integrate with integrations if completion affects shipments/dispatches (e.g., update tracking)
- Ensure consistency with core design: safe consumption, deterministic assignments, and event-driven posting for financial/stock events
- Handle conflicts (e.g., concurrent updates) via optimistic locking or queues"
191,service-order,Deliver Service,Mark as delivered,api/service-orders/{id}/deliver,post,Employee,Implement Deliver Service API Endpoint for Service Orders,"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint marks a service order as delivered, transitioning its state via the service order lifecycle state machine. It ensures transactional updates, profitability calculations, and integration with notifications or accounting ledgers as needed.

## API Specifications

- **Category:** service-order
- **Title:** Deliver Service
- **Description:** Mark as delivered
- **Route:** api/service-orders/{id}/deliver
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint handles valid requests and marks the service order as delivered using the state machine
- [ ] Validates that the service order exists and is in a transition-eligible state (e.g., confirmed or in-progress)
- [ ] Returns RFC7807 problem+json for invalid states or unauthorized access
- [ ] Integrates with middleware for auth, RBAC, branch scope, and idempotency
- [ ] Triggers relevant business logic: update profitability, post to accounting ledger, send notifications (email/SMS)
- [ ] Handles soft deletes and UTC timestamps correctly
- [ ] Includes audit_event logging for the transition
- [ ] Unit and integration tests cover success, failure, and edge cases (e.g., concurrent updates)
- [ ] Endpoint is documented with OpenAPI specs including request/response examples

## Technical Requirements

- Implement in Laravel: Define route in api.php, create controller method in ServiceOrderController
- Use state machine for service_order lifecycle to validate and perform the 'deliver' transition
- Apply middleware stack: auth (JWT/session/API key), RBAC permission checks (e.g., 'service-orders.deliver'), branch scope, throttles, idempotency
- Input validation: Ensure {id} is a valid UUID or integer; optional request body for delivery notes or attachments if polymorphic
- Error handling: 404 for non-existent order, 403 for unauthorized, 422 for invalid state, 409 for conflicts
- Response: 200 OK with updated service order JSON (including state, profitability metrics); use ETag for caching
- Database: Transactional update to service_order table; potential polymorphic relations for notes/attachments
- Observability: Log request-id, audit_event for state change; PII masking if customer data involved
- Testing: PHPUnit tests for controller, state machine validation, and integration with queues/notifications

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- RBAC: User must have role/permission allowing 'deliver' on service orders (e.g., service manager or technician role)
- Additional checks: Active user, email-verified, 2FA if enabled; branch scope to ensure employee can access the order's branch
- Multi-role support via user_role junction

## Expected Request/Response Format Considerations

- **Request:** POST /api/service-orders/{id}/deliver
  - Headers: Authorization (Bearer/JWT), Content-Type: application/json, X-Request-ID, If-Match (ETag for idempotency)
  - Body: Optional JSON { ""notes"": ""string"", ""attachments"": [] } for polymorphic additions; otherwise empty
  - Validation: Sanitize inputs, guard against domain conflicts (e.g., reservation/promo overrides if applicable)

- **Response:** 
  - Success (200): application/json with service order details { ""id"": ""uuid"", ""state"": ""delivered"", ""profitability"": { ""revenue"": float, ""cost"": float }, ""updated_at"": ""utc"" }
  - Error: application/problem+json per RFC7807, e.g., { ""type"": ""https://example.com/probs/invalid-state"", ""title"": ""Invalid Transition"", ""status"": 422, ""detail"": ""Service order not ready for delivery"" }
  - Cache headers: ETag, Cache-Control based on content-negotiation and versioning

## Relevant Business Logic

- State machine enforces legal transition to 'delivered'; revert or conflict if not possible (e.g., if pending payments)
- On delivery: Calculate/update profitability (revenue - costs); post ledger_entry for financial impact
- Trigger notifications via templates (email/SMS for customer confirmation); potential webhooks for integrations
- Ensure transactional stock movements if service involves inventory (e.g., parts used in service_order)
- Handle reversals if delivery is later amended; synchronize with order.payment_status if linked
- Compliance: Audit the event; mask PII in logs; support feature flags for optional behaviors like auto-invoicing"
192,log,List Logs,System/user action logs,api/logs,get,Admin,Implement List Logs API Endpoint (GET /api/logs),"## Context

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.
Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

## Overview

This issue covers the implementation of the 'List Logs' API endpoint in the Deshio ERP system. The endpoint retrieves system and user action logs, which are crucial for observability, compliance, auditing, and debugging. Logs include audit events, request logs, and other system activities, supporting features like request-id tracking, PII masking, and integration with health/metrics. The endpoint must adhere to the system's middleware stack, including authentication, RBAC checks, pagination, and error handling as per RFC7807 for conflicts.

## API Specifications

- **Category:** log
- **Title:** List Logs
- **Description:** System/user action logs
- **Route:** api/logs
- **HTTP Method:** GET
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint returns a paginated list of logs with filtering options (e.g., by date, user, level, request-id)
- [ ] Authentication requires admin role with appropriate permissions for log access
- [ ] Response includes relevant log details while masking PII as per compliance rules
- [ ] Implement pagination, sorting, and search capabilities
- [ ] Handle errors with RFC7807 problem+json format for invalid requests or unauthorized access
- [ ] Logs are queried from the log/audit_event tables with soft delete awareness
- [ ] Endpoint respects caching/etag and request-id middleware
- [ ] Unit and integration tests cover successful retrieval, filtering, pagination, auth failures, and edge cases
- [ ] Documentation updated with request/response examples and OpenAPI spec
- [ ] Performance optimized for large log volumes with indexing on query params

## Technical Requirements

- Use Laravel framework: Define route in api.php, create a dedicated LogsController with index method
- Implement Eloquent queries on log/audit_event models, supporting filters via query parameters (e.g., ?date_from=...&user_id=...&level=error)
- Apply middleware: auth (JWT/API key), RBAC permission check for logs.view or equivalent admin ability
- Use Laravel's pagination (e.g., LengthAwarePaginator) with default limits and ?page/?per_page support
- Input validation: Sanitize query params with Laravel Validator, enforce date formats, user IDs, etc.
- Response format: JSON array of log objects with fields like id, timestamp (UTC), user_id, action, message, request_id, ip, masked_pii; include meta for pagination
- Error handling: 401 for unauth, 403 for forbidden, 422 for invalid params, 500 for server errors
- Integrate with system's state machines if logs involve transitions, but primarily read-only
- Ensure transactional consistency if logs link to other entities (e.g., orders, inventory movements)
- Add queue support if log retrieval involves heavy processing; use caching for frequent queries

## Authentication/Authorization Requirements

- Requires admin authentication via JWT, session, or API key
- RBAC: User must have admin role or specific permission (e.g., ability('logs', 'view')) via role-permission mapping
- Enforce active user, email-verified, and optional 2FA/MFA checks from middleware
- Branch scope if logs are scoped; tenancy if multi-tenant setup
- Admin-only access to prevent unauthorized log exposure, aligning with security & identity features

## Expected Request/Response Format Considerations

- **Request:** GET /api/logs?filter[date_from]=2023-01-01&filter[date_to]=2023-12-31&filter[user_id]=123&filter[level]=error&sort=timestamp&direction=desc&page=1&per_page=50
  - All times in UTC; validate formats (ISO 8601 for dates)
  - Optional query params for filtering, sorting, pagination
- **Response (200 OK):**
  {
    ""data"": [
      {
        ""id"": 1,
        ""timestamp"": ""2023-10-01T12:00:00Z"",
        ""user_id"": 123,
        ""action"": ""order_created"",
        ""message"": ""Order #456 created"",
        ""request_id"": ""req-abc123"",
        ""ip"": ""192.0.2.1"",
        ""masked_pii"": true,
        ""details"": {...}
      }
    ],
    ""meta"": {
      ""current_page"": 1,
      ""last_page"": 10,
      ""per_page"": 50,
      ""total"": 500
    }
  }
- **Error Response (e.g., 403 Forbidden):**
  {
    ""type"": ""https://tools.ietf.org/html/rfc7231#section-6.5.3"",
    ""title"": ""Forbidden"",
    ""status"": 403,
    ""detail"": ""Admin access required for logs""
  }
- Content negotiation: JSON only; versioned via headers if applicable
- Headers: Include ETag for caching, X-Request-Id

## Relevant Business Logic

- Logs capture system/user actions across domains (e.g., order states, inventory adjustments, payments, audits)
- Support compliance: PII masking in logs, soft deletes for archival
- Integrate with observability: Link to audit_event for auditable actions, request-id for tracing
- Business rules: Filter logs by entity (e.g., order-related via polymorphic relations), ensure UTC storage
- No state transitions here (read-only); but logs may reference state machine events
- Align with reporting: Logs can feed into analytics like activity tracking, SLA monitoring
- Idempotency: GET is idempotent; use cache headers to avoid redundant queries
- Edge cases: Empty logs return empty data array; large result sets paginated; historical logs with aging consideration"
193,log,Get Log,Get single log entry,api/logs/{id},get,Admin,Implement Get Log API Endpoint in Deshio ERP,"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This issue is for implementing the 'Get Log' API endpoint in the log category, which retrieves a single log entry from the observability & compliance module.

## API Specifications

- **Category:** log
- **Title:** Get Log
- **Description:** Get single log entry
- **Route:** api/logs/{id}
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET /api/logs/{id} endpoint to retrieve a single log entry
- [ ] Ensure the endpoint requires Admin authentication and authorization
- [ ] Validate the {id} parameter as a valid log ID (e.g., UUID or integer)
- [ ] Return the log entry with all relevant details, including timestamps in UTC, request-id, and any PII masking if applicable
- [ ] Handle cases where the log ID does not exist (return 404 with RFC7807 problem+json)
- [ ] Apply middleware such as RequestId, auth (JWT/session/API key), RBAC & permission checks, and throttles
- [ ] Include proper cache headers and ETag support for observability
- [ ] Write unit tests for successful retrieval, invalid ID, unauthorized access, and error handling
- [ ] Write integration tests to verify end-to-end functionality with the log model and database
- [ ] Ensure soft deletes are respected if logs support archival

## Technical Requirements

- Use Laravel controller (e.g., LogController) and define the route in api.php with {id} as a required parameter
- Implement input validation using Laravel's FormRequest or Validator for the {id} parameter
- Query the log model (assuming Eloquent model for logs) to fetch the entry, handling soft deletes if enabled
- Integrate with observability features: include request-id, log level, and any associated audit_event if linked
- Proper error handling: use try-catch for database exceptions, return standardized errors per RFC7807
- Ensure data is returned in JSON format, with timestamps in UTC
- Consider polymorphic relations if logs link to notes/attachments or other entities
- Follow Deshio's middleware stack: apply auth, RBAC, branch scope (if logs are scoped), and idempotency if relevant
- Add logging for the API call itself via the log system for audit trails

## Authentication/Authorization Requirements

- Requires Admin role authentication via JWT, session, or API key
- Enforce RBAC: only users with 'view logs' permission (via role↔perm) can access
- Include middleware for active user, email-verified, 2FA (if enabled), and permission checks
- For API keys, ensure they are scoped to admin-level access for log retrieval
- Reject unauthorized requests with 401/403 and problem+json details

## Expected Request/Response Format Considerations

- **Request:** GET /api/logs/{id} with no body; {id} must be a valid identifier (e.g., integer or UUID)
- **Response (200 OK):** JSON object representing the log entry, e.g., {""id"": 123, ""level"": ""info"", ""message"": ""Sample log"", ""context"": {...}, ""timestamp"": ""2023-01-01T00:00:00Z"", ""request_id"": ""uuid""} – include PII masking for sensitive data
- **Error Responses:** 400 for invalid ID format, 404 for non-existent log, 401/403 for auth issues, all in problem+json format per RFC7807
- Use versioned content-negotiation (e.g., Accept: application/vnd.deshio.v1+json)
- Set appropriate HTTP headers: Content-Type: application/json, Cache-Control, ETag

## Relevant Business Logic

- Logs are part of observability & compliance, capturing events like audit_event, request-id, and system metrics
- Retrieval should respect data storage in UTC and any soft deletes for archival purposes
- If logs are linked to other domains (e.g., orders, payments), ensure referential integrity but do not expand relations unless specified
- Apply domain guards if log access involves sensitive areas like fraud or payments
- State machines are not directly applicable here, but ensure retrieval does not allow illegal state transitions indirectly
- For compliance, mask PII in response (e.g., customer data in log context)
- Integrate with queues/caching/etag for performance, especially if logs are high-volume"
194,audit,Audit Trail,Entity-level change history,api/audit/{entity}/{id},get,Admin,Implement Audit Trail API: Entity-Level Change History,"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint provides entity-level change history through the audit trail, retrieving audit events for a specific entity and ID. It falls under the 'audit' category and supports observability & compliance features like audit_event tracking.

## API Specifications

- **Category:** audit
- **Title:** Audit Trail
- **Description:** Entity-level change history
- **Route:** api/audit/{entity}/{id}
- **Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET endpoint at api/audit/{entity}/{id} to retrieve audit events for the specified entity and ID
- [ ] Ensure the endpoint requires Admin authentication and proper RBAC permission checks
- [ ] Add input validation for {entity} (e.g., valid entity types like 'product', 'order') and {id} (positive integer or UUID)
- [ ] Support pagination, filtering (e.g., by date range, event type), and sorting for audit events
- [ ] Handle soft deletes and archival data appropriately in audit retrieval
- [ ] Return RFC7807 problem+json for validation errors, unauthorized access, or non-existent entity/ID
- [ ] Write unit and integration tests covering success, error cases, auth failures, and edge cases (e.g., no audits)
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger)
- [ ] Ensure compliance with middleware stack: auth, RBAC, request-id, PII masking for sensitive audit data

## Technical Requirements

- Use Laravel controller (e.g., AuditController) and define route in api.php with resource constraints
- Leverage Eloquent models for audit_event entity, supporting polymorphic relations to audited entities
- Implement query builder for efficient retrieval: join with audit_event table, filter by auditable_type ({entity}) and auditable_id ({id})
- Include fields like event timestamp (UTC), user_id (who made change), event_type (create/update/delete), old_values/new_values (JSON diff), IP, user_agent
- Apply caching/etag if applicable, but prioritize real-time audit integrity
- Integrate with state machines if audits relate to transitions (e.g., order state changes)
- Use queues for any heavy audit logging, but retrieval should be synchronous
- Ensure transactional consistency: audits posted on every stock/financial/event as per design

## Authentication/Authorization Requirements

- Requires Admin role via RBAC: check user_role and ability (role↔perm) for 'view-audit' permission
- Enforce middleware: auth (JWT/API key), active user, email-verified, 2FA if enabled
- Branch scope if applicable (e.g., audits scoped to user's branches)
- Deny access for non-admin users; return 403 Forbidden with problem+json
- Support API keys for machine-to-machine audit access if Admin-equivalent

## Expected Request/Response Format Considerations

- **Request:** GET /api/audit/{entity}/{id}?page=1&per_page=50&from_date=2023-01-01&to_date=2023-12-31&event_type=update (query params for pagination/filtering)
  - Validate entity as string (e.g., 'orders', 'products'), id as integer/UUID
  - Optional params: page (int), per_page (1-100), from_date/to_date (ISO 8601), event_type (enum: create/update/delete/restore)
- **Response (200 OK):** JSON array of audit events, e.g., {""data"": [{ ""id"": 1, ""event_type"": ""update"", ""old_values"": {""price"": 10}, ""new_values"": {""price"": 15}, ""user_id"": 123, ""created_at"": ""2023-01-01T00:00:00Z"", ""ip_address"": ""127.0.0.1"" }], ""meta"": {""current_page"": 1, ""total"": 100 }}
  - Use JSON:API or standard Laravel pagination format
  - Mask PII in old/new_values (e.g., emails, names) per compliance
- **Errors:** 400 Bad Request (invalid entity/id/params), 401 Unauthorized, 403 Forbidden, 404 Not Found (entity not exist or no audits), 500 Internal Server Error
  - All errors as RFC7807 problem+json: {""title"": ""Invalid Entity"", ""detail"": ""Entity 'invalid' not recognized"", ""status"": 400, ""type"": ""/errors/validation""}

## Relevant Business Logic

- Audits capture all changes to core entities (e.g., product updates, order state transitions) via observers or event listeners
- Support polymorphic audits for related entities (e.g., order_item changes linked to order)
- Ensure audits are immutable and timestamped in UTC; include referential links for context
- Integrate with reporting: allow audits to feed into activity logs, compliance checks
- Handle bulk operations: if entity has multiple IDs (though route is singular), consider extension for bulk
- Conflicts (e.g., concurrent audits) resolved via request-id and idempotency
- Align with observability: log endpoint calls, metrics for audit retrieval performance"
195,audit,Export Audit,Export audit events,api/audit/export,get,Admin,Implement Export Audit Events API Endpoint (GET /api/audit/export),"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint allows exporting audit events for compliance and observability purposes, supporting PII masking and filtered queries from the audit_event entity.

## API Specifications

- **Category:** audit
- **Title:** Export Audit
- **Description:** Export audit events
- **Route:** api/audit/export
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET /api/audit/export endpoint in Laravel
- [ ] Ensure authentication requires Admin role via RBAC
- [ ] Support query parameters for filtering (e.g., date range, user ID, event type) to export specific audit events
- [ ] Generate export in a secure format (e.g., CSV or Excel) with PII masking applied
- [ ] Stream the response as a downloadable file with appropriate headers (Content-Disposition: attachment)
- [ ] Handle errors with RFC7807 problem+json for invalid filters or unauthorized access
- [ ] Add unit and feature tests covering successful export, filtering, authorization failures, and edge cases (e.g., no results)
- [ ] Document the endpoint in API docs including parameters and response format
- [ ] Integrate with middleware stack (RequestId, auth, RBAC, throttles)

## Technical Requirements

- Use Laravel controller (e.g., AuditController@export) and define route in api.php with 'api' middleware group
- Query the AuditEvent model with Eloquent, applying soft deletes and UTC handling; support pagination or limits for large exports
- Implement input validation using Form Requests for query parameters (e.g., date validation, integer for IDs)
- Use Laravel's Response::streamDownload() or similar for efficient file generation without loading full data into memory
- Apply business logic for audit export: filter by request-id, user, timestamps; ensure compliance with PII masking; log the export event itself
- Error handling: 401/403 for auth issues, 400 for invalid params, 500 for server errors
- Consider caching/etag for repeated exports if applicable, but prioritize idempotency

## Authentication/Authorization Requirements

- Requires Admin authentication (JWT/session/API key)
- RBAC check: User must have permission to view/export audits (e.g., 'audit.export')
- Apply active user, email-verified, and 2FA middleware if enabled
- Branch scope and optional tenancy should not apply to global audit exports

## Expected Request/Response Format Considerations

- **Request:** GET /api/audit/export?from_date=YYYY-MM-DD&to_date=YYYY-MM-DD&user_id=123&event_type=update&limit=1000
  - Query params: Optional filters for date range (UTC), user_id, event_type, etc.; validate and sanitize inputs
  - No request body
- **Response:** 
  - 200 OK: Streamed file (e.g., application/csv) with headers: Content-Type: text/csv, Content-Disposition: attachment; filename=""audit_events_{timestamp}.csv""
  - CSV columns: id, user_id, event_type, timestamp, ip_address, details (masked PII), request_id
  - Empty export: Return 200 with empty file or message
  - Errors: JSON with RFC7807 format, e.g., { ""type"": ""https://example.com/problems/invalid-date"", ""title"": ""Invalid date"", ""status"": 400 }

## Relevant Business Logic

- Audit events track all significant actions (e.g., order updates, inventory adjustments) for compliance
- Exports must respect data retention policies; exclude soft-deleted events unless specified
- Ensure transactional integrity; if export fails mid-stream, handle gracefully without partial data
- Integrate with observability: Log export attempts with request-id; trigger audit_event for the export action itself
- Support bulk export patterns consistent with other Deshio APIs (e.g., no full DB dump without filters to prevent performance issues)"
196,report,Sales Summary,Sales Summary,api/reports/sales-summary,get,Admin,Implement Sales Summary Report API Endpoint,"## Overview

As a technical writer creating GitHub issues for API implementation in the Deshio ERP system, this issue covers the development of the Sales Summary report endpoint. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The Sales Summary endpoint provides aggregated sales data, including revenue, orders, and units by store, product, user, etc., supporting key metrics like LTV/AOV, return/refund rates, and promo impact.

## API Specifications

- **Category:** report
- **Title:** Sales Summary
- **Description:** Sales Summary
- **Route:** api/reports/sales-summary
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET /api/reports/sales-summary endpoint in Laravel
- [ ] Support query parameters for filtering (e.g., date range, store, product, user) and aggregation (e.g., by store/product/user)
- [ ] Ensure response includes key metrics: revenue, orders, units, LTV/AOV, return/refund rates, promo impact
- [ ] Add input validation for query parameters
- [ ] Implement proper error handling with RFC7807 problem+json for conflicts or invalid states
- [ ] Write unit and integration tests covering happy path, edge cases, and authentication
- [ ] Verify integration with reporting/analytics features from Deshio ERD (e.g., orders, payments, inventory movements)
- [ ] Ensure data is aggregated in UTC with soft deletes handled for archival accuracy
- [ ] Test RBAC and permission checks for Admin role only
- [ ] Include observability: audit events, request-id, caching/etag support

## Technical Requirements

- Use Laravel controller and define route in api.php with versioning and content-negotiation middleware
- Leverage Eloquent models for core entities (orders, order_items, payments, stores, products) with strict referential links
- Implement aggregation queries efficiently, potentially using database views or raw SQL for performance on large datasets
- Integrate with state machines for order/payment states to ensure only fulfilled/confirmed data is summarized
- Apply full middleware stack: auth (JWT/API key), RBAC checks, branch scope, throttles, idempotency, input sanitizer
- Handle PII masking in responses for compliance
- Support bulk/export considerations if extended, but focus on JSON response
- Ensure transactional consistency for any underlying ledger postings or movements reflected in summaries
- Use queues for heavy computations if needed, with health/metrics monitoring

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have Admin role with permissions for report access (ability: role↔perm, multi-role support)
- Additional checks: active user, email-verified, 2FA (TOTP + backup codes)
- Branch scope to limit data to authorized stores/branches
- Optional tenancy if multi-tenant setup is enabled
- Reject unauthorized requests with 401/403, logging audit_event

## Expected Request/Response Format Considerations

- **Request:** GET with query params, e.g., ?from=2023-01-01&to=2023-12-31&store_id=1&group_by=store,product
  - Validate params: dates in ISO format, IDs as integers, group_by enum (store/product/user/etc.)
  - Sanitize inputs to prevent injection
- **Response:** JSON object with aggregated data, e.g., {""total_revenue"": 10000, ""orders_count"": 500, ""units_sold"": 2000, ""breakdown"": [...], ""metrics"": {""ltv"": 150, ""aov"": 50}}
  - Use RFC7807 for errors: {""type"": ""https://example.com/probs/invalid-date"", ""title"": ""Invalid date range"", ""status"": 400}
  - Include cache headers, etag for conditional requests
  - Paginate if large datasets, but prefer summaries
  - All timestamps in UTC

## Relevant Business Logic

- Aggregate from order domain: Filter by states (confirmed→fulfilled), apply promos/taxes, sync with payment_status
- Include returns/refunds impact on net revenue (RMA, refunds, exchanges)
- Factor in inventory movements (reservations, adjustments, shipments, dispatches) for units sold
- Support analytics: revenue/orders/units by store/product/user, return/refund rates, promo impact, activity
- Ensure deterministic calculations, consistent with accounting ledger_entries for all financial events
- Handle soft deletes: Exclude deleted records from summaries
- Conflicts (e.g., invalid date range) trigger state machine validation and error responses
- Integrate with observability: Log requests, mask PII, track metrics for SLA/dispatch performance if relevant"
197,report,Revenue by Day,Revenue by Day,api/reports/revenue-by-day,get,Admin,Implement Revenue by Day Report API Endpoint,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the 'Revenue by Day' API endpoint. This endpoint falls under the reporting category and provides aggregated revenue data by day, supporting analytics such as revenue by store/product/user, LTV/AOV, and other metrics. Core entities include product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. Order domain handles states (pending→confirmed→fulfilled|cancelled), assignment, notes/attachments, promos, taxes, fraud flags. Fulfillment includes shipments, inter-store dispatch with tracking. Returns via RMA with receive/restock/scrap, refunds, exchanges. Payments with intent→capture/void, refunds, synchronization. Accounting with transaction headers + ledger entries, reversals, reconciliation. Services with service orders and profitability. Integrations for carriers, webhooks, notifications. Security with user/role/permission, sessions, email verification, password reset, TOTP MFA, API keys. Observability includes audit events, logs, PII masking, health/metrics, queues, caching. Middleware covers TLS/HSTS, CORS, auth (JWT/session/API key), RBAC, branch scope, throttles, idempotency, sanitizers, domain guards. Reporting includes revenue/orders/units by various dimensions, return rates, SLA, inventory aging, promo impact. State machines ensure legal transitions; conflicts return RFC7807 problem+json. APIs support bulk import/export, search, attachments, reindex, backups, feature flags. Data in UTC; soft deletes; EAV for attributes; polymorphic notes; strict referential links. Design enables deterministic assignment, safe reservations, consistent ledger posting.

This endpoint will query and aggregate revenue from orders, payments, and ledger entries to provide daily revenue insights.

## API Specifications

- **Category:** report
- **Title:** Revenue by Day
- **Description:** Revenue by Day
- **Route:** api/reports/revenue-by-day
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET endpoint at api/reports/revenue-by-day
- [ ] Ensure authentication requires Admin role with proper RBAC checks
- [ ] Support query parameters for filtering (e.g., date range, store/branch, product/category)
- [ ] Aggregate revenue from confirmed/fulfilled orders and captured payments
- [ ] Handle timezone/locale via middleware (data in UTC)
- [ ] Return results in JSON format with daily breakdowns
- [ ] Include proper error handling for invalid inputs or unauthorized access (RFC7807 problem+json)
- [ ] Add unit/integration tests covering happy path, edge cases, and auth failures
- [ ] Document the endpoint in API specs (e.g., OpenAPI)
- [ ] Ensure performance for large datasets with pagination or limits if needed
- [ ] Verify integration with state machines for order/payment states
- [ ] Test for idempotency and caching/etag support

## Technical Requirements

- Use Laravel controller (e.g., ReportController) and define route in api.php with versioned prefix
- Implement input validation using Form Requests (e.g., date range, filters)
- Query database using Eloquent models for orders, payments, ledger_entries, stores, etc., with joins/aggregates (e.g., SUM on revenue fields grouped by DATE)
- Apply branch scope middleware if filtering by store/branch
- Use soft deletes awareness; exclude deleted records unless specified
- Handle polymorphic relations if notes/attachments needed (though likely not for this report)
- Ensure transactional consistency for any related ledger postings (read-only for report)
- Add logging/audit_event for endpoint access
- Support bulk/export if extended, but focus on GET response
- Optimize with indexes on date/store/product fields
- Include request-id, CORS, JSON limits via middleware

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have 'report.view' permission or equivalent in their roles
- Active user check, email-verified, 2FA if enabled
- Branch scope: Limit data to user's accessible branches unless global admin
- Optional tenancy if multi-tenant setup
- Reject unauthenticated/unauthorized with 401/403 and problem+json

## Expected Request/Response Format Considerations

- **Request:** GET api/reports/revenue-by-day?from=YYYY-MM-DD&to=YYYY-MM-DD&store_id=1&branch_id=2&product_id=3&format=json (use content-negotiation for versioned responses)
- **Response:** 200 OK with JSON array/object, e.g., {""data"": [{""date"": ""2023-01-01"", ""revenue"": 1500.00, ""currency"": ""USD"", ""store_id"": 1, ""units"": 10}], ""meta"": {""total"": 100, ""from"": ""2023-01-01"", ""to"": ""2023-01-31""}}
- Include ETag for caching, rate limiting via throttles
- Errors: 400 for invalid params, 422 validation, 500 internal with masked PII
- Support locale/tz for date formatting in response

## Relevant Business Logic

- Aggregate revenue only from confirmed/fulfilled orders with captured payments (exclude pending/cancelled/voided)
- Include taxes/promos/discounts as per pricing rules; use price_override if applicable
- Factor in refunds/exchanges: Deduct from gross revenue for net calculation
- Source from ledger_entry lines for financial accuracy, ensuring reversals are applied
- Handle multi-store: Filter/aggregate by store/branch as requested
- Currency handling: Assume base currency unless specified
- Align with inventory movements if revenue ties to stock sales
- Use state machines to validate order/payment states in queries
- For analytics: Enable filtering by product/category/vendor for deeper insights
- Ensure deterministic results with UTC dates; no timezone conversion in aggregation"
198,report,Revenue by Store,Revenue by Store,api/reports/revenue-by-store,get,Admin,Implement GET /api/reports/revenue-by-store API Endpoint,"## Overview

Deshio is a Laravel-based ERP system for retail/omni-channel operations, featuring approximately 290 REST APIs built over a normalized ERD. It covers key domains including catalog (products/categories/vendors with attributes, media, barcodes, pricing, promotions), stores/branches, customers with tags/blacklist, batch-centric inventory (reservations, adjustments, cycle counts, valuation, ledgers), orders (order/order_item states: pending→confirmed→fulfilled|cancelled, assignment to store, notes/attachments, promos, taxes, fraud flag), fulfillment (shipments/shipment_item, inter-store dispatch with tracking/scan events/POD, transactional stock movements), returns (RMA/return_item, receive/restock/scrap, refunds, exchanges), payments (intent→payment capture/void, refund lifecycle, order.payment_status sync), accounting (transaction headers + ledger_entry lines, reversals, reconciliation/export), services (service/service_order lifecycle/profitability), integrations (carriers/accounts, waybills/rates/tracking, webhooks, notification templates), security/identity (user/role/permission with abilities, multi-role, sessions, email verification, password reset, TOTP MFA + backup codes, API keys), observability/compliance (audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag), middleware (TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth via JWT/session/API key, active user, email-verified, 2FA, RBAC/permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards for order/payment/dispatch/reservation/promo/override/cycle-count/fraud, upload mime guard, provider webhook signatures + replay defense, cache headers), reporting/analytics (revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity), state machines for transitions (orders, items, dispatch, shipments, returns, payments, cycle counts; conflicts via RFC7807 problem+json), bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data in UTC, soft deletes, EAV for attributes, polymorphic notes/attachments, strict referential links. Design supports deterministic admin assignment, safe reservation/consumption, consistent ledger posting.

This API endpoint implements the 'Revenue by Store' report, providing revenue analytics aggregated by store, including metrics like revenue, orders, units sold, potentially filtered by date range, product, or other parameters. It leverages the reporting domain to query order, payment, and store data for accurate financial insights.

## API Specifications

- **Category:** report
- **Title:** Revenue by Store
- **Description:** Revenue by Store
- **Route:** api/reports/revenue-by-store
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET endpoint handler in a Laravel controller
- [ ] Support query parameters for filtering (e.g., date range, store IDs, product categories) to generate revenue reports by store
- [ ] Ensure response includes aggregated data: revenue totals, order counts, units sold per store, with optional breakdowns (e.g., by product/vendor)
- [ ] Add input validation for query parameters using Laravel's validation rules
- [ ] Implement proper error handling, returning RFC7807 problem+json for validation errors or unauthorized access
- [ ] Write unit and feature tests covering successful responses, edge cases (e.g., no data, invalid filters), and authentication failures
- [ ] Verify integration with state machines and ledger data for accurate revenue calculation (e.g., confirmed/fulfilled orders, captured payments)
- [ ] Ensure compliance with middleware stack: auth, RBAC, branch scope, throttling, caching/etag
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger) with request/response examples
- [ ] Performance: Optimize queries for large datasets using indexes on order/store/payment tables

## Technical Requirements

- Use Laravel framework: Create a dedicated controller (e.g., ReportController) with route registration in api.php
- Query builder or Eloquent for aggregating data from orders, order_items, payments, stores (e.g., sum(revenue) group by store_id where payment_status='captured' and order_status='fulfilled')
- Input validation: Use FormRequest or controller validation for params like ?from_date=YYYY-MM-DD&to_date=YYYY-MM-DD&store_ids[]=1&store_ids[]=2
- Pagination support if results are large (e.g., via ?page=1&per_page=50)
- Response format: JSON array of store objects with revenue metrics (e.g., {store_id: 1, store_name: 'Main Branch', total_revenue: 15000.00, order_count: 100, units_sold: 500})
- Error handling: 401 Unauthorized, 403 Forbidden, 422 Unprocessable Entity with problem+json
- Logging: Audit events for report access, include request-id
- Caching: Etag or query cache for repeated requests
- Soft deletes: Exclude deleted records in queries
- UTC handling: Ensure date filters align with stored UTC timestamps

## Authentication/Authorization Requirements

- Requires Admin authentication (JWT/session/API key)
- RBAC: User must have 'admin' role or specific permission (e.g., 'view_revenue_reports') via ability checks
- Middleware: Apply auth, active user, email-verified, 2FA (if enabled), RBAC/permission checks, branch scope (if multi-branch)
- Optional: Tenancy isolation if multi-tenant setup

## Expected Request/Response Format Considerations

- **Request:** GET /api/reports/revenue-by-store?from_date=2023-01-01&to_date=2023-12-31&store_ids[]=1&include_breakdown=true
  - Headers: Authorization: Bearer <token>, Accept: application/json, X-Request-Id: <uuid>
- **Success Response (200):** 
  {
    ""data"": [
      {
        ""store_id"": 1,
        ""store_name"": ""Main Store"",
        ""total_revenue"": 15000.50,
        ""order_count"": 200,
        ""units_sold"": 1000,
        ""breakdown"": { ""by_product"": [...] } // if requested
      }
    ],
    ""meta"": { ""total_stores"": 5, ""filtered_revenue"": 75000.00 }
  }
- **Error Response (e.g., 422):** 
  {
    ""title"": ""Validation Error"",
    ""detail"": ""Invalid date range"",
    ""status"": 422,
    ""problems"": [ { ""field"": ""from_date"", ""message"": ""Date must be valid"" } ]
  }
- Content negotiation: Versioned (e.g., /v1/), locale/tz support for dates

## Relevant Business Logic

- Revenue calculation: Sum of captured payment amounts for confirmed/fulfilled orders assigned to each store, excluding returns/refunds (net revenue)
- Filters: Date range defaults to last 30 days; store_ids for specific branches; integrate with promotions/taxes for accurate totals
- Analytics tie-in: Align with LTV/AOV, return rates; exclude fraud-flagged orders
- Ledger consistency: Base on accounting transaction headers/ledger_entries for financial accuracy
- State machines: Only include orders/payments in valid states (e.g., no pending/cancelled for revenue)
- Compliance: Mask PII in logs; audit report generation events"
199,report,Revenue by Product,Revenue by Product,api/reports/revenue-by-product,get,Admin,Implement GET /api/reports/revenue-by-product API Endpoint,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs over a normalized ERD, implement the 'Revenue by Product' report endpoint. This endpoint falls under the reporting/analytics category, providing revenue metrics by product, aligning with core entities like products/categories/vendors, pricing (including price_overrides and promotions), orders/order_items, and accounting ledgers. It supports features such as revenue by store/product/user, LTV/AOV calculations, and promo impact analysis. The system uses UTC storage, soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential integrity. State machines ensure legal transitions, with conflicts returning RFC7807 problem+json. Middleware includes TLS/HSTS, CORS, auth (JWT/session/API key), RBAC, branch scope, throttles, idempotency, and more. This endpoint enables deterministic reporting for online orders, reservations, and ledger postings on stock/financial events.

Brief overview: The endpoint retrieves revenue data aggregated by product, potentially filtered by date ranges, stores, or other criteria, to support business intelligence in retail operations.

## API Specifications

- **Category:** report
- **Title:** Revenue by Product
- **Description:** Revenue by Product
- **Route:** api/reports/revenue-by-product
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET endpoint at /api/reports/revenue-by-product in a Laravel controller
- [ ] Support query parameters for filtering (e.g., date_from, date_to, store_id, product_id) based on reporting needs
- [ ] Return aggregated revenue data by product in JSON format, including fields like product_id, product_name, total_revenue, units_sold, and promo_discounts
- [ ] Apply Admin authentication and RBAC permissions
- [ ] Handle errors with RFC7807 problem+json for invalid inputs or unauthorized access
- [ ] Include unit tests for successful responses, edge cases (e.g., no data), and authentication failures
- [ ] Ensure response caching with ETag and proper cache headers
- [ ] Validate inputs with Laravel's validation rules and sanitizer middleware
- [ ] Integrate with inventory/ledger data for accurate revenue calculations, considering promotions, taxes, and refunds
- [ ] Support bulk export if applicable, aligning with system features like search/autosuggest and reindex

## Technical Requirements

- Use Laravel framework: Define route in api.php, create a dedicated controller (e.g., ReportController) with the revenueByProduct method
- Query database using Eloquent models for products, orders, order_items, payments, and ledger_entries; aggregate revenue from confirmed/fulfilled orders minus refunds/exchanges
- Implement business logic for revenue calculation: Sum (order_item quantity * price) adjusted for promotions, taxes, and payment_status synchronization; account for batch-centric inventory and reservations
- Handle date filtering in UTC, with locale/tz middleware support
- Use RequestId middleware for observability; log audit_events for report access
- Apply domain guards for order/payment/reservation/promo data access
- Ensure soft deletes are respected in queries; use EAV for product attributes in reports
- For performance: Use queues/caching if large datasets; support pagination for extensive results
- Error handling: 400 for validation errors, 401/403 for auth issues, 500 for server errors with PII masking
- Integrations: Align with webhooks/notifications if report triggers alerts (e.g., low revenue); consider feature flags for endpoint enablement

## Authentication/Authorization Requirements

- Require Admin role via RBAC: Check user_role and ability (role↔perm) for 'view-revenue-reports' permission
- Use JWT/session/API key auth middleware, followed by active user, email-verified, and optional 2FA checks
- Apply branch scope to limit data to authorized stores/branches
- Enforce throttles and idempotency for repeated requests
- Include session management and API keys for secure access

## Expected Request/Response Format Considerations

- **Request:** GET with query params, e.g., ?date_from=2023-01-01&date_to=2023-12-31&store_id=1&product_category=electronics. Use content-negotiation for JSON; apply JSON limits and input sanitizer.
- **Response:** 200 OK with JSON array/object, e.g., {""data"": [{""product_id"": 123, ""name"": ""Widget"", ""revenue"": 15000.00, ""units"": 100, ""avg_price"": 150.00}], ""meta"": {""total"": 1, ""filters_applied"": {...}}}. Include cache headers and ETag. For errors: problem+json per RFC7807, e.g., {""type"": ""https://example.com/probs/validation"", ""title"": ""Invalid Input"", ""detail"": ""Date format invalid""}.
- Support versioned API (e.g., /v1/reports/...); optional tenancy middleware.

## Relevant Business Logic

- Revenue derivation: From order domain (pending→confirmed→fulfilled|cancelled states), including promos, taxes, fraud flags, and payment captures/refunds. Sync with accounting transaction headers and ledger_entry lines for all movements/reversals.
- Product linkage: Via product/category/vendor entities with attributes, media, barcodes, and pricing overrides.
- Inventory integration: Batch-centric with reservations/adjustments; ensure revenue reflects fulfilled shipments/dispatches, RMAs (returns/restock/refunds/exchanges), and inter-store movements.
- Reporting specifics: Align with analytics like revenue by store/product/user, return/refund rates, promo impact, and inventory aging. Use state machines for data consistency; support cycle counts and price change history if filtering by periods.
- Compliance: Audit report access; PII masking in logs; health/metrics for endpoint performance."
200,report,Top Products,Top Products,api/reports/top-products,get,Admin,Implement GET /api/reports/top-products for Top Products Report,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue covers the implementation of the 'Top Products' report API endpoint. This endpoint will provide insights into top-performing products based on metrics like revenue, orders, or units sold, aligning with the reporting/analytics features such as revenue/orders/units by store/product/user, LTV/AOV, and promo impact.

Core entities involved include products/categories/vendors with attributes, pricing, promotions, and inventory batches. The system supports state machines for transitions, soft deletes, EAV for attributes, polymorphic notes/attachments, and data in UTC. Middleware includes auth (JWT/session/API key), RBAC, branch scope, throttles, idempotency, and error handling via RFC7807 problem+json.

This API falls under the 'report' category and enables admins to fetch top products data for analytics and decision-making.

## API Specifications

- **Category:** report
- **Title:** Top Products
- **Description:** Top Products
- **Route:** api/reports/top-products
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint returns top products based on configurable metrics (e.g., revenue, units sold) over a specified period
- [ ] Supports query parameters for filtering by date range, store/branch, category, or top N count
- [ ] Response includes product details like ID, name, SKU, sales metrics, and rankings
- [ ] Handles pagination for large datasets
- [ ] Implements proper authentication and authorization for admin users only
- [ ] Includes unit and integration tests covering success, error cases, and edge scenarios
- [ ] Adheres to API versioning, content-negotiation, and caching/etag for performance
- [ ] Generates audit events for API calls
- [ ] Ensures PII masking if applicable and request-id tracing

## Technical Requirements

- Create a Laravel controller (e.g., ReportController) with a topProducts method
- Define the route in api.php with proper middleware stack: auth, active user, RBAC (admin permission), branch scope
- Use Eloquent queries or a reporting service to aggregate data from orders, order_items, products, and inventory tables
- Implement input validation using Form Requests for query params (e.g., date_from, date_to, limit, metric)
- Handle business logic: Calculate top products using joins on order/order_item for sales data, respecting soft deletes and UTC timestamps; support optional per-unit items and batch inventory
- Integrate with state machines if needed for order states (e.g., confirmed/fulfilled)
- Proper error handling: Return RFC7807 problem+json for invalid inputs, unauthorized access, or query failures
- Optimize for performance: Use indexes on date/store/product fields, caching where appropriate

## Authentication/Authorization Requirements

- Requires admin authentication via JWT, session, or API key
- RBAC check: User must have 'admin' role or specific 'view_reports' permission
- Enforce email verification and optional 2FA
- Branch scope: Limit data to user's assigned branches unless global admin
- Include security middleware: TLS/HSTS, CORS, throttles, idempotency

## Expected Request/Response Format Considerations

- **Request:** GET /api/reports/top-products?date_from=2023-01-01&date_to=2023-12-31&limit=10&metric=revenue&store_id=1
  - Query params: date_from (date, optional), date_to (date, optional), limit (int, default 10), metric (string: revenue|units|orders, default revenue), store_id (int, optional), category_id (int, optional)
  - No body required

- **Response:** JSON array of top products, e.g.,
  [
    {
      ""rank"": 1,
      ""product_id"": 123,
      ""name"": ""Product Name"",
      ""sku"": ""SKU123"",
      ""category_id"": 45,
      ""total_revenue"": 15000.00,
      ""units_sold"": 500,
      ""orders_count"": 200
    }
  ]
  - Include pagination metadata if applicable (e.g., total, per_page)
  - Success: 200 OK
  - Errors: 400 Bad Request (validation), 401 Unauthorized, 403 Forbidden, 422 Unprocessable Entity

- Use versioned content-negotiation (e.g., Accept: application/vnd.deshio.v1+json)
- Set cache headers and ETag for repeatable queries

## Relevant Business Logic

- Top products derived from fulfilled orders (state: confirmed→fulfilled), excluding cancelled/returned items
- Aggregate metrics: revenue (sum of order_item totals with promos/taxes applied), units (sum of quantities), orders (distinct count)
- Respect inventory reservations, adjustments, and cycle counts for accurate stock context
- Handle price overrides, promotions, and fraud flags in calculations
- Ensure deterministic results with consistent UTC handling and referential integrity
- If no data, return empty array with 200 OK
- Align with accounting ledger for financial accuracy and reporting exports"
201,report,Top Customers,Top Customers,api/reports/top-customers,get,Admin,Implement Top Customers Report API Endpoint,"## Overview

This GitHub issue covers the implementation of the 'Top Customers' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD that covers catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes (fields/features), media (product images), barcodes, pricing (price overrides), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flags. Fulfillment handles shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns manage RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments cover intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting includes transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services handle service/service_order with lifecycle and profitability. Integrations include carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The 'Top Customers' endpoint is a reporting API that retrieves top customers based on metrics such as revenue, order count, units purchased, LTV/AOV, return/refund rates, or other activity indicators, filtered by time periods, stores, or other criteria.

## API Specifications

- **Category:** report
- **Title:** Top Customers
- **Description:** Top Customers
- **Route:** api/reports/top-customers
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET endpoint at api/reports/top-customers that returns a list of top customers with relevant metrics (e.g., revenue, order count, LTV/AOV)
- [ ] Support query parameters for filtering (e.g., ?top_n=10&period=last_30_days&metric=revenue&store_id=1)
- [ ] Ensure response includes customer details (ID, name, email, tags) while masking PII if required
- [ ] Add input validation for query parameters
- [ ] Implement proper error handling with RFC7807 problem+json for invalid requests or unauthorized access
- [ ] Write unit and integration tests covering success, edge cases (e.g., no data, invalid params), and authentication failures
- [ ] Verify caching/etag support for performance
- [ ] Ensure audit_event logging for endpoint access
- [ ] Confirm compatibility with middleware stack (auth, RBAC, throttles, etc.)
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger)

## Technical Requirements

- Use Laravel controller (e.g., ReportController) and define route in api.php with appropriate middleware
- Leverage Eloquent models for customers, orders, payments, etc., with efficient queries (e.g., joins, aggregations) to compute top customers
- Implement input validation using Laravel's Form Requests or Validator for query params (e.g., integer for top_n, date ranges)
- Handle pagination if large datasets are expected, or limit results based on top_n param
- Use state machines if any order/payment states need filtering (e.g., only confirmed orders)
- Ensure soft deletes are respected and data is in UTC
- Integrate with reporting/analytics logic for metrics like revenue by user, LTV/AOV

## Authentication/Authorization Requirements

- Require Admin authentication (JWT/session/API key)
- Enforce RBAC: Only users with 'admin' role or 'view_reports' permission can access
- Apply active user, email-verified, and 2FA checks via middleware
- Include branch scope if reports are store-specific
- Reject unauthorized access with 403 Forbidden and appropriate error message

## Expected Request/Response Format Considerations

- **Request:** GET with query params, e.g., ?top_n=10&start_date=2023-01-01&end_date=2023-12-31&sort_by=revenue&store_id=1. No request body.
- **Response:** JSON array of top customers, e.g., {""data"": [{""customer_id"": 123, ""name"": ""John Doe"", ""email"": ""masked@example.com"", ""total_revenue"": 1500.00, ""order_count"": 5, ""ltv"": 300.00, ""aov"": 300.00}], ""meta"": {""total"": 10, ""period"": ""2023-01-01 to 2023-12-31""}}. Use 200 OK for success.
- **Errors:** 400 Bad Request for invalid params, 401 Unauthorized, 403 Forbidden, 500 Internal Server Error with problem+json details.
- Support content-negotiation, locale/tz for dates, and idempotency if needed.

## Relevant Business Logic

- Compute top customers using aggregations from orders, payments, and customer entities (e.g., sum(revenue) GROUP BY customer_id HAVING conditions).
- Filter by time periods, stores/branches, exclude blacklisted customers.
- Include metrics like LTV (lifetime value), AOV (average order value), return/refund rates from related domains.
- Ensure transactional consistency; use read replicas if performance demands.
- Align with observability: log request-id, mask PII in logs/responses.
- Consider feature flags for enabling/disabling certain metrics or filters."
202,report,Customer LTV,Customer LTV,api/reports/customer-ltv,get,Admin,Implement Customer LTV Report API Endpoint,"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This issue is for implementing the Customer LTV (Lifetime Value) report API endpoint, which provides analytics on customer lifetime value, including revenue/orders/units by user, LTV/AOV calculations, as part of the reporting category.

## API Specifications

- **Category:** report
- **Title:** Customer LTV
- **Description:** Customer LTV
- **Route:** api/reports/customer-ltv
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET /api/reports/customer-ltv endpoint in a Laravel controller
- [ ] Ensure the endpoint requires Admin authentication and RBAC permission checks
- [ ] Support query parameters for filtering (e.g., date range, customer segments, stores/branches)
- [ ] Return LTV calculations based on customer orders, revenue, and related metrics (AOV, return/refund rates)
- [ ] Handle pagination, sorting, and searching for large datasets
- [ ] Include proper error handling with RFC7807 problem+json for invalid requests or conflicts
- [ ] Add unit and integration tests covering success, edge cases, and authorization failures
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger)
- [ ] Ensure response data is masked for PII compliance and uses UTC timestamps
- [ ] Verify integration with middleware stack (auth, throttling, idempotency, etc.)

## Technical Requirements

- Use Laravel controller and routes for implementation
- Leverage Eloquent models for customers, orders, payments, and analytics queries
- Implement efficient querying with joins across orders, order_items, payments, and customer entities
- Support bulk data handling if needed, with caching/etag for performance
- Integrate with reporting/analytics features: revenue/orders/units by store/product/user, LTV/AOV
- Use state machines if applicable for order/payment states in calculations
- Apply soft deletes and archival handling in queries
- Ensure transactional consistency for any underlying data movements or ledgers
- Follow middleware plan: auth (JWT/API key), RBAC, branch scope, throttles, input sanitizer
- Handle observability: audit_event logging, request-id tracing, metrics for endpoint

## Authentication/Authorization Requirements

- Requires Admin role with specific permissions for report access
- Enforce RBAC & permission checks via middleware
- Support JWT/session/API key auth
- Additional checks: active user, email-verified, 2FA if enabled
- Branch scope and optional tenancy enforcement

## Expected Request/Response Format Considerations

- **Request:** GET with optional query params (e.g., ?date_from=YYYY-MM-DD&date_to=YYYY-MM-DD&customer_id=123&store_id=456&limit=100&page=1&sort=ltv_desc)
- **Response:** JSON array of customer LTV data, e.g., { ""data"": [{ ""customer_id"": 123, ""ltv"": 1500.00, ""aov"": 75.00, ""order_count"": 20, ""first_order_date"": ""2023-01-01T00:00:00Z"", ""last_order_date"": ""2024-01-01T00:00:00Z"" }], ""meta"": { ""total"": 100, ""per_page"": 100, ""current_page"": 1 } }
- Use versioned content-negotiation and locale/tz handling
- Include cache headers and etag for responses
- Errors: RFC7807 problem+json, e.g., { ""title"": ""Invalid Date Range"", ""status"": 400, ""detail"": ""Date from cannot be after date to"" }

## Relevant Business Logic

- Calculate LTV as total revenue from a customer's orders minus refunds/returns over a period
- Factor in AOV (Average Order Value), order frequency, and customer tags/blacklist status
- Aggregate by store/branch, product/category if filtered
- Exclude cancelled/pending orders; use confirmed/fulfilled states
- Synchronize with payment statuses and ledger entries for accurate financials
- Consider promotions, taxes, and fraud flags in revenue calculations
- Support analytics like return/refund rates impacting LTV
- Ensure deterministic calculations with UTC data and strict referential integrity"
203,report,Abandoned Orders,Abandoned Orders,api/reports/abandoned-orders,get,Admin,Implement Abandoned Orders Report API Endpoint,"## Overview

This GitHub issue is for implementing the 'Abandoned Orders' report API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD that covers catalog, orders, inventory, logistics, payments, RBAC, and audits.

Core entities include: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.

Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.

Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.

Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).

Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.

Services: service/service_order with lifecycle and profitability.

Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.

Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The 'Abandoned Orders' endpoint will provide a report on orders that reach a pending state but are not confirmed within a configurable timeframe, aiding in analytics for cart abandonment rates and recovery strategies.

## API Specifications

- **Category:** report
- **Title:** Abandoned Orders
- **Description:** Abandoned Orders
- **Route:** api/reports/abandoned-orders
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET endpoint at api/reports/abandoned-orders
- [ ] Ensure the endpoint requires Admin authentication and authorization
- [ ] Support query parameters for filtering (e.g., date range, store/branch, status thresholds)
- [ ] Return a paginated list of abandoned orders with relevant details (order ID, customer info, items, timestamp, abandonment reason if applicable)
- [ ] Include response in JSON format with proper structure (e.g., data array, metadata for pagination)
- [ ] Handle errors per RFC7807 problem+json for invalid inputs or unauthorized access
- [ ] Add unit and integration tests covering happy path, edge cases, and authentication failures
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger)
- [ ] Ensure compliance with middleware stack (e.g., RBAC checks, request ID, caching)
- [ ] Verify integration with order state machine for accurate abandonment detection
- [ ] Performance: Endpoint should handle queries efficiently with indexing on order timestamps and states

## Technical Requirements

- Use Laravel controller (e.g., ReportController) and define route in api.php with proper middleware
- Leverage Eloquent models for orders (Order, OrderItem) and related entities (Customer, Store)
- Implement query builder or repository pattern for fetching abandoned orders (e.g., where state = 'pending' and created_at < threshold)
- Apply soft deletes awareness and UTC handling
- Integrate with reporting/analytics features for metrics like abandonment rate
- Use state machines to validate order states
- Support bulk export if extended, but focus on paginated GET
- Ensure referential integrity with junctions (e.g., order_items, promotions)
- Add audit_event logging for endpoint access

## Authentication/Authorization Requirements

- Requires Admin role via RBAC (user/role/permission with ability checks)
- Apply middleware: auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope
- Deny access for non-admin users with 403 Forbidden (RFC7807)
- Support API keys for automated reporting tools

## Expected Request/Response Format Considerations

- **Request:** GET api/reports/abandoned-orders?from_date=YYYY-MM-DD&to_date=YYYY-MM-DD&store_id=1&limit=50&offset=0
  - Query params: Optional filters for date range, store/branch, threshold days; pagination (limit/offset or page/size)
  - No request body

- **Response (200 OK):** JSON object
  {
    ""data"": [
      {
        ""id"": 123,
        ""customer"": {""id"": 456, ""name"": ""John Doe"", ""email"": ""masked@example.com""},
        ""store"": {""id"": 1, ""name"": ""Branch A""},
        ""items"": [{""product_id"": 789, ""quantity"": 2, ""price"": 10.00}],
        ""created_at"": ""2023-10-01T12:00:00Z"",
        ""abandoned_at"": ""2023-10-02T12:00:00Z"",
        ""subtotal"": 20.00,
        ""status"": ""pending""
      }
    ],
    ""meta"": {""total"": 100, ""limit"": 50, ""offset"": 0, ""abandonment_rate"": 15.5}
  }
  - PII masking for compliance (e.g., email partial masking)
  - ETag/caching headers for repeat requests

- **Error Responses:**
  - 401 Unauthorized: Missing/invalid auth
  - 403 Forbidden: Insufficient permissions
  - 422 Unprocessable Entity: Invalid query params (with validation details)
  - 500 Internal Server Error: Unexpected issues (logged)

## Relevant Business Logic

- Define abandonment as orders in 'pending' state older than a configurable threshold (e.g., 24 hours) without confirmation
- Exclude fraud-flagged or blacklisted customer orders if specified
- Calculate derived metrics like abandonment rate (abandoned / total sessions or carts)
- Tie into order lifecycle: pending → confirmed → fulfilled|cancelled; use state machine for transitions
- Support branch scoping: Limit results to user's assigned branches
- Ensure transactional consistency; no direct mutations, read-only report
- Integrate with analytics: Feed into LTV/AOV, return/refund rates, activity reports
- Handle promotions/taxes in subtotal calculations for accurate reporting
- Comply with observability: Log request-id, audit access, mask PII in logs"
204,report,Inventory Snapshot,Inventory Snapshot,api/reports/inventory-snapshot,get,Admin,Implement Inventory Snapshot Report API Endpoint,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue covers the implementation of the Inventory Snapshot report API endpoint. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. The Inventory Snapshot provides a current view of inventory levels across batches, reservations, and valuations, enabling reporting on stock positions, aging, low stock alerts, and cycle count accuracy. This aligns with reporting/analytics features like inventory aging/low stock, cycle count accuracy, and activity metrics. State machines drive legality of transitions for related entities like cycle counts; conflicts return RFC7807 problem+json. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

## API Specifications

- **Category:** report
- **Title:** Inventory Snapshot
- **Description:** Inventory Snapshot
- **Route:** api/reports/inventory-snapshot
- **HTTP Method:** GET
- **Authentication:** Admin

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

## Acceptance Criteria

- [ ] Implement the GET /api/reports/inventory-snapshot endpoint in a Laravel controller
- [ ] Ensure the endpoint returns a comprehensive snapshot of inventory levels, including batch-centric details, reservations, adjustments, cycle counts, valuations, and ledgers
- [ ] Support filtering by store/branch, product/category, date range, and low stock thresholds
- [ ] Include metrics like inventory aging, low stock alerts, and cycle count accuracy in the response
- [ ] Handle soft deletes by excluding archived data unless specified
- [ ] Apply UTC timezone for all timestamps and ensure data consistency with referential links
- [ ] Return RFC7807 problem+json for conflicts or invalid states (e.g., state machine transitions)
- [ ] Add unit/integration tests covering happy paths, edge cases (e.g., empty inventory), and error scenarios
- [ ] Document the endpoint in API specs with examples
- [ ] Verify integration with observability features: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag

## Technical Requirements

- Use Laravel controller and routes for implementation
- Leverage Eloquent models for inventory-related entities (e.g., batches, reservations, ledgers)
- Implement input validation using Laravel's Form Requests or Validator for query parameters (e.g., filters)
- Utilize state machines for ensuring legal transitions in related inventory operations
- Integrate with reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity
- Support bulk operations if applicable, and ensure deterministic behavior for reservations and ledger postings
- Apply caching/etag for performance on repeated snapshot requests
- Handle polymorphic relations for notes/attachments if relevant to inventory reports
- Ensure compatibility with integrations like carriers & accounts, webhooks, notification templates (email/SMS)
- Follow security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys

## Authentication/Authorization Requirements

- Require Admin authentication via JWT/session/API key
- Enforce RBAC & permission checks: users must have admin role with permissions for report access and inventory domain guards (reservation/cycle-count/fraud)
- Apply active user, email-verified, 2FA checks
- Scope to branch/store as per middleware
- Optional tenancy support
- Use throttles and idempotency keys

## Expected Request/Response Format Considerations

- **Request:** GET with query parameters (e.g., ?store_id=1&date_from=2023-01-01&low_stock=true&include_batches=true). Support JSON limits and input sanitizer.
- **Response:** JSON object with inventory snapshot data, e.g., { ""snapshot"": { ""total_units"": 1000, ""batches"": [...], ""valuations"": [...], ""metrics"": { ""aging"": [...], ""low_stock"": [...] } }, status 200. Use versioned content-negotiation and cache headers. For errors: RFC7807 problem+json (e.g., 422 for invalid filters, 403 for unauthorized).
- Ensure PII masking for any customer-related inventory tags/blacklist.
- Support locale/tz for formatted dates.

## Relevant Business Logic

- Inventory snapshot captures current state: batch-centric with per-unit options; reservations, adjustments, cycle counts, valuation, ledgers.
- Cross-reference with order domain (order/order_item states: pending→confirmed→fulfilled|cancelled), fulfillment (shipments, dispatch + tracking), returns (RMA, refunds, exchanges), payments (intent→payment, refund lifecycle), accounting (transaction headers + ledger_entry, reversals, reconciliation/export).
- Enable safe reservation/consumption and consistent ledger posting on stock events.
- Integrate with services (service/service_order lifecycle), promotions, taxes, fraud flags.
- Support deterministic admin assignment for online orders.
- Align with observability & compliance: audit_event for snapshot requests, log with request-id."
205,report,Inventory Aging,Inventory Aging,api/reports/inventory-aging,get,Admin,Implement Inventory Aging Report API Endpoint,"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This issue is for implementing the Inventory Aging report API endpoint, which provides insights into inventory aging as part of the reporting/analytics features, focusing on batch-centric inventory valuation, low stock alerts, and aging analysis.

## API Specifications

- **Category:** report
- **Title:** Inventory Aging
- **Description:** Inventory Aging
- **Route:** api/reports/inventory-aging
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET endpoint at api/reports/inventory-aging
- [ ] Ensure authentication requires Admin role with proper RBAC checks
- [ ] Support query parameters for filtering (e.g., by store, date range, product category) to customize aging reports
- [ ] Return inventory aging data including batch ages, valuation, and low stock indicators
- [ ] Handle errors with RFC7807 problem+json format for invalid requests or state conflicts
- [ ] Add unit and integration tests covering happy path, edge cases, and authorization failures
- [ ] Ensure response is cached appropriately with ETag headers and respects locale/tz middleware
- [ ] Verify integration with inventory ledgers and batch data for accurate aging calculations
- [ ] Document the endpoint in API specs including request/response examples
- [ ] Confirm compliance with middleware stack (e.g., throttles, input sanitizer, domain guards for inventory/reservation)

## Technical Requirements

- Use Laravel controller and define route in api.php with proper versioning and content-negotiation
- Implement input validation using Form Requests for query parameters (e.g., dates in UTC, store/branch scopes)
- Query inventory batches, ledgers, and related entities (products, stores) to compute aging metrics (e.g., days since receipt, value at risk)
- Leverage Eloquent models for efficient joins across normalized ERD; use soft deletes and UTC handling
- Integrate with state machines if cycle counts or adjustments affect aging
- Apply branch scope and RBAC middleware to restrict data visibility
- Use queues if report generation is heavy; support idempotency for repeated requests
- Proper error handling: 4xx for validation/auth, 5xx for server issues, with audit_event logging
- Response should be JSON with structured data (e.g., arrays of aged batches by period: <30 days, 30-60 days, etc.)

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have 'report' permissions and 'inventory' domain access
- Include active user, email-verified, and 2FA checks via middleware
- Branch scope: Limit data to user's assigned branches/stores
- Log access in audit_event for compliance

## Expected Request/Response Format Considerations

- **Request:** GET api/reports/inventory-aging?store_id=1&from_date=2023-01-01&to_date=2023-12-31&aging_period=30 (optional params for filtering; validate as ISO dates, integers)
- **Response:** 200 OK with JSON array of aging reports, e.g., {""data"": [{""batch_id"": 123, ""product_name"": ""Item"", ""age_days"": 45, ""value"": 100.00, ""status"": ""aged""}], ""meta"": {""total"": 50, ""filters_applied"": true}}
- Use RFC7807 for errors, e.g., {""title"": ""Invalid Date"", ""status"": 400, ""detail"": ""From date must be before to date""}
- Ensure PII masking if customer data indirectly involved; add request-id header
- Support bulk/export via optional ?format=csv param if aligns with reporting APIs

## Relevant Business Logic

- Inventory aging analyzes batch-centric stock: calculate days since inbound (receipt/adjustment), flag low stock or over-aged items for alerts
- Integrate with valuation methods (FIFO/LIFO/weighted) from ledgers; consider reservations and pending fulfillments
- Handle soft deletes: Exclude archived batches; use EAV attributes for custom aging rules per product/vendor
- Tie into analytics: Enable slicing by store/product/user for LTV/AOV impacts; track promo/price override effects on aged value
- Ensure transactional consistency: Aging snapshots should post to ledgers if adjustments trigger
- Conflicts (e.g., concurrent cycle counts) resolved via state machines, returning problem+json"
206,report,Stock Valuation,Stock Valuation,api/reports/stock-valuation,get,Admin,Implement Stock Valuation Report API Endpoint,"## Overview

This GitHub issue is for implementing the Stock Valuation report API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The Stock Valuation endpoint provides a report on inventory valuation, leveraging batch-centric inventory with valuation and ledger features.

## API Specifications

- **Category:** report
- **Title:** Stock Valuation
- **Description:** Stock Valuation
- **Route:** api/reports/stock-valuation
- **HTTP Method:** GET
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET /api/reports/stock-valuation endpoint in Laravel
- [ ] Ensure the endpoint requires Admin authentication and authorization
- [ ] Support query parameters for filtering (e.g., by store, branch, date range, valuation method)
- [ ] Return comprehensive stock valuation data including batch values, total inventory value, and ledger summaries
- [ ] Handle errors with RFC7807 problem+json format for invalid requests or conflicts
- [ ] Include unit tests for successful responses, edge cases, and error handling
- [ ] Add integration tests verifying data accuracy against inventory and pricing entities
- [ ] Ensure response caching with ETag and proper headers
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger)
- [ ] Verify compliance with middleware stack (e.g., RBAC, branch scope, throttles)

## Technical Requirements

- Create a Laravel controller (e.g., ReportController) with a stockValuation method
- Define the route in api.php: Route::get('/reports/stock-valuation', [ReportController::class, 'stockValuation'])->middleware(['auth:api', 'admin']); // Adjust for Admin RBAC
- Use Eloquent queries to aggregate inventory batches, joining with products, pricing (price_override), and ledgers
- Implement valuation logic: Calculate based on batch quantities, unit costs, and current pricing; support methods like FIFO/LIFO/weighted average if applicable
- Apply soft deletes filter and UTC handling for data consistency
- Use RequestId middleware for observability; log audit_event for report access
- Optimize for performance with indexes on inventory/ledger tables; consider queues for large reports
- Input validation: Use FormRequest for query params (e.g., store_id, branch_id, from_date, to_date)
- Proper error handling: 400 for invalid params, 403 for unauthorized, 500 for server errors with problem+json

## Authentication/Authorization Requirements

- Requires Admin role via RBAC: Check user_role and permission for 'report:stock-valuation:view'
- Enforce active user, email-verified, and optional 2FA via middleware
- Support JWT or API key auth; branch scope if multi-branch filtering
- Deny access for non-admin users with 403 Forbidden

## Expected Request/Response Format Considerations

- **Request:** GET with query params, e.g., ?store_id=1&branch_id=2&date=2023-01-01&method=fifo (JSON limits via middleware)
- **Response:** 200 OK with JSON array/object of valuation data, e.g., {""total_value"": 15000.00, ""batches"": [{ ""product_id"": 1, ""quantity"": 100, ""unit_cost"": 10.00, ""value"": 1000.00 }], ""summary"": {...} }; Use content-negotiation for versioned responses
- Paginate large results with ?page=1&limit=50
- Include cache headers (ETag, Cache-Control); idempotency not required for GET
- Errors: RFC7807, e.g., {""type"": ""https://example.com/probs/invalid-param"", ""title"": ""Invalid store_id"", ""status"": 400}

## Relevant Business Logic

- Valuation based on batch-centric inventory: Aggregate quantities from reservations, adjustments, cycle counts
- Integrate with pricing (price_override, promotions) and ledgers for accurate financial valuation
- Ensure transactional consistency: Reflect stock movements from orders, shipments, returns, dispatches
- Handle soft deletes: Exclude archived data unless specified
- Support analytics: Align with reporting features like inventory aging, low stock
- State machines: No transitions here, but ensure data legality from underlying entities
- PII masking if customer data indirectly involved; audit logging for access"
207,report,Low Stock,Low Stock,api/reports/low-stock,get,Admin,Implement Low Stock Report API Endpoint (GET /api/reports/low-stock),"## Overview

This GitHub issue is for implementing the Low Stock report API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.

Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.

Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.

Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.

Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).

Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.

Services: service/service_order with lifecycle and profitability.

Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.

Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The Low Stock report provides insights into inventory aging and low stock levels, helping with stock management and reordering.

## API Specifications

- **Category:** report
- **Title:** Low Stock
- **Description:** Low Stock
- **Route:** api/reports/low-stock
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET endpoint at /api/reports/low-stock
- [ ] Ensure admin-level authentication and RBAC checks for access
- [ ] Support query parameters for filtering (e.g., by store, product, threshold)
- [ ] Return JSON response with low stock items, including product details, current stock levels, and aging info
- [ ] Handle errors with RFC7807 problem+json format for invalid requests or unauthorized access
- [ ] Add unit and integration tests covering success, auth failure, and edge cases
- [ ] Document the endpoint in API specs (e.g., OpenAPI)
- [ ] Verify integration with inventory batch-centric model and soft deletes
- [ ] Ensure response respects caching/etag and request-id middleware

## Technical Requirements

- Use Laravel controller (e.g., ReportController) and define route in api.php
- Implement input validation for query parameters using Laravel's FormRequest or Validator
- Query inventory data from relevant models (e.g., Product, InventoryBatch, Store) to identify low stock based on configurable thresholds
- Incorporate business logic for inventory aging/low stock reporting, considering reservations, adjustments, and cycle counts
- Apply all relevant middleware: auth (JWT/API key), RBAC permission checks, branch scope, throttles, input sanitizer, cache headers
- Handle UTC timestamps and polymorphic relations if attachments/notes are included
- Use Eloquent for efficient querying with joins across normalized ERD (e.g., products, categories, vendors)
- Ensure transactional consistency for any ledger implications (though read-only for reports)
- Proper error handling: 401/403 for auth, 400 for validation, 500 for server errors
- Optimize for performance with pagination if large datasets expected

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC: User must have 'report:view' permission or equivalent role
- Enforce active user, email-verified, and 2FA if enabled
- Branch scope: Limit data to user's assigned branches/stores
- Optional tenancy if multi-tenant setup

## Expected Request/Response Format Considerations

- **Request:** GET /api/reports/low-stock?store_id=1&threshold=10&include_aging=true (query params for filters)
  - All data in UTC
  - Support content-negotiation for JSON
  - Idempotent and throttle-safe

- **Response:** 200 OK with JSON array of low stock items, e.g.:
  {
    ""data"": [
      {
        ""product_id"": 123,
        ""name"": ""Item Name"",
        ""current_stock"": 5,
        ""threshold"": 10,
        ""aging_days"": 30,
        ""store_id"": 1,
        ""batch_details"": [...]
      }
    ],
    ""meta"": { ""total"": 1, ""page"": 1 }
  }
  - Include ETag for caching
  - Error responses: RFC7807 problem+json, e.g. { ""type"": ""https://example.com/probs/unauthorized"", ""title"": ""Unauthorized"" }

- Versioned endpoint (e.g., /api/v1/reports/low-stock)
- Locale/tz handling for any date fields in response

## Relevant Business Logic

- Low stock determined by comparing current batch-centric inventory levels against thresholds, excluding reserved stock
- Include inventory aging: days since last adjustment or cycle count
- Respect soft deletes: exclude archived products
- Integrate with reporting/analytics: align with inventory aging/low stock metrics
- No state machine transitions needed (read-only report)
- Ensure PII masking if customer-related data indirectly involved
- Audit events for report access if configured
- Support feature flags for enabling/disabling the report"
208,report,Out of Stock,Out of Stock,api/reports/out-of-stock,get,Admin,Implement Out of Stock Report API Endpoint (GET /api/reports/out-of-stock),"## Overview

As a technical writer creating GitHub issues for API implementation in the Deshio ERP system, this issue covers the development of the 'Out of Stock' report API endpoint. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. This endpoint provides a report on products that are currently out of stock across stores/branches, leveraging the inventory management system to identify items where available stock is zero, considering reservations and adjustments.

The endpoint enables admins to query and retrieve out-of-stock products for inventory monitoring, low stock alerts, and reporting/analytics such as inventory aging and low stock. It aligns with Deshio's observability & compliance features, including audit_event logging, and integrates with reporting/analytics for revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, and activity. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

## API Specifications

- **Category:** report
- **Title:** Out of Stock
- **Description:** Out of Stock
- **Route:** api/reports/out-of-stock
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET endpoint at /api/reports/out-of-stock that returns a list of out-of-stock products
- [ ] Ensure authentication requires Admin role with RBAC permission checks
- [ ] Support query parameters for filtering (e.g., store_id, category_id, date range) and pagination (e.g., page, limit)
- [ ] Validate inputs and return RFC7807 problem+json for errors
- [ ] Include response fields like product_id, name, sku, store/branch, current_stock (0), last_updated
- [ ] Log audit_event for endpoint access
- [ ] Write unit and integration tests covering success, auth failure, invalid params, and empty results
- [ ] Ensure response uses caching/etag and proper cache headers
- [ ] Handle soft deletes by excluding archived products
- [ ] Integrate with inventory ledgers for accurate stock calculation considering reservations and adjustments

## Technical Requirements

- Use Laravel controller (e.g., ReportController) and define route in api.php with middleware stack: auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, throttles, input sanitizer, RequestId, locale/tz, versioned content-negotiation
- Implement in the reports namespace, querying from inventory tables (e.g., products, inventory_batches, stock_ledgers) joined with categories/vendors/stores
- Use Eloquent for queries, with scopes for out-of-stock (available_quantity <= 0) and UTC handling
- Add input validation using Form Requests for query params (e.g., integer for ids, date format)
- Proper error handling: 401 for unauth, 403 for unauthorized, 422 for validation, 500 for server errors, with PII masking in logs
- Response format: JSON array of objects, paginated with meta (total, per_page, current_page), status 200 OK
- Business logic: Calculate out-of-stock based on batch-centric inventory, subtracting reservations/allocations; consider cycle counts and adjustments; filter by branch scope if applicable
- Ensure transactional consistency and idempotency; use queues if heavy computation needed
- Document in OpenAPI/Swagger with examples

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC check: User must have 'view_reports' permission and Admin role
- Enforce email-verified, active user, and optional 2FA
- Branch scope: Limit results to user's assigned branches if multi-tenancy enabled

## Expected Request/Response Format Considerations

- **Request:** GET /api/reports/out-of-stock?store_id=1&category_id=2&from_date=2023-01-01&to_date=2023-12-31&page=1&limit=50
  Headers: Authorization: Bearer <token>, Accept: application/json, X-Locale: en, X-Timezone: UTC
- **Success Response (200):** {
  ""data"": [
    {
      ""id"": 123,
      ""name"": ""Product Name"",
      ""sku"": ""SKU123"",
      ""category"": ""Electronics"",
      ""store_id"": 1,
      ""store_name"": ""Main Branch"",
      ""current_stock"": 0,
      ""reserved"": 5,
      ""last_adjustment"": ""2023-10-01T00:00:00Z""
    }
  ],
  ""meta"": {
    ""current_page"": 1,
    ""per_page"": 50,
    ""total"": 100
  }
}
- **Error Response (e.g., 422):** {
  ""type"": ""https://example.com/probs/validation-error"",
  ""title"": ""Validation Error"",
  ""detail"": ""Invalid store_id"",
  ""status"": 422
}
- Support JSON limits, CORS, HSTS, and replay defense if needed

## Relevant Business Logic

- Out-of-stock determination: Query inventory where sum(available_quantity) - reservations <= 0, aggregated by product and store/branch
- Exclude items with future incoming shipments or dispatches that would restock
- Integrate with promotions/pricing for override considerations if stock affects pricing
- Align with state machines for inventory adjustments/cycle counts
- Support reporting/analytics: Enable export to CSV/Excel via bulk export API if extended
- Ensure ledger posting consistency for any stock events triggered
- Handle EAV attributes for product features in response if relevant (e.g., size/color for out-of-stock variants)"
209,report,Return Rates,Return Rates,api/reports/return-rates,get,Admin,Implement Return Rates Report API Endpoint,"## Overview

As a technical writer for Deshio ERP, this GitHub issue tracks the implementation of the Return Rates API endpoint. Deshio is a Laravel-based ERP system for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain handles states (pending→confirmed→fulfilled|cancelled), assignments, notes/attachments, promos, taxes, and fraud flags. Fulfillment involves shipments, inter-store dispatches with tracking and POD, and transactional stock movements. Returns are managed via RMA (return/return_item) with receive/restock/scrap, refunds, and exchanges. Payments include intent→capture/void, refunds, and order synchronization. Accounting uses transaction headers + ledger entries for movements, reversals, and reconciliation. Services cover service orders with lifecycle and profitability. Integrations include carriers, waybills/rates/tracking, webhooks, and notifications. Security features user/role/permission with abilities, sessions, email verification, password reset, TOTP MFA, API keys. Observability includes audit events, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware encompasses TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC/permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards, upload guards, webhook signatures, cache headers. Reporting/analytics include revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price history, cycle count accuracy, promo impact, activity. State machines ensure legal transitions for orders, items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, maintenance. Data uses UTC storage, soft deletes, EAV for attributes, polymorphic notes/attachments, strict referential links. Design supports deterministic admin assignment, safe reservation/consumption, consistent ledger posting.

This endpoint provides reporting on return rates, part of the analytics features for monitoring return/refund rates.

## API Specifications

- **Category:** report
- **Title:** Return Rates
- **Description:** Return Rates
- **Route:** api/reports/return-rates
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET endpoint at api/reports/return-rates
- [ ] Ensure authentication requires Admin role via RBAC
- [ ] Support query parameters for filtering (e.g., by date range, store, product, etc., based on reporting needs)
- [ ] Return JSON response with return rate metrics (e.g., total returns, return percentage, breakdowns by category)
- [ ] Handle errors per RFC7807 problem+json for invalid requests or unauthorized access
- [ ] Add unit and integration tests covering happy path, edge cases, and authorization
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger)
- [ ] Ensure response times meet performance SLAs for reporting
- [ ] Integrate with state machines for return-related data accuracy

## Technical Requirements

- Use Laravel framework: Define route in api.php, create a dedicated controller (e.g., ReportController@returnRates)
- Implement input validation using Laravel's Form Requests or Validator for query params (e.g., dates in ISO format, store IDs)
- Query data from relevant models: returns (RMA), orders, order_items, leveraging Eloquent relationships and soft deletes
- Aggregate metrics: Calculate return rates (e.g., (total returns / total orders) * 100), support groupings by store/product/time
- Use UTC for all date handling; apply locale/tz middleware if needed
- Incorporate middleware stack: auth (JWT/API key), RBAC checks for Admin permission, branch scope if applicable, throttles, idempotency
- Error handling: Domain guards for returns data, return standardized errors
- Response format: JSON with etag/caching headers; consider pagination for large datasets
- Testing: PHPUnit tests for controller logic, database seeding for return/order fixtures, mock auth
- Observability: Log requests with request-id, audit events for report access, metrics for usage
- Business logic integration: Pull from return domain (RMA lifecycle: receive/restock/scrap, refunds, exchanges); sync with order states and ledgers; ensure data consistency via transactions

## Authentication/Authorization Requirements

- Requires Admin authentication: Validate via JWT/session/API key middleware
- RBAC check: User must have Admin role/permission for report access
- Additional checks: Active user, email-verified, 2FA if enabled; branch scope to limit data visibility
- Reject unauthorized with 401/403 per RFC7807

## Expected Request/Response Format Considerations

- **Request:** GET api/reports/return-rates?from_date=YYYY-MM-DD&to_date=YYYY-MM-DD&store_id=1&product_id=2&format=json (query params optional for filtering)
- **Response (200 OK):** JSON object, e.g., {""data"": [{""period"": ""2023-01"", ""total_orders"": 100, ""total_returns"": 5, ""return_rate"": 5.0, ""breakdown"": {...}}], ""meta"": {""total"": 12, ""page"": 1}}
- **Error Responses:** 400 for invalid params (validation errors), 401 Unauthorized, 403 Forbidden, 500 Internal with problem+json
- Content negotiation: Versioned API (e.g., /v1/), JSON only, cache headers for repeatable queries
- Considerations: PII masking if customer data included; bulk export potential via ?export=csv

## Relevant Business Logic

- Return rates derived from RMA entities linked to orders; include refunded/exchanged returns
- Aggregate across stores/branches, products/categories; factor in order states (fulfilled→returned)
- Handle promotions/taxes impacts on return values; integrate with accounting ledgers for financial returns
- State machine validation: Ensure only valid return transitions are counted
- Analytics alignment: Support LTV/AOV calculations, return/refund rates as KPIs; enable filtering for SLA/dispatch performance correlations
- Data integrity: Use soft deletes for historical accuracy; EAV attributes for custom return reasons; polymorphic attachments for return notes"
210,report,Refund Summary,Refund Summary,api/reports/refund-summary,get,Admin,Implement Refund Summary Report API (GET /api/reports/refund-summary),"## Overview

This GitHub issue covers the implementation of the Refund Summary API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD that spans catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain handles states (pending→confirmed→fulfilled|cancelled), assignments, notes/attachments, promos, taxes, fraud flags. Fulfillment involves shipments, inter-store dispatches with tracking and POD. Returns manage RMAs, restocking, refunds, exchanges. Payments track intents, captures/voids, refunds, and order synchronization. Accounting uses transaction headers and ledger entries for movements, reversals, reconciliation. Services include service orders with lifecycle and profitability. Integrations cover carriers, webhooks, notifications. Security features user/role/permission with multi-roles, sessions, MFA, API keys. Observability includes audits, logs, PII masking, health/metrics. Middleware enforces TLS/HSTS, CORS, auth (JWT/session/API key), RBAC, throttles, idempotency, sanitization, domain guards, webhook signatures. Reporting/analytics provide revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, inventory aging, promo impact. State machines ensure legal transitions for orders, shipments, returns, payments; conflicts use RFC7807 problem+json. APIs support bulk operations, search, attachments, reindex, backups, feature flags. Data uses UTC storage, soft deletes, EAV attributes, polymorphic relations, strict referential integrity. Design supports deterministic assignments, safe reservations, consistent ledger posting.

The Refund Summary endpoint provides aggregated insights into refunds, including totals, rates, and trends, drawing from payments, returns (RMAs), and accounting ledgers to support analytics on return/refund rates, profitability impacts, and compliance.

## API Specifications

- **Category:** report
- **Title:** Refund Summary
- **Description:** Refund Summary
- **Route:** api/reports/refund-summary
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET /api/reports/refund-summary endpoint in Laravel
- [ ] Ensure admin-only access with proper RBAC and permission checks
- [ ] Support query parameters for filtering (e.g., date range, store/branch, product/category filters)
- [ ] Aggregate refund data from payments, RMAs, ledger entries, and order states
- [ ] Handle pagination or limits for large datasets if needed
- [ ] Return JSON response with summary metrics (e.g., total refunds, refund rates, breakdowns by period/store)
- [ ] Implement input validation and sanitization
- [ ] Add comprehensive unit, integration, and API tests covering success, error cases, and edge scenarios
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger) including request/response schemas
- [ ] Ensure compatibility with middleware (auth, throttles, idempotency, domain guards for payment/refund/fraud)
- [ ] Verify UTC handling, soft deletes exclusion, and PII masking in reports
- [ ] Test state machine integrations for refund-related transitions (e.g., payment voids, RMA approvals)

## Technical Requirements

- Develop a Laravel controller (e.g., ReportController) with a refundSummary method
- Define route in api.php with prefix 'reports' and name 'reports.refund-summary'
- Use Eloquent models for querying Orders, Payments, Returns (RMAs), LedgerEntries, filtering by admin's branch scope
- Implement business logic for calculations: total refunded amounts, refund rates (refunds / total orders/revenue), aging, trends; integrate with analytics views or raw queries for performance
- Apply Laravel validation for query params (e.g., dates in YYYY-MM-DD format, store IDs)
- Use resource classes for response formatting (e.g., RefundSummaryResource)
- Handle errors with RFC7807 problem+json for invalid inputs, unauthorized access, or query failures
- Optimize queries with indexes on date/store/refund_status fields; consider caching/etag for repeated reports
- Ensure transactional consistency for any underlying data reads, aligning with ledger posting rules
- Integrate with observability: log requests with request-id, audit events for report access

## Authentication/Authorization Requirements

- Require Admin authentication via JWT, session, or API key
- Enforce RBAC: user must have 'view_reports' permission and 'refund_summary' ability; multi-role support
- Apply active user check, email verification, optional 2FA/MFA
- Scope to user's branches/stores via branch scope middleware
- Optional tenancy if multi-tenant setup is enabled
- Reject unauthenticated/unauthorized with 401/403 and problem+json details

## Expected Request/Response Format Considerations

- **Request:** GET /api/reports/refund-summary?from_date=YYYY-MM-DD&to_date=YYYY-MM-DD&store_id=integer&category_id=integer&paginate=true&per_page=50
  - All params optional; defaults to last 30 days, all stores
  - Content-Type: application/json; versioned via Accept header (e.g., application/vnd.deshio.v1+json)
  - Idempotency via key if supported for reports

- **Response:** 200 OK with JSON body, e.g.:
  {
    ""data"": {
      ""total_refunds"": 15000.00,
      ""refund_rate"": 0.05,
      ""breakdown"": [
        {""period"": ""2023-01"", ""amount"": 5000.00, ""count"": 10},
        ...
      ],
      ""by_store"": [...],
      ""trends"": {...}
    },
    ""meta"": {""from"": ""2023-01-01"", ""to"": ""2023-01-31"", ""filtered_by"": ""store_id:1""}
  }
  - Use snake_case keys, UTC timestamps
  - For errors: 400/422 with problem+json (type, title, detail, instance)
  - Cache headers, ETag for conditional GETs
  - Large responses: paginate with links (first/last/next/prev)

## Relevant Business Logic

- Aggregate from payment refunds, RMA approvals/scraps/exchanges, ledger reversals; exclude pending/cancelled orders
- Calculate rates as (refunded amount / total revenue) or (refund count / order count), configurable
- Factor in promotions/taxes/fraud flags; sync with order.payment_status
- Support filters aligning with reporting/analytics (e.g., by store/product/user, LTV impacts)
- Ensure determinism: use transaction timestamps for periods, handle soft deletes by excluding
- Comply with state machines: only include completed refund transitions (e.g., intent→captured→refunded)
- Post ledger entries if report triggers adjustments; prevent conflicts with domain guards (payment/refund/fraud)
- Align with overall design: safe consumption of refund data, consistent posting on financial events, PII masking for customer refs"
211,report,Order Fulfillment SLA,Order Fulfillment SLA,api/reports/fulfillment-sla,get,Admin,Implement Order Fulfillment SLA Report API Endpoint,"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint provides a report on Order Fulfillment SLA (Service Level Agreement) metrics, calculating performance indicators such as on-time fulfillment rates, dispatch times, and SLA compliance based on order states, shipments, and dispatch events.

## API Specifications

- **Category:** report
- **Title:** Order Fulfillment SLA
- **Description:** Order Fulfillment SLA
- **Route:** api/reports/fulfillment-sla
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET endpoint at api/reports/fulfillment-sla
- [ ] Support query parameters for filtering (e.g., date range, store/branch, order status)
- [ ] Calculate SLA metrics including fulfillment time, on-time delivery rate, and dispatch performance
- [ ] Return JSON response with aggregated data (e.g., SLA percentage, average times, breakdowns by store/product)
- [ ] Handle pagination for large datasets if applicable
- [ ] Add unit and integration tests covering success, error, and edge cases
- [ ] Ensure response complies with RFC7807 for errors
- [ ] Document the endpoint in API specs

## Technical Requirements

- Use Laravel controller (e.g., ReportController) with route definition in api.php
- Leverage Eloquent queries on order, shipment, dispatch, and related entities for data aggregation
- Implement caching (e.g., Redis) for performance on report queries
- Use state machines to validate order and fulfillment states in calculations
- Integrate with observability: log requests, add metrics for query performance
- Handle soft deletes and UTC timestamps in calculations
- Support bulk/export features if filters allow CSV/JSON export

## Authentication/Authorization Requirements

- Require Admin role via RBAC (user_role with admin permissions)
- Apply middleware stack: auth (JWT/API key), active user, email-verified, 2FA if enabled, RBAC checks
- Enforce branch scope if multi-branch filtering is used
- Use permission checks for report access (e.g., 'view-fulfillment-sla')

## Expected Request/Response Format Considerations

- **Request:** GET with query params like ?start_date=YYYY-MM-DD&end_date=YYYY-MM-DD&store_id=1&branch_id=2&paginate=10
- **Response:** JSON object with structure e.g., {""sla_compliance"": 95.5, ""avg_fulfillment_time"": ""2.3 days"", ""breakdown"": [...], ""total_orders"": 1500}
- Use content-negotiation for JSON; include ETag for caching
- Errors: RFC7807 problem+json, e.g., {""type"": ""invalid_date"", ""title"": ""Invalid date range""}
- Paginated responses: Use Laravel's pagination with meta/links

## Relevant Business Logic

- SLA calculation: Measure time from order confirmation to fulfillment/shipment completion; compare against configurable thresholds (e.g., 48 hours for standard)
- Include dispatch performance: Scan events, tracking updates, POD confirmation
- Aggregate by store/branch, product category, or vendor; factor in promotions/taxes if impacting timelines
- Handle returns/exchanges in SLA if they affect fulfillment metrics
- Ensure transactional consistency with stock movements and ledger postings
- Conflicts (e.g., invalid filters) return problem+json; use idempotency for repeated report requests"
212,report,Dispatch Performance,Dispatch Performance,api/reports/dispatch-performance,get,Admin,Implement GET /api/reports/dispatch-performance Admin Endpoint,"## Overview

Implement the Dispatch Performance report API endpoint for the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint provides dispatch performance metrics, including SLA, tracking events, scan events, POD, and transactional stock movements for inter-store dispatches.

## API Specifications

- **Category:** report
- **Title:** Dispatch Performance
- **Description:** Dispatch Performance
- **Route:** api/reports/dispatch-performance
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET endpoint at /api/reports/dispatch-performance
- [ ] Ensure authentication requires Admin role via RBAC
- [ ] Support query parameters for filtering (e.g., date range, store/branch, dispatch status)
- [ ] Return performance metrics including average dispatch time, SLA compliance, scan event counts, POD rates, and stock movement accuracy
- [ ] Handle errors with RFC7807 problem+json for invalid transitions or conflicts
- [ ] Add unit/integration tests covering success, auth failure, and edge cases
- [ ] Document the endpoint in API specs (e.g., OpenAPI)
- [ ] Ensure response caching with ETag and proper headers
- [ ] Verify data in UTC and handle soft deletes appropriately
- [ ] Integrate with observability: log requests, audit events, request-id

## Technical Requirements

- Use Laravel controller (e.g., ReportController) and define route in api.php
- Implement input validation using Form Requests for query params (e.g., date_from, date_to, store_id, status)
- Query dispatch-related entities (dispatch, tracking, scan events, shipment/shipment_item, ledger_entry for stock movements)
- Aggregate metrics using Eloquent queries or raw SQL for performance, respecting branch scope and tenancy if enabled
- Apply middleware stack: auth (JWT/API key), RBAC permission checks for 'report.dispatch-performance', throttles, idempotency if applicable
- Handle state machine legality for dispatch transitions; return errors for invalid states
- Support pagination and sorting for large datasets
- Ensure transactional consistency for any underlying data reads
- Use queues/caching for heavy computations if needed
- Proper error handling: 401/403 for auth, 422 for validation, 500 for server errors with PII masking

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC check: User must have 'report.dispatch-performance' permission tied to Admin role
- Enforce active user, email-verified, and 2FA if enabled
- Branch scope: Limit data to user's assigned branches
- Audit the request in audit_event table with request-id

## Expected Request/Response Format Considerations

- **Request:** GET with query params, e.g., ?date_from=2023-01-01&date_to=2023-12-31&store_id=1&status=fulfilled&per_page=50&page=1
  - All params optional; default to last 30 days and all stores
  - Validate dates as UTC, store_id as existing branch
- **Response:** JSON array/object with metrics, e.g., {""metrics"": {""avg_dispatch_time"": 120, ""sla_compliance"": 95.5, ""total_dispatches"": 1000, ""pod_rate"": 98}, ""data"": [dispatch summaries], ""meta"": {pagination}}
  - Use RFC7807 for errors: {""title"": ""Invalid Date"", ""status"": 422, ""detail"": ""Date range too large""}
  - Include Link headers for pagination, Cache-Control for etag

## Relevant Business Logic

- Metrics derived from dispatch lifecycle: states via state machines (e.g., pending→assigned→shipped→delivered), scan events, tracking updates, POD
- Calculate performance: time from assignment to POD, SLA (e.g., <24h for intra-city), error rates for stock movements/reversals
- Filter by store/branch for omni-channel views; aggregate across for enterprise reports
- Ensure ledger consistency: only include reconciled dispatch events
- Handle inter-store dispatches with transactional stock reservations/consumptions
- Conflicts (e.g., concurrent updates) return problem+json; use optimistic locking if needed
- Align with analytics: dispatch performance as part of SLA, activity reporting"
213,report,Cycle Count Accuracy,Cycle Count Accuracy,api/reports/cycle-count-accuracy,get,Admin,Implement Cycle Count Accuracy Report API Endpoint,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue covers implementing the Cycle Count Accuracy report API endpoint.

Core entities include: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.

Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.

Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.

Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).

Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.

Services: service/service_order with lifecycle and profitability.

Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.

Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint provides Cycle Count Accuracy metrics as part of the reporting category, helping analyze inventory accuracy through cycle counts, including variance analysis, accuracy rates, and historical trends.

## API Specifications

- **Category:** report
- **Title:** Cycle Count Accuracy
- **Description:** Cycle Count Accuracy
- **Route:** api/reports/cycle-count-accuracy
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET endpoint at api/reports/cycle-count-accuracy
- [ ] Ensure endpoint returns Cycle Count Accuracy metrics, such as accuracy percentage, variance details, count frequencies, and breakdowns by store/product/batch
- [ ] Support query parameters for filtering (e.g., date range, store_id, product_id, branch scope)
- [ ] Add input validation for query parameters
- [ ] Implement proper error handling with RFC7807 problem+json for invalid requests or unauthorized access
- [ ] Write unit and integration tests covering successful responses, edge cases, and errors
- [ ] Ensure response is cached appropriately with ETag headers for performance
- [ ] Verify integration with inventory ledgers and cycle count state machines
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger)
- [ ] Add audit logging for endpoint access

## Technical Requirements

- Use Laravel controller (e.g., ReportController) and define route in api.php with middleware stack including auth, RBAC checks, branch scope, throttles, and cycle-count domain guard
- Leverage Eloquent models for cycle counts, inventory batches, products, stores, and ledgers to compute accuracy (e.g., (counted_qty / expected_qty) * 100, variances > threshold)
- Implement query builder or scopes for efficient data retrieval, supporting pagination if large datasets
- Handle soft deletes and UTC timestamps in calculations
- Use state machines to ensure only completed cycle counts are included in accuracy reports
- Integrate with reporting/analytics features for aggregations (e.g., by store/product/user, historical trends)
- Apply middleware for request-id, locale/tz, input sanitizer, and cache headers
- Ensure deterministic results with consistent ledger posting references

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have admin role/permission for reports and cycle-count access
- Apply branch scope to limit data to user's assigned branches/stores
- Include active user, email-verified, and optional 2FA checks
- Reject unauthorized requests with 403 Forbidden (RFC7807 format)

## Expected Request/Response Format Considerations

- **Request:** GET with optional query params (e.g., ?from_date=YYYY-MM-DD&to_date=YYYY-MM-DD&store_id=1&product_id=2&paginate=true&per_page=50)
  - Validate params with Laravel Form Requests (e.g., dates in UTC, IDs as integers)
  - Support content-negotiation for JSON response

- **Response:** JSON object with structure like:
  {
    ""data"": [
      {
        ""cycle_count_id"": 123,
        ""store_name"": ""Branch A"",
        ""product_sku"": ""ABC123"",
        ""expected_qty"": 100,
        ""counted_qty"": 98,
        ""variance"": 2,
        ""accuracy"": 98.0,
        ""count_date"": ""2023-10-01T00:00:00Z"",
        ""notes"": ""Minor discrepancy""
      }
    ],
    ""summary"": {
      ""overall_accuracy"": 95.5,
      ""total_counts"": 50,
      ""avg_variance"": 1.2
    },
    ""meta"": { ""total"": 50, ""per_page"": 50, ""current_page"": 1 }
  }
  - Include ETag for caching, request-id in headers
  - Errors: 400 for invalid params, 401/403 for auth issues, 500 for server errors (all in problem+json)

## Relevant Business Logic

- Compute accuracy based on cycle count states (completed/approved via state machine)
- Pull expected quantities from inventory ledgers/batches, accounting for reservations, adjustments, and movements
- Flag high-variance counts for review; integrate with low stock/inventory aging alerts
- Ensure transactional consistency: No partial data; use database transactions for complex queries
- Support bulk/export features if extended (e.g., CSV download via query param)
- Align with observability: Log metrics, mask PII, track SLA for response times
- Conflicts (e.g., concurrent counts) resolved via state machine legality checks"
214,report,Price Change History,Price Change History,api/reports/price-change-history,get,Admin,Implement Price Change History Report API Endpoint,"## Overview

This GitHub issue is for implementing the Price Change History API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The Price Change History endpoint falls under the reporting category and provides historical data on price changes for products, supporting analytics on price change history as part of the overall reporting features.

## API Specifications

- **Category:** report
- **Title:** Price Change History
- **Description:** Price Change History
- **Route:** api/reports/price-change-history
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET endpoint at api/reports/price-change-history that retrieves historical price change data for products
- [ ] Ensure the endpoint requires Admin authentication and appropriate RBAC permissions
- [ ] Support query parameters for filtering by product, date range, store/branch, and other relevant criteria (e.g., ?product_id=123&from_date=2023-01-01&to_date=2023-12-31)
- [ ] Return paginated results with metadata (e.g., total count, current page)
- [ ] Handle errors according to RFC7807 problem+json format for invalid inputs or unauthorized access
- [ ] Integrate with existing middleware stack including auth, RBAC checks, request ID, and caching/etag
- [ ] Ensure data is fetched from relevant entities like pricing (price_override) and audit logs for change tracking
- [ ] Add unit and integration tests covering success, error, and edge cases (e.g., no changes, large datasets)
- [ ] Document the endpoint in API specs with request/response examples
- [ ] Verify compatibility with UTC storage, soft deletes, and EAV attributes

## Technical Requirements

- Use Laravel framework: Create a dedicated controller (e.g., ReportController) with a method for priceChangeHistory
- Define the route in api.php with proper middleware grouping (auth:admin, rbac:report.view, etc.)
- Implement input validation using Laravel's Form Requests or Validator for query parameters (e.g., date formats, product IDs)
- Query the database using Eloquent: Join product, pricing, and audit_event tables to track price changes, respecting soft deletes and referential integrity
- Support business logic for price change history: Track changes via audit logs or dedicated price_history table, including old/new values, timestamps, user who made the change, and context (e.g., promotion, override)
- Handle pagination with Laravel's LengthAwarePaginator and include optional sorting (e.g., by date descending)
- Proper error handling: 401 for auth failures, 403 for permission issues, 422 for validation errors, 500 for server issues, all in problem+json
- Authentication/authorization: Enforce Admin role via JWT/session/API key; RBAC check for 'report.view' permission; scope to branch if applicable; optional 2FA and email verification
- Expected request/response format: Request as GET with query params (JSON-compatible); Response as JSON array of objects with fields like {id, product_id, old_price, new_price, changed_at, changed_by, reason}; Include links for HATEOAS if applicable; Use content-negotiation for versioned API
- Relevant business logic: Price changes tie into catalog/pricing entities; Ensure deterministic logging of changes; Integrate with state machines if changes affect promotions or orders; Support reporting analytics like price change frequency/impact
- Observability: Log requests with request-id; Audit the endpoint usage; Apply PII masking if user data is involved; Use queues if heavy computation needed
- Security: Throttle the endpoint; Sanitize inputs; Domain guards for pricing overrides; Cache results with etag for performance"
215,report,User Activity,User Activity,api/reports/user-activity,get,Admin,Implement User Activity Report API Endpoint,"## Overview

This GitHub issue is for implementing the User Activity report API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The User Activity endpoint provides reporting on user activities within the system, aligning with the reporting/analytics features for activity tracking.

## API Specifications

- **Category:** report
- **Title:** User Activity
- **Description:** User Activity
- **Route:** api/reports/user-activity
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET endpoint at api/reports/user-activity to retrieve user activity reports
- [ ] Ensure the endpoint supports query parameters for filtering (e.g., by user ID, date range, activity type) based on reporting needs
- [ ] Add input validation for query parameters to prevent invalid requests
- [ ] Implement proper pagination and sorting for large result sets
- [ ] Write unit and integration tests covering success, error, and edge cases
- [ ] Verify response includes relevant user activity data from audit_event, log, and related entities
- [ ] Ensure compliance with PII masking for sensitive user data in reports
- [ ] Test endpoint with Admin authentication only; deny access to non-admin users
- [ ] Confirm responses use RFC7807 problem+json for errors
- [ ] Integrate with middleware stack including auth, RBAC, and request-id

## Technical Requirements

- Use Laravel controller and routes to define the endpoint
- Leverage Eloquent models for querying user, audit_event, log, and activity-related data
- Implement input validation using Laravel's Form Requests or Validator
- Handle soft deletes and UTC timestamps in queries
- Apply caching/etag for performance on repeated requests
- Use queues if report generation is resource-intensive
- Ensure transactional consistency for any underlying data reads
- Include proper error handling with HTTP status codes (e.g., 200 for success, 401/403 for auth issues, 422 for validation)
- Follow versioned content-negotiation and locale/tz middleware

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC & permission checks: Only users with admin role/permission can access
- Apply active user, email-verified, and 2FA checks via middleware
- Include branch scope if applicable to user activity filtering
- Use throttles and idempotency for request protection

## Expected Request/Response Format Considerations

- **Request:** GET api/reports/user-activity?user_id=123&start_date=2023-01-01&end_date=2023-12-31&activity_type=login&per_page=50&page=1 (query params for filtering, pagination)
- **Response:** JSON array of user activities with fields like id, user_id, activity_type, timestamp, description, ip_address (masked PII); include meta for pagination
- Support JSON content type; return problem+json for errors
- Ensure responses are deterministic and sorted by timestamp descending

## Relevant Business Logic

- Query user activities from audit_event and log tables, joining with user/role data
- Filter by user, date range, and activity types (e.g., login, order creation, inventory adjustment) to support analytics like activity reports
- Respect soft deletes and archival policies
- Align with observability features: include request-id in logs
- For reports, aggregate or summarize data if needed (e.g., count of activities per user)
- Ensure no direct data mutations; read-only endpoint
- Integrate with state machines if activity involves entity transitions (e.g., order states)"
216,report,Permission Coverage,Permission Coverage,api/reports/permission-coverage,get,Admin,Implement Permission Coverage Report API Endpoint,"## Overview

This GitHub issue is for implementing the 'Permission Coverage' report API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain handles states from pending to fulfilled/cancelled, with assignments, notes, promos, taxes, and fraud flags. Fulfillment includes shipments, inter-store dispatches with tracking and POD. Returns manage RMAs, restocking, refunds, and exchanges. Payments handle intents, captures, voids, refunds, and synchronization. Accounting uses transaction headers and ledger entries for all movements, with reversals and reconciliation. Services include service orders with lifecycle and profitability. Integrations cover carriers, waybills, rates, tracking, webhooks, and notifications. Security & identity features user/role/permission with abilities, multi-roles, sessions, email verification, password reset, TOTP MFA, backup codes, and API keys. Observability includes audit events, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware encompasses TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures, replay defense, and cache headers. Reporting/analytics include revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, and activity. State machines ensure legal transitions for orders, dispatches, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential links. Design supports deterministic admin assignment, safe reservation/consumption, and consistent ledger posting.

The 'Permission Coverage' endpoint generates a report on permission coverage, analyzing roles, permissions, and their assignments to ensure comprehensive RBAC coverage in the system.

## API Specifications

- **Category:** report
- **Title:** Permission Coverage
- **Description:** Permission Coverage
- **Route:** api/reports/permission-coverage
- **Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET endpoint at api/reports/permission-coverage
- [ ] Ensure endpoint requires Admin authentication and authorization
- [ ] Generate report data on permission coverage, including roles, permissions, and assignments
- [ ] Handle errors with RFC7807 problem+json for unauthorized access or system issues
- [ ] Add unit and integration tests for the endpoint, covering success and failure cases
- [ ] Document the endpoint in API specs with request/response examples
- [ ] Verify integration with RBAC system for accurate coverage analysis
- [ ] Ensure response is cached appropriately using etag and cache headers

## Technical Requirements

- Use Laravel framework: Define route in api.php, create a dedicated controller (e.g., ReportController) with a permissionCoverage method
- Implement in the reports category, querying the user/role/permission tables with abilities (role↔perm) and user_role (multi-role)
- Input validation: As a GET endpoint, validate any query parameters if added (e.g., filters for specific roles); use Laravel's FormRequest if needed
- Proper error handling: Return 401/403 for auth failures, 500 for internal errors, using standardized problem+json format
- Response format: JSON array/object detailing permission coverage (e.g., { ""roles"": [...], ""permissions"": [...], ""coverage"": { ""assigned"": X, ""unassigned"": Y } })
- Business logic: Analyze coverage by joining roles, permissions, and assignments; compute metrics like percentage covered, gaps in permissions per role; respect branch scope if applicable; use state machines if transitions involve permissions
- Database: Query normalized ERD tables for roles and permissions; use UTC timestamps; support soft deletes for archival
- Middleware: Apply auth (JWT/session/API key), RBAC & permission checks (admin only), throttles, idempotency, input sanitizer, cache headers
- Testing: PHPUnit tests for controller logic, mock RBAC queries, assert JSON structure and coverage calculations
- Observability: Log requests with request-id, audit events for report access, PII masking if user data involved

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Authorization: User must have admin role with permissions for report access; enforce RBAC checks in middleware
- Additional: Active user, email-verified, 2FA if enabled; branch scope to limit data if multi-tenant

## Expected Request/Response Format Considerations

- **Request:** GET api/reports/permission-coverage (optional query params: ?role_id=123&filter=unassigned for customization)
- **Response:** 200 OK with JSON: {
  ""data"": {
    ""total_roles"": 10,
    ""total_permissions"": 50,
    ""coverage_percentage"": 85.0,
    ""gaps"": [...],
    ""details"": [...]
  },
  ""meta"": { ""request_id"": ""uuid"", ""timestamp"": ""UTC"" }
}
- Errors: 4xx/5xx with problem+json: { ""title"": ""Error"", ""detail"": ""Message"", ""status"": 403 }
- Content negotiation: Versioned API, JSON only; include etag for caching

## Relevant Business Logic

- Permission coverage report assesses RBAC completeness: Identify roles without sufficient permissions, unassigned permissions, multi-role overlaps
- Integrate with security & identity domain; ensure report aids compliance and audit_event logging
- Support for feature flags if coverage reporting is toggled; align with observability for metrics on permission usage
- Handle polymorphic relations if permissions link to notes/attachments; use EAV if custom permission attributes
- Ensure deterministic results, respecting soft deletes and referential integrity"
217,search,Global Search,Search across entities,api/search,get,Employee,Implement Global Search API Endpoint (GET /api/search),"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.
Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The Global Search API endpoint enables searching across various entities in the Deshio ERP system, providing a unified search interface for core domains like catalog, orders, inventory, customers, and more. It supports query parameters for terms, filters, and pagination to retrieve relevant results efficiently.

## API Specifications

- **Category:** search
- **Title:** Global Search
- **Description:** Search across entities
- **Route:** api/search
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET /api/search endpoint in a Laravel controller
- [ ] Support searching across core entities including products, categories, vendors, orders, customers, inventory batches, shipments, returns, payments, users, and roles
- [ ] Handle authentication exclusively for Employee users with appropriate RBAC permissions
- [ ] Validate input parameters such as query string (q), entity filters (e.g., entity=product), pagination (limit, offset), and sorting
- [ ] Return search results in a standardized JSON format with entity type, highlights, and relevant attributes (e.g., media, pricing, states)
- [ ] Ensure results respect soft deletes (exclude unless specified) and apply branch scope for scoped entities
- [ ] Integrate with state machines to only surface valid entity states
- [ ] Apply PII masking for sensitive customer data in results
- [ ] Support autosuggest-like partial matching and full-text search using Eloquent or Laravel Scout
- [ ] Handle errors and conflicts using RFC7807 problem+json format
- [ ] Add comprehensive unit, integration, and API tests covering happy paths, edge cases, and authorization failures
- [ ] Document the endpoint in API specs with examples of request/response
- [ ] Ensure compatibility with middleware stack: auth, RBAC, throttles, input sanitizer, cache headers, and request-id
- [ ] Performance: Index searchable fields; use caching/etag for repeated queries; aim for <500ms response time

## Technical Requirements

- Define the route in routes/api.php with Laravel's Route::get('search', [SearchController::class, 'index']);
- Create a dedicated SearchController with index method handling query parsing and entity-specific searches
- Use Eloquent models for querying normalized ERD; leverage EAV for attribute-based filtering; polymorphic relations for notes/attachments
- Implement search logic: Combine queries across entities using unions or a search service class; support filters like date ranges, store/branch, status, tags/blacklist
- Pagination: Use Laravel's LengthAwarePaginator for offset/limit, include total count and metadata
- Data handling: All timestamps in UTC; include media URLs, barcode lists, pricing overrides, promo impacts where applicable
- Integrations: Tie into reporting/analytics for aggregated results (e.g., low stock flags); audit search events via audit_event
- Error handling: Validate with Laravel Form Requests; throw ValidationException or custom exceptions for domain guards (e.g., fraud flag on orders)
- Testing: Use PHPUnit for backend; Pest for readable tests; mock auth and DB; cover bulk scenarios if extensible to imports
- Deployment: Ensure versioned API (e.g., /api/v1/search); health checks for search indices if using Scout/Elasticsearch
- Observability: Log search queries with request-id; metrics for search volume, hit rates; queue heavy searches if needed

## Authentication/Authorization Requirements

- Mandatory Employee authentication via JWT, session, or API key
- RBAC enforcement: Users must have 'search' permission in their role(s); multi-role support via user_role junction
- Additional checks: Active user status, email-verified, 2FA if enabled; branch scope to limit results to assigned stores/branches
- Optional: Tenancy isolation if multi-tenant mode active
- Reject unauthenticated/unauthorized with 401/403, including detailed problem+json

## Expected Request/Response Format Considerations

**Request:**
GET /api/search?q=search_term&entity=product&store_id=1&limit=20&offset=0&sort=relevance
- q: Required string for search term (full-text on name, description, attributes)
- entity: Optional filter (e.g., product, order, customer; default all)
- filters: JSON or query params for advanced (e.g., status=confirmed, date_from=YYYY-MM-DD)
- Headers: Accept: application/json; Authorization: Bearer <token>; X-Branch-Id: <id>

**Response:**
200 OK
{
  ""data"": [
    {
      ""type"": ""product"",
      ""id"": 123,
      ""attributes"": {
        ""name"": ""Item Name"",
        ""highlights"": [""matched term""],
        ""price"": 10.99,
        ""media"": [{""url"": ""/images/123.jpg""}],
        ""inventory"": {""available"": 50}
      },
      ""score"": 0.95
    }
  ],
  ""meta"": {
    ""total"": 100,
    ""limit"": 20,
    ""offset"": 0
  }
}
- For other entities, adapt attributes (e.g., order: state, total, payment_status; customer: tags, blacklist flag)
- Errors: 400 for invalid query; 422 for validation; 500 with problem+json
- Content negotiation: JSON only; versioned responses; ETag for caching

## Relevant Business Logic

- Search must enforce entity-specific rules: e.g., only show confirmed orders, respect reservations in inventory results, exclude blacklisted customers
- State machine integration: Filter to legal states (e.g., pending/fulfilled orders); prevent searching invalid transitions
- Ledger consistency: If search includes financials, ensure posted transactions only; support reversals/refunds visibility
- Fulfillment/returns: Include tracking/POD status in shipment/RMA results; fraud flags on orders
- Promotions/pricing: Highlight active promos, overrides in product results
- Compliance: Mask PII (e.g., customer email/phone partial); log audits for search on sensitive data (payments, personal info)
- Analytics tie-in: Optionally include metrics like LTV for customers, aging for inventory in enriched results
- Edge cases: Empty results return empty data[]; handle large result sets with pagination; support bulk-like exports via ?export=true
- Determinism: Results ordered by relevance/score; timezone-aware if locale/tz middleware applied
- Extensibility: Design for future autosuggest (e.g., /api/search/suggest), integrations (webhooks on search? unlikely), and feature flags for search providers"
218,search,Advanced Search,Structured search queries,api/search/advanced,post,Admin,Implement Advanced Search API Endpoint (POST /api/search/advanced),"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint provides structured search queries across the Deshio ERP system's entities, enabling advanced search functionality in the search category.

## API Specifications

- **Category:** search
- **Title:** Advanced Search
- **Description:** Structured search queries
- **Route:** api/search/advanced
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST /api/search/advanced endpoint in Laravel
- [ ] Support structured search queries across core entities (e.g., products, categories, orders, inventory)
- [ ] Integrate with search/autosuggest features and EAV attributes
- [ ] Handle authentication and authorization for Admin users only
- [ ] Include input validation for search parameters
- [ ] Return results in JSON format with proper pagination and filtering
- [ ] Implement error handling using RFC7807 problem+json for conflicts or invalid queries
- [ ] Add unit and integration tests covering happy path, edge cases, and errors
- [ ] Ensure compatibility with middleware stack (e.g., auth, RBAC, throttling)
- [ ] Log audit events for search queries if applicable
- [ ] Document the endpoint in API docs with examples

## Technical Requirements

- Use Laravel controller and define route in api.php
- Leverage Eloquent models for querying normalized ERD entities
- Implement search using Laravel Scout or custom query builder for structured queries
- Support filtering by attributes, tags, states, and relationships (e.g., orders by store, products by category)
- Handle soft deletes and UTC timestamps in results
- Integrate with caching/etag for performance
- Use queues if search is resource-intensive
- Ensure idempotency for repeated searches
- Add request ID for observability

## Authentication/Authorization Requirements

- Require Admin authentication via JWT, session, or API key
- Enforce RBAC: Only users with Admin role/permission can access
- Apply middleware: auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope
- Reject unauthorized requests with 401/403 and problem+json response

## Expected Request/Response Format Considerations

- **Request:** JSON body with structured search parameters (e.g., { ""entity"": ""product"", ""filters"": { ""category_id"": 1, ""price_min"": 10 }, ""query"": ""search term"", ""page"": 1, ""limit"": 20 })
- **Response:** JSON array of results with metadata (e.g., { ""data"": [...], ""meta"": { ""total"": 100, ""page"": 1 } })
- Use content-negotiation for versioned responses
- Errors: RFC7807 problem+json (e.g., { ""type"": ""validation_error"", ""title"": ""Invalid query"", ""detail"": ""..."" })
- Set cache headers and ETag for conditional requests

## Relevant Business Logic

- Searches should respect entity states (e.g., order states via state machines)
- Filter by branch/store scope and permissions
- Support PII masking in results for compliance
- Integrate with reporting/analytics for search-derived metrics if needed
- Ensure transactional consistency for any related operations (e.g., audit logging)
- Handle bulk search scenarios compatible with import/export features"
219,import-export,Import Customers,CSV/Excel import,api/customers/import,post,Admin,Implement Import Customers API Endpoint (POST /api/customers/import),"## Overview

This GitHub issue is for implementing the 'Import Customers' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint supports CSV/Excel import for customers, integrating with customer entities including tags and blacklist features.

## API Specifications

- **Category:** import-export
- **Title:** Import Customers
- **Description:** CSV/Excel import
- **Route:** api/customers/import
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST /api/customers/import endpoint to handle CSV/Excel file uploads for bulk customer creation
- [ ] Validate uploaded file format (CSV or Excel) and content against customer schema including required fields, tags, and blacklist status
- [ ] Process import successfully, creating or updating customer records with proper UTC timestamps and soft delete handling
- [ ] Handle errors gracefully, returning RFC7807 problem+json for validation failures, duplicates, or import conflicts
- [ ] Ensure integration with RBAC for admin-only access and audit logging for import events
- [ ] Support idempotency for repeated imports to avoid duplicates
- [ ] Write unit and integration tests covering successful imports, edge cases (e.g., invalid data, large files), and error scenarios
- [ ] Document the endpoint in API specs with request/response examples
- [ ] Verify compatibility with middleware stack including auth, throttling, and input sanitization

## Technical Requirements

- Use Laravel controller (e.g., CustomerController@import) and define route in api.php with admin middleware
- Implement file upload handling via multipart/form-data, using Laravel's Storage and packages like Maatwebsite/Excel for parsing
- Apply input validation with Laravel Validator for file type (CSV/XLSX), size limits, and data rows (e.g., email uniqueness, required fields like name, email)
- Integrate with Customer model, supporting EAV attributes, polymorphic relations, and tags/blacklist associations
- Use queues for large imports to handle asynchronously if needed, with progress tracking
- Ensure transactional database operations for atomicity during import
- Add proper error handling with try-catch, logging via audit_event and request-id tracing
- Incorporate PII masking for customer data in logs and responses
- Follow Deshio conventions: versioned API, content-negotiation, cache headers, and state machine checks if applicable for customer lifecycle

## Authentication/Authorization Requirements

- Require Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have 'admin' role or specific permission (e.g., 'customers.import')
- Apply middleware chain: auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope (if multi-tenant), throttles, idempotency
- Reject unauthorized requests with 401/403 status and problem+json details

## Expected Request/Response Format Considerations

- **Request:** multipart/form-data with 'file' (CSV/Excel upload), optional 'options' JSON (e.g., { ""update_existing"": true, ""tag_ids"": [1,2] } for behavior control)
  - CSV headers expected: e.g., name, email, phone, address, tags (comma-separated), blacklist (boolean)
  - Max file size: 10MB, validated via upload mime guard
- **Response (Success - 201 Created):** JSON with { ""success"": true, ""imported"": 50, ""skipped"": 5, ""errors"": [] } and Location header for import job if queued
- **Response (Validation Error - 422 Unprocessable Entity):** RFC7807 problem+json, e.g., { ""type"": ""validation_error"", ""title"": ""Invalid data"", ""detail"": ""Row 3: Duplicate email"", ""invalid-params"": [...] }
- **Response (Unauthorized - 401/403):** Standard auth error in problem+json format
- Use JSON limits middleware and ensure responses are cacheable where appropriate

## Relevant Business Logic

- Customers are core entities with tags for segmentation and blacklist for restrictions (e.g., fraud prevention)
- During import, validate against existing customers to prevent duplicates (e.g., by email/phone); support update if opted
- Apply domain guards for fraud checks if blacklist-related; synchronize with order/payment domains if customer links exist
- Post-import, trigger any necessary events like email verification sends or audit logs for compliance
- Ensure all data stored in UTC; handle soft deletes if importing archived customers
- Integrate with reporting/analytics for tracking new customer acquisitions (e.g., LTV/AOV impacts)
- Conflicts (e.g., invalid email) should use state machines if extending customer lifecycle, returning problem+json
- Support bulk operations aligning with Deshio's import/export patterns, including reindex for search/autosuggest post-import"
220,import-export,Export Customers,Export CSV/Excel,api/customers/export,get,Admin,Implement Export Customers API Endpoint (GET /api/customers/export),"## Context about Deshio ERP

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.
Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

## Overview

Implement the Export Customers API endpoint for the Deshio ERP system. This endpoint allows administrators to export customer data in CSV or Excel format, supporting bulk export operations as part of the import-export category. It aligns with the system's core entities for customers, including tags and blacklist information, while adhering to security, observability, and compliance standards.

## API Specifications

- **Category:** import-export
- **Title:** Export Customers
- **Description:** Export CSV/Excel
- **Route:** api/customers/export
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint returns customer data in CSV format when requested
- [ ] Endpoint returns customer data in Excel format when requested (e.g., via query parameter or Accept header)
- [ ] Export includes core customer fields, tags, and blacklist status
- [ ] Authentication restricts access to Admin users only, with RBAC permission checks
- [ ] Handles large datasets efficiently with streaming or chunking to avoid memory issues
- [ ] Supports filtering/query parameters for selective exports (e.g., by date range, status)
- [ ] Returns appropriate HTTP status codes and RFC7807 problem+json for errors
- [ ] Includes audit logging for export events
- [ ] Unit and integration tests cover successful exports, auth failures, and error cases
- [ ] Documentation updated with request/response examples

## Technical Requirements

- Use Laravel framework: Define route in api.php, create dedicated controller (e.g., CustomerExportController)
- Implement export logic using Laravel Excel (Maatwebsite/Excel) for CSV/Excel generation
- Query customer data from the normalized ERD, joining relevant tables (customers, tags, blacklist)
- Apply soft deletes filter to exclude archived records unless specified
- Ensure data is anonymized or PII masked if required by compliance
- Integrate with middleware stack: auth, RBAC checks, request-id, throttles, idempotency
- Handle timezones (UTC storage) and locale considerations
- For large exports, use queues or background jobs if necessary
- Error handling: Validate inputs, return 4xx/5xx with problem+json

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have 'export-customers' permission or equivalent role
- Include active user, email-verified, and 2FA checks via middleware
- Branch scope if applicable; optional tenancy isolation

## Expected Request/Response Format Considerations

- **Request:** GET /api/customers/export?format=csv&filters[date_from]=2023-01-01 (query params for format, filters)
- **Response:** Binary download (CSV/Excel file) with Content-Disposition: attachment; filename=""customers_export.csv""
- For errors: JSON with RFC7807 format, e.g., { ""type"": ""https://example.com/probs/export-failed"", ""title"": ""Export Failed"", ""status"": 400, ""detail"": ""Invalid format"" }
- Support content negotiation for format selection (Accept: application/vnd.ms-excel or text/csv)
- Ensure exports include headers and respect EAV attributes for customer fields

## Relevant Business Logic

- Export customer entities with associated tags and blacklist flags
- Respect data privacy: Exclude sensitive PII unless authorized; apply masking
- Integrate with observability: Log export events in audit_event table with request-id
- Align with state machines if customer status affects export (e.g., active only)
- Ensure transactional consistency; no direct DB writes, but log for compliance
- Support bulk operations in line with Deshio's import/export APIs
- Handle polymorphic relations like notes/attachments if included in export"
221,import-export,Import Inventory,Bulk load inventory,api/inventory/import,post,Admin,Implement API: POST /api/inventory/import for Bulk Inventory Load,"## Overview

Deshio is a Laravel-based ERP system for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers.

This API endpoint enables bulk loading of inventory data, allowing administrators to import inventory batches, adjustments, or initial stock levels in a structured format. It integrates with the inventory domain's state machines for legality of transitions, ensures transactional stock movements, and posts to accounting ledgers for all events. Data is stored in UTC with soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across junctions. Design supports deterministic admin assignment, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint falls under the import-export category and should handle bulk operations securely, with validation, error handling per RFC7807 problem+json for conflicts, and observability via audit_event, logs, request-id, PII masking.

## API Specifications

- **Category:** import-export
- **Title:** Import Inventory
- **Description:** Bulk load inventory
- **Route:** api/inventory/import
- **HTTP Method:** post
- **Authentication:** Admin

Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, cache headers.

## Acceptance Criteria

- [ ] Implement the POST /api/inventory/import endpoint in Laravel controller
- [ ] Support bulk import of inventory data (e.g., batches, quantities, locations) via multipart/form-data or JSON payload
- [ ] Validate input data against inventory schema (batch-centric, per-unit options, reservations, adjustments)
- [ ] Handle file uploads for CSV/Excel imports with mime type guarding
- [ ] Integrate with state machines for legal transitions (e.g., pending to confirmed inventory states)
- [ ] Ensure transactional stock movements and ledger postings for accounting (transaction headers + ledger_entry lines)
- [ ] Apply RBAC: Restrict to Admin roles/permissions; check user_role multi-role abilities
- [ ] Implement error handling with RFC7807 problem+json for validation failures, conflicts, or idempotency issues
- [ ] Add audit trails (audit_event) and logging with request-id for all import operations
- [ ] Support soft deletes and UTC storage; handle EAV attributes if applicable
- [ ] Write unit/integration tests covering success, validation errors, auth failures, and bulk scenarios
- [ ] Document request/response schemas in OpenAPI/Swagger
- [ ] Ensure compatibility with reporting/analytics (e.g., inventory aging, low stock updates post-import)

## Technical Requirements

- Use Laravel framework: Define route in api.php, create dedicated InventoryImportController
- Input validation: Leverage Laravel's FormRequest for rules on import file/format, batch details, store/branch scoping
- Process imports asynchronously if large (via queues) with progress tracking
- Integrate with inventory models: Handle batch-centric inventory, optional per-unit items, reservations, cycle counts
- Business logic: Validate against existing stock (prevent over-reservation), apply pricing/promos if tied to inventory, flag fraud if anomalies detected; synchronize with order domain if reservations affected
- Error handling: Return 4xx/5xx with problem+json; support idempotency keys to avoid duplicate imports
- Observability: Emit metrics/health checks, use caching/etag, PII masking for customer-related inventory
- Integrations: If import affects shipments/dispatches, trigger webhooks; ensure referential integrity across ERD
- Security: Enforce 2FA/MFA for admins, API key support, replay defense for uploads
- Reporting: Update analytics views (e.g., units by store/product) post-import

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC checks: User must have 'import-inventory' permission via role↔perm mapping; support multi-role (user_role)
- Additional guards: Active user, email-verified, 2FA (TOTP + backup codes), branch scope to prevent cross-branch imports
- Optional tenancy isolation if multi-tenant mode enabled

## Expected Request/Response Format Considerations

- **Request:** multipart/form-data for file uploads (CSV/JSON/Excel with columns: batch_id, product_sku, quantity, location/store_id, expiry_date, cost_price, notes); or JSON array for direct bulk data. Include idempotency-key header. Max size via JSON limits middleware.
- **Response:** 201 Created on success with { ""imported"": N, ""warnings"": [], ""job_id"": ""uuid"" } for async; 202 Accepted with job details. Errors: 400 Bad Request with problem+json (e.g., { ""type"": ""validation_error"", ""title"": ""Invalid batch"", ""detail"": ""..."" }). Use versioned content-negotiation (e.g., Accept: application/vnd.deshio.v1+json).
- Sanitize inputs, validate mime types, handle polymorphic attachments if notes included.

## Relevant Business Logic

- Inventory imports must respect batch-centric model: Create/update batches with optional per-unit serialization.
- Trigger adjustments/valuations/ledgers on import; support reversals if partial failures.
- Check for promotions/pricing overrides affected by new stock; reserve if tied to pending orders.
- Ensure compliance: No PII in imports unless masked; audit all events.
- State machines: Validate transitions (e.g., initial load as 'pending' → 'confirmed' post-validation).
- Bulk operations: Atomic per-batch, rollback on failure; support cycle count reconciliation if import corrects counts.
- Edge cases: Handle zero-quantity (removal), negative adjustments, inter-store transfers via dispatch integration."
222,import-export,Export Inventory,Export inventory,api/inventory/export,get,Admin,Implement Export Inventory API Endpoint,"## Overview

As a technical writer creating GitHub issues for API implementation in the Deshio ERP system, this issue covers the development of the Export Inventory API endpoint. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. The export functionality allows administrators to retrieve inventory data in a structured format, potentially for reporting, backups, or integrations. This endpoint falls under the import-export category and enables exporting current inventory states, including batch details, stock levels, valuations, and related metadata, ensuring compliance with data stored in UTC, soft deletes for archival, EAV for attributes, polymorphic notes/attachments, and strict referential links across junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

## API Specifications

- **Category:** import-export
- **Title:** Export Inventory
- **Description:** Export inventory
- **Route:** api/inventory/export
- **HTTP Method:** GET
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET /api/inventory/export endpoint in Laravel
- [ ] Ensure the endpoint exports comprehensive inventory data including batches, reservations, adjustments, valuations, and ledgers
- [ ] Support filtering, pagination, or format options (e.g., CSV, JSON) if applicable to inventory export needs
- [ ] Add input validation for any query parameters (e.g., date ranges, store filters)
- [ ] Implement proper error handling using RFC7807 problem+json for conflicts or invalid states
- [ ] Write unit and integration tests covering successful exports, edge cases, and authorization failures
- [ ] Verify integration with state machines for inventory legality and stock movements
- [ ] Ensure observability: include audit_event logging, request-id, PII masking, and metrics
- [ ] Test for middleware compliance: TLS/HSTS, CORS, auth (JWT/session/API key), RBAC & permission checks, branch scope, throttles, idempotency, input sanitizer

## Technical Requirements

- Use Laravel controller and routes: Define the route in api.php with admin middleware
- Inventory export logic: Query batch-centric inventory data, join with products, stores, ledgers; handle soft deletes and UTC timestamps
- Output format: Return downloadable file (e.g., CSV/Excel) or JSON array; consider bulk export capabilities
- Performance: Use queues for large exports, caching/etag, and efficient queries to avoid N+1 issues
- Integrations: Align with reporting/analytics features like inventory aging/low stock, cycle count accuracy
- Security: Enforce admin role/permission via RBAC; optional tenancy and branch scope
- Error handling: Return 4xx/5xx with problem+json; log errors with request-id
- Testing: PHPUnit tests for controller, validation, and business rules; feature tests for full flow

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC check: User must have admin role with permissions for inventory export (ability role↔perm)
- Additional guards: Active user, email-verified, 2FA (TOTP MFA + backup codes), branch scope
- Middleware stack: auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope, throttles, idempotency

## Expected Request/Response Format Considerations

- **Request:** GET api/inventory/export?params (e.g., ?store_id=1&from_date=YYYY-MM-DD&format=csv)
  - Query parameters: Optional filters for stores, date ranges, product categories; validate with Laravel's FormRequest
  - Headers: Accept: application/json or text/csv; Authorization: Bearer <token>
- **Response:** 
  - Success (200): JSON array of inventory records or streamed file download with Content-Disposition: attachment
    Example JSON: {""data"": [{""batch_id"": 1, ""product_id"": 123, ""quantity"": 50, ""valuation"": 1000.00, ""store_id"": 1, ...}]}
  - Error (401/403): Unauthorized or forbidden with problem+json
  - Error (422): Validation errors
- Content negotiation: Versioned, locale/tz aware; JSON limits, upload mime guard if attachments involved

## Relevant Business Logic

- Inventory export must reflect current states: pending reservations, confirmed adjustments, cycle counts, and ledger entries
- Handle batch-centric data: Include per-unit items if applicable; support reservations and stock movements
- Compliance: Export data with PII masking; include audit trails but respect soft deletes
- State machines: Ensure export legality, e.g., only export non-conflicting inventory states; return errors for invalid transitions
- Accounting sync: Include transaction headers + ledger_entry lines for movements; support reversals and reconciliation
- Integrations: Compatible with carriers, webhooks, notifications; enable exports for reporting like revenue/units by store/product, inventory aging, low stock alerts
- Edge cases: Empty inventory, large datasets (use pagination or async), multi-store/branch filtering, timezone conversions from UTC"
223,attachment,Upload,Upload file,api/attachments,post,Employee,Implement Attachment Upload API Endpoint (POST /api/attachments),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the 'Upload' API endpoint in the 'attachment' category. This endpoint allows uploading files, supporting polymorphic notes/attachments across core entities like products, orders, customers, and more. Deshio handles core entities such as product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment covers shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns include RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments manage intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting features transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services include service/service_order with lifecycle and profitability. Integrations cover carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint facilitates secure file uploads for attachments, ensuring integration with the polymorphic attachment system and adherence to upload guards.

## API Specifications

- **Category:** attachment
- **Title:** Upload
- **Description:** Upload file
- **Route:** api/attachments
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST /api/attachments endpoint in Laravel controller
- [ ] Support multipart/form-data for file uploads with MIME type validation via upload mime guard
- [ ] Integrate polymorphic attachment storage, allowing association with entities like orders, products, customers, etc.
- [ ] Apply middleware: auth (JWT/session/API key), RBAC & permission checks for Employee role, upload mime guard, input sanitizer, throttles, idempotency
- [ ] Handle successful uploads by returning attachment details (e.g., ID, URL, metadata) in JSON response
- [ ] Return RFC7807 problem+json for errors (e.g., invalid file type, size limits, auth failures)
- [ ] Log audit_event for upload actions with request-id and PII masking if applicable
- [ ] Ensure data stored in UTC with soft deletes capability
- [ ] Write unit/integration tests covering valid/invalid uploads, auth scenarios, and error cases
- [ ] Document endpoint in API specs with request/response examples

## Technical Requirements

- Use Laravel framework: Define route in api.php, create AttachmentsController with upload method
- Implement file storage using Laravel's Storage facade, supporting local/S3/etc. with ETag/caching headers
- Validation: Use FormRequest for input (file size limits, allowed MIME types e.g., images/PDFs), custom rules for polymorphic attachable_id/attachable_type
- Error handling: Consistent with Deshio standards, using exceptions for domain guards and returning standardized JSON errors
- Database: Store in attachments table with fields like id, filename, path, size, mime_type, attachable_id, attachable_type, uploaded_by (user_id), timestamps; ensure referential integrity
- Queue file processing if large uploads, with job for post-upload tasks (e.g., virus scan, thumbnail generation)
- Observability: Integrate with audit_event, log, and metrics for upload success/failure rates

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT/session/API key
- RBAC check: Employee role must have permission for 'attachment.upload' or equivalent ability
- Additional checks: Active user, email-verified, optional 2FA; branch scope if attachment tied to store/branch
- Idempotency key to prevent duplicate uploads

## Expected Request/Response Format Considerations

- **Request:** multipart/form-data
  - file: required, uploaded file (with size/mime limits)
  - attachable_id: optional, ID of entity to attach (e.g., order_id)
  - attachable_type: optional, Morph class (e.g., App\Models\Order)
  - idempotency_key: optional, for safe retries
  - Other metadata: e.g., description
- **Response (Success - 201 Created):** application/json
  {
    ""data"": {
      ""id"": 1,
      ""filename"": ""example.jpg"",
      ""url"": ""/storage/attachments/example.jpg"",
      ""mime_type"": ""image/jpeg"",
      ""size"": 1024,
      ""attachable_id"": 123,
      ""attachable_type"": ""App\\Models\\Order""
    }
  }
- **Response (Error - e.g., 422 Unprocessable Entity):** application/problem+json (RFC7807)
  {
    ""title"": ""Validation Error"",
    ""status"": 422,
    ""detail"": ""Invalid file type"",
    ""type"": ""https://example.com/probs/validation-error""
  }
- Versioned content-negotiation, locale/tz handling, cache headers

## Relevant Business Logic

- Attachments are polymorphic, linkable to any attachable model (e.g., orders for notes/attachments, products for media)
- Enforce upload mime guard to prevent malicious files; optional domain guards if attachment context requires (e.g., fraud flag on order attachments)
- Transactional: Ensure atomic upload and DB insert; rollback on failure
- Post-upload: Trigger events for notifications (e.g., email/SMS via templates), audit logging, and potential webhooks
- Compliance: PII masking in logs if file contains sensitive data; support for feature flags to enable/disable uploads
- Integration with state machines: If attaching to stateful entities (e.g., orders), validate transition legality indirectly via permissions
- Soft deletes for archival; EAV if custom attachment attributes needed"
224,attachment,Get,Get attachment,api/attachments/{id},get,Employee,Implement GET /api/attachments/{id} for Retrieving Attachments,"## Overview

Deshio is a Laravel-based ERP system for retail/omni-channel operations, featuring approximately 290 REST APIs built over a normalized ERD. It covers domains including catalog (products/categories/vendors with attributes, media like product_images, barcodes, pricing with overrides, promotions), stores/branches, customers with tags/blacklists. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to stores, notes/attachments, promotions, taxes, and fraud flags. Fulfillment handles shipments (shipment/shipment_item) and inter-store dispatches (dispatch + tracking, scan events, POD) with transactional stock movements. Returns manage RMAs (return/return_item), receiving/restocking/scrap, refunds, and exchanges (exchange_order). Payments involve intent→payment capture/void, refund lifecycles, and order.payment_status synchronization. Accounting uses transaction headers + ledger_entry lines for all movements, reversals, and reconciliation/export. Services include service/service_order with lifecycles and profitability. Integrations cover carriers/accounts, waybills/rates/tracking, webhooks with deliveries, and notification templates (email/SMS). Security and identity features user/role/permission with abilities (role↔perm) and multi-role user_roles, sessions, email verification, password reset, TOTP MFA + backup codes, and API keys. Observability and compliance include audit_event, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware encompasses TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics provide revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines enforce legal transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC with soft deletes for archival, EAV for attributes, polymorphic notes/attachments, and strict referential links across junctions. The design ensures deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This issue focuses on implementing the 'Get attachment' API endpoint in the attachment category. Attachments are polymorphic and can be associated with various entities (e.g., orders, products, notes) across the Deshio ERP system. The endpoint retrieves a specific attachment by ID, serving its content or metadata while enforcing access controls based on the attached entity and user permissions.

## API Specifications

- **Category:** attachment
- **Title:** Get
- **Description:** Get attachment
- **Route:** api/attachments/{id}
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET /api/attachments/{id} endpoint to retrieve attachment details and/or content
- [ ] Validate the {id} parameter as a valid UUID or integer identifier for the attachment
- [ ] Return 200 OK with the attachment data (e.g., metadata, file content as base64 or direct download) if found and accessible
- [ ] Return 404 Not Found if the attachment ID does not exist
- [ ] Return 403 Forbidden if the authenticated employee lacks RBAC permissions to access the attachment or its parent entity
- [ ] Handle soft-deleted attachments by excluding them or returning 404
- [ ] Apply middleware for authentication, RBAC checks, request ID, and error handling per Deshio standards
- [ ] Ensure responses use UTC timestamps and follow content-negotiation for JSON or file serving
- [ ] Write unit/integration tests covering success, 404, 403, invalid ID, and permission scenarios
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger)
- [ ] Verify compatibility with polymorphic attachments (e.g., linked to orders, products, shipments)
- [ ] Test for audit logging of access events

## Technical Requirements

- Use Laravel framework: Define the route in routes/api.php with appropriate middleware stack (auth:employee, rbac:view-attachments, etc.)
- Create or extend AttachmentController with a show() method to handle the GET request
- Leverage Eloquent model for Attachment (polymorphic relation to attachable entities like Order, Product, etc.)
- Implement input validation using FormRequest or inline rules for {id} (required, exists:attachments,id)
- Handle file serving: If attachment is media (e.g., product_image), use Laravel's response()->file() or stream for downloads; for JSON, return structured data with URL or base64
- Integrate state machine checks if applicable (e.g., ensure parent entity state allows access)
- Use Deshio's error response format: RFC7807 problem+json for validation/errors
- Ensure transactional integrity if retrieval involves ledger or audit updates
- Add caching/ETag support for performance, with branch scope if attachment is store-specific
- Follow security: Sanitize inputs, mask PII in responses, apply throttles and idempotency if needed

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- Enforce active user status, email verification, and 2FA if enabled
- RBAC: User must have permission to view attachments (e.g., 'attachments.view' ability assigned via role)
- Scope checks: Respect branch/store scope if attachment is entity-specific (e.g., order attachments visible only to assigned store employees)
- Audit the access event in audit_event table with request-id

## Expected Request/Response Format Considerations

- **Request:** No body; path param {id} (e.g., GET /api/attachments/123). Query params optional for format (e.g., ?format=json or ?download=true).
- **Success Response (200):** JSON object with attachment metadata (id, name, mime_type, size, created_at, attachable_type, attachable_id, url or content) or direct file stream with headers (Content-Type, Content-Disposition).
- **Error Responses:** 400 for invalid ID format; 401 Unauthorized; 403 Forbidden; 404 Not Found; 500 Internal Server Error (with problem+json: type, title, detail, instance).
- Follow Deshio conventions: Versioned API (e.g., /v1/attachments/{id}), locale/tz headers, cache headers, JSON limits.
- For file attachments, support range requests for large files; ensure secure URLs with signatures if temporary.

## Relevant Business Logic

- Attachments are polymorphic (via morphTo('attachable')) and linked to core entities (e.g., orders, products, shipments, returns).
- Access must verify permissions on the parent entity (e.g., if attached to an order, user needs 'orders.view' for that order's branch).
- Handle soft deletes: Query withWithTrashed() only if user has archival access; otherwise, treat as non-existent.
- Integrate with media handling (e.g., product_image via attachments); trigger audit_event on retrieval.
- Ensure consistency with ledger posting if attachment relates to financial/stock events (though retrieval is read-only).
- Conflicts (e.g., concurrent edits) resolved via optimistic locking or ETag; state machines may restrict access based on entity state (e.g., cancelled order attachments read-only)."
225,attachment,Delete,Delete attachment,api/attachments/{id},delete,Employee,Implement DELETE /api/attachments/{id} Endpoint,"## Overview

This GitHub issue is for implementing the Delete Attachment API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs built over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media (e.g., product_image), barcodes, pricing, promotions, stores/branches, customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. Order domain features states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flags. Fulfillment includes shipments and inter-store dispatches with tracking and stock movements. Returns handle RMAs, restocking, refunds, exchanges. Payments manage intents, captures, voids, refunds, and order synchronization. Accounting uses transaction headers and ledger entries for movements, reversals, reconciliation. Services include service orders with lifecycle and profitability. Integrations cover carriers, waybills, tracking, webhooks, notifications (email/SMS). Security features user/role/permission with abilities, multi-role assignments, sessions, email verification, password reset, TOTP MFA, API keys. Observability includes audit events, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware encompasses TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC/permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, webhook signatures, cache headers. Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price history, cycle count accuracy, promo impact, activity. State machines ensure legal transitions for orders, dispatches, shipments, returns, payments, cycle counts; conflicts use RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data is stored in UTC, uses soft deletes for archival, EAV for attributes, polymorphic notes/attachments, strict referential links. Design supports deterministic admin assignment, safe reservation/consumption, consistent ledger posting on stock/financial events.

The endpoint allows authenticated employees to delete attachments, which are polymorphic and associated with entities like orders or products. Deletions should use soft deletes to maintain audit trails.

## API Specifications

- **Category:** attachment
- **Title:** Delete
- **Description:** Delete attachment
- **Route:** api/attachments/{id}
- **HTTP Method:** DELETE
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the DELETE endpoint handler in a Laravel controller
- [ ] Require authentication as an Employee (via JWT/session/API key)
- [ ] Enforce RBAC and permission checks for attachment deletion
- [ ] Validate the attachment ID as a valid UUID or integer
- [ ] Perform soft delete on the attachment if authorized and exists
- [ ] Return 204 No Content on successful deletion
- [ ] Return 404 Not Found if attachment does not exist
- [ ] Return 403 Forbidden if user lacks permissions
- [ ] Return 422 Unprocessable Entity for invalid input (e.g., malformed ID)
- [ ] Log audit events for deletion attempts
- [ ] Handle errors using RFC7807 problem+json format for conflicts
- [ ] Write unit/integration tests for success, authorization failure, not found, and validation errors
- [ ] Ensure idempotency for repeated delete requests
- [ ] Test integration with polymorphic relations (e.g., attachments on orders/products)
- [ ] Verify soft delete preserves data for archival and audits

## Technical Requirements

- Define the route in routes/api.php with middleware stack: auth, active user, RBAC checks, branch scope if applicable
- Use Laravel's Attachment model with soft deletes enabled
- Implement in AttachmentsController (or equivalent) with method destroy($id)
- Use path parameter {id} for attachment identification
- Apply input validation via FormRequest or controller validation (e.g., 'id' => 'required|exists:attachments,id')
- Integrate with state machines if deletion affects entity states (unlikely for attachments, but check polymorphic parents)
- Ensure transactional integrity if deletion impacts related ledgers or audits
- Add ETag/caching headers if applicable, but likely unnecessary for DELETE
- Use RequestId middleware for tracing
- Handle PII masking in logs if attachment contains sensitive data

## Authentication/Authorization Requirements

- Authentication: Required via Employee credentials (JWT, session, or API key)
- Authorization: RBAC check for 'delete' permission on attachments; respect user_role multi-role assignments and ability mappings
- Additional checks: Active user, email-verified, 2FA if enabled; branch scope to ensure employee can only delete attachments in their scoped branches
- Use middleware for auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks

## Expected Request/Response Format Considerations

- **Request:** No body required; path parameter {id} (e.g., DELETE /api/attachments/123). Headers: Authorization, Accept: application/json, Content-Type: application/json (though no body)
- **Success Response:** 204 No Content
- **Error Responses:**
  - 401 Unauthorized: Missing/invalid auth
  - 403 Forbidden: Insufficient permissions
  - 404 Not Found: Attachment ID not found
  - 422 Unprocessable Entity: Invalid ID format, using RFC7807 problem+json (e.g., {""type"": ""https://example.com/probs/validation"", ""title"": ""Invalid ID"", ""status"": 422, ""detail"": ""The selected id is invalid.""})
- Versioned via content-negotiation (e.g., Accept: application/vnd.deshio.v1+json)
- All timestamps in UTC; use ETag if caching attachments

## Relevant Business Logic

- Attachments are polymorphic, linked to entities like orders, products, or notes; deletion must not cascade but soft-delete to preserve referential integrity and audits
- Trigger audit_event on deletion for compliance
- If attachment is media (e.g., product_image), ensure no impact on core entity visibility; consider ledger_entry if financial implications (rare)
- Respect soft deletes: Query withWithTrashed() only if needed, but default to permanent archival via soft delete
- Domain guards: Prevent deletion if attachment is in use (e.g., attached to active order) via state machine checks
- Idempotency: Deleting a non-existent or already-deleted (soft) attachment should return 204 without error
- Integrations: If attachment is part of notifications or webhooks, trigger relevant events post-deletion"
226,notification,List Templates,Email/SMS templates,api/notifications/templates,get,Admin,Implement GET /api/notifications/templates for Listing Email/SMS Templates,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the 'List Templates' API endpoint. This endpoint handles email/SMS templates in the notification category, enabling retrieval of configurable templates for notifications. Core entities include product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, ledgers. Order domain covers states, assignment, notes, promos, taxes, fraud. Fulfillment includes shipments, dispatches with tracking. Returns via RMA with restock/refunds/exchanges. Payments with intent capture, refunds. Accounting with transaction headers, ledger entries. Services with service orders. Integrations for carriers, webhooks, notifications. Security with user/role/permission, sessions, MFA, API keys. Observability with audits, logs, PII masking. Middleware includes TLS, CORS, auth (JWT/session/API key), RBAC, throttles, etc. Reporting on revenue, LTV, etc. State machines for transitions, RFC7807 errors. APIs support bulk ops, search, attachments, etc. Data in UTC, soft deletes, EAV, polymorphic relations. Design ensures deterministic assignments, safe reservations, consistent ledgers.

This endpoint specifically lists notification templates for email/SMS, supporting the system's notification features.

## API Specifications

- **Category:** notification
- **Title:** List Templates
- **Description:** Email/SMS templates
- **Route:** api/notifications/templates
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint returns a list of all available email/SMS notification templates
- [ ] Supports pagination, filtering (e.g., by type: email/sms), and sorting
- [ ] Handles authentication and authorization correctly for admin users only
- [ ] Returns appropriate HTTP status codes (200 for success, 401/403 for auth issues, 500 for errors)
- [ ] Includes proper error responses in RFC7807 problem+json format for conflicts or invalid requests
- [ ] Integrates with middleware for request ID, throttling, input sanitization, and cache headers
- [ ] Templates include relevant fields like ID, name, type (email/sms), subject, body, variables, status (active/inactive)
- [ ] Add unit and integration tests covering happy path, auth failures, empty list, large datasets
- [ ] Document the endpoint in API docs (e.g., OpenAPI/Swagger)
- [ ] Ensure compatibility with soft deletes and UTC timestamps

## Technical Requirements

- Implement in Laravel: Define route in api.php, create NotificationTemplateController with index method
- Use Eloquent models for templates (e.g., NotificationTemplate model with fields: id, name, type, subject, body, variables json, status, created_at, updated_at)
- Apply query builder for listing: Support ?page=, ?per_page=, ?type=, ?search= params
- Pagination via Laravel's LengthAwarePaginator, return JSON with meta (total, current_page, etc.)
- Response format: { data: [ { id, name, type, ... } ], meta: { ... } }
- Input validation: Use FormRequest for query params (e.g., type enum ['email','sms'], search string max 255)
- Error handling: Catch exceptions, return problem+json with title, detail, status
- Integrate with RBAC: Check if user has 'admin' role or specific permission for notifications
- Consider caching: Use etag or query caching for performance
- Ensure idempotency and replay defense if applicable
- Follow conventions: Soft deletes, polymorphic relations if templates link to notes/attachments
- Queue any heavy ops if needed, but listing should be lightweight

## Authentication/Authorization Requirements

- Requires admin authentication via JWT, session, or API key
- Middleware stack: auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks (e.g., 'view-notification-templates' permission), branch scope if applicable
- Reject non-admin users with 403 Forbidden
- Support for multi-role users; check against user_role junction
- Include request-id in logs/audits for observability

## Expected Request/Response Format Considerations

- **Request:** GET /api/notifications/templates?page=1&per_page=20&type=email&search=order
  - No body required
  - Query params: page (int, default 1), per_page (int, 1-100, default 15), type (enum: email,sms, all), search (string, optional)
- **Success Response (200):** 
  {
    ""data"": [
      {
        ""id"": 1,
        ""name"": ""Order Confirmation"",
        ""type"": ""email"",
        ""subject"": ""Your Order #{order_id}"",
        ""body"": ""Template body with variables"",
        ""variables"": [""order_id"", ""customer_name""],
        ""status"": ""active"",
        ""created_at"": ""2023-01-01T00:00:00Z"",
        ""updated_at"": ""2023-01-01T00:00:00Z""
      }
    ],
    ""meta"": {
      ""current_page"": 1,
      ""last_page"": 1,
      ""per_page"": 20,
      ""total"": 1
    }
  }
- **Error Response (e.g., 401):** 
  {
    ""type"": ""https://tools.ietf.org/html/rfc7231#section-6.5.1"",
    ""title"": ""Unauthorized"",
    ""status"": 401,
    ""detail"": ""Admin access required""
  }
- Use JSON content-type, versioned if applicable (e.g., /v1/ prefix)
- Handle large responses efficiently with limits

## Relevant Business Logic

- Templates support variables for dynamic content (e.g., {order_id}, {customer_email})
- Types: Email templates include subject/body in HTML/text; SMS limited to short text
- Status: active/inactive to control usage in notifications
- Integration: Used in webhooks, order fulfillments, payments, etc., for automated emails/SMS
- Auditing: Log access to audit_event for compliance
- State machines not directly applicable, but ensure no illegal states (e.g., deleted templates not listed unless archived view)
- PII masking: If templates include sensitive data, apply masking in logs
- Feature flags: Optionally gate endpoint behind flags for maintenance
- Bulk export possible via additional params or separate endpoint
- Ensure consistency with overall system: UTC times, referential integrity if templates link to entities"
227,notification,Create Template,Create template,api/notifications/templates,post,Admin,Implement POST /api/notifications/templates for Creating Templates,"## Overview

Implement the 'Create Template' API endpoint for the Deshio ERP system's notification category. Deshio is a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. Order domain handles states (pending→confirmed→fulfilled|cancelled), assignment, notes, promos, taxes, fraud. Fulfillment includes shipments, inter-store dispatch with tracking and scan events. Returns manage RMA, restock, refunds, exchanges. Payments handle intent→capture/void, refunds, synchronization. Accounting uses transaction headers and ledger entries for movements, reversals, reconciliation. Services cover service orders with lifecycle and profitability. Integrations include carriers, waybills, rates, tracking, webhooks, and notification templates (email/SMS). Security features user/role/permission, sessions, email verification, password reset, TOTP MFA, API keys. Observability includes audit events, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware encompasses TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC, permission checks, branch scope, tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures, cache headers. Reporting/analytics cover revenue, LTV/AOV, return rates, SLA, inventory aging, promo impact, etc. State machines ensure legal transitions for orders, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs support bulk import/export, search, attachments, reindex, backups, feature flags, maintenance. Data in UTC; soft deletes; EAV for attributes; polymorphic notes/attachments; strict referential links. Design supports deterministic admin assignment, safe reservation/consumption, consistent ledger posting.

This endpoint enables admins to create notification templates for email/SMS, integrating with the broader notification system.

## API Specifications

- **Category:** notification
- **Title:** Create Template
- **Description:** Create template
- **Route:** api/notifications/templates
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint handles POST requests to /api/notifications/templates
- [ ] Requires Admin authentication and authorization
- [ ] Validates input data for template creation (e.g., name, type: email/SMS, content, variables)
- [ ] Creates and persists a new template entity with audit logging
- [ ] Returns appropriate success response with created template details
- [ ] Handles errors per RFC7807 for validation failures, unauthorized access, etc.
- [ ] Integrates with state machines if applicable for template lifecycle
- [ ] Supports idempotency for duplicate requests
- [ ] Includes unit/integration tests covering happy path, edge cases, and errors
- [ ] Documentation updated for API reference

## Technical Requirements

- Implement in Laravel: Define route in api.php, create NotificationTemplateController with store method
- Use Laravel validation for request inputs (e.g., Request::validate([...]))
- Model: NotificationTemplate with fields like id, name, type, subject, body, variables, created_at, updated_at; soft deletes
- Database: Migration for templates table, ensuring referential integrity if linked to other entities
- Error handling: Return JSON errors with problem+json format for conflicts/invalids
- Middleware: Apply auth (Admin), RBAC permission check, input sanitizer, throttles, idempotency
- Observability: Log audit_event for creation, include request-id, cache headers
- Business logic: Ensure template creation supports polymorphic attachments if needed; validate against feature flags; post to queues if async processing required
- Integrations: Template usable in webhooks, email/SMS notifications; EAV for custom variables

## Authentication/Authorization Requirements

- Authentication: JWT/session/API key for Admin users
- Authorization: Admin role with specific permission (e.g., 'create-notification-template')
- Additional checks: Active user, email-verified, 2FA if enabled, branch scope if applicable
- RBAC: Enforce via middleware; deny access returns 403

## Expected Request/Response Format Considerations

- Request: JSON body with fields like {""name"": ""string"", ""type"": ""email|sms"", ""subject"": ""string"", ""body"": ""string"", ""variables"": [""var1"", ""var2""]}
- Response: 201 Created with JSON {""id"": int, ""name"": ""string"", ..., ""created_at"": ""utc-datetime""}
- Errors: 400 Bad Request for validation (problem+json), 401 Unauthorized, 403 Forbidden, 429 Too Many Requests
- Content negotiation: Versioned API, JSON only, ETag for caching if applicable
- Data in UTC; PII masking if template includes sensitive placeholders

## Relevant Business Logic

- Templates integrate with notification system for orders, shipments, payments, etc. (e.g., order confirmation emails)
- Support for promotions, custom attributes via variables
- Ensure creation doesn't conflict with existing templates (unique name per type?)
- Transactional: Rollback on failure to maintain ledger/audit consistency
- Soft delete support; no hard deletes for compliance
- Potential hooks: Trigger reindex if templates affect search/autosuggest"
228,notification,Send Test,Send test notification,api/notifications/test,post,Admin,Implement Send Test Notification API Endpoint,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue covers the implementation of the 'Send Test' notification API endpoint. This endpoint allows admins to send a test notification, useful for verifying notification configurations, templates (email/SMS), and delivery mechanisms within the integrations and services domains. Core entities like users, roles, and permissions ensure secure access, while observability features such as audit events and logs will track usage. The system uses state machines for transitions, RFC7807 problem+json for errors, UTC storage, soft deletes, and middleware for security (TLS/HSTS, CORS, auth via JWT/session/API key, RBAC, etc.).

## API Specifications

- **Category:** notification
- **Title:** Send Test
- **Description:** Send test notification
- **Route:** api/notifications/test
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint responds to POST requests at api/notifications/test
- [ ] Requires Admin authentication and authorization via RBAC (user/role/permission checks)
- [ ] Validates input parameters for notification details (e.g., recipient, type: email/SMS, template ID)
- [ ] Sends a test notification using the notification service, integrating with templates and providers
- [ ] Logs the event in audit_event and observability logs with request-id
- [ ] Returns success response with notification ID or status on successful send
- [ ] Handles errors (e.g., invalid template, delivery failure) with RFC7807 problem+json format
- [ ] Includes unit/integration tests covering happy path, validation errors, auth failures, and edge cases
- [ ] Applies middleware: auth, active user, email-verified, 2FA, RBAC, throttles, idempotency, input sanitizer
- [ ] Ensures PII masking in logs for recipient data
- [ ] Supports bulk or single test sends if applicable to business logic

## Technical Requirements

- Implement in Laravel: Define route in api.php, create NotificationController with testSend method
- Use Request validation (FormRequest class) for inputs like recipient_email, notification_type, template_id, optional message overrides
- Integrate with notification service for dispatching (e.g., via queues for email/SMS, webhooks if needed)
- Handle stock/financial irrelevance here, but ensure ledger posting if notification triggers any (unlikely for test)
- Add ETag/caching headers if response is cacheable (probably not for POST)
- Ensure soft deletes and referential integrity not directly applicable, but follow ERD norms
- Write tests: PHPUnit for controller, feature tests for full flow, mock notification providers
- Document in OpenAPI/Swagger if part of API spec
- Consider feature flags for enabling/disabling test sends

## Authentication/Authorization Requirements

- Authentication: JWT, session, or API key
- Authorization: Admin role/permission required (e.g., 'notifications.test' permission via ability table)
- Middleware chain: RequestId, JSON limits, versioned content-negotiation, locale/tz, auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope (if applicable), throttles, idempotency
- Security: Provider webhook signatures + replay defense if test involves external integrations; upload mime guard N/A

## Expected Request/Response Format Considerations

- **Request:** JSON body, e.g., {""recipient"": ""admin@example.com"", ""type"": ""email"", ""template_id"": 1, ""subject"": ""Test"", ""body"": ""Test message""}
- **Response (Success - 201/200):** {""success"": true, ""notification_id"": ""uuid"", ""status"": ""sent""}
- **Response (Error - 4xx/5xx):** RFC7807 problem+json, e.g., {""type"": ""https://example.com/probs/validation"", ""title"": ""Invalid Input"", ""status"": 422, ""detail"": ""Recipient email invalid""}
- Content negotiation: JSON only, versioned (e.g., /v1/)
- Idempotency: Use key in header/body to prevent duplicate sends

## Relevant Business Logic

- Test notifications verify setups for email/SMS templates, carriers, and webhooks in integrations
- Ties into services domain: service/service_order notifications if extended, but focus on core send
- No state machine transitions needed, but ensure legality via permissions
- Supports reporting/analytics indirectly (e.g., track test sends in activity logs for SLA/dispatch performance)
- Domain guards: Optional for promo/override if test involves them, but minimal for pure notification test
- Ensures deterministic behavior: Safe for admin testing without affecting live orders/inventory/payments
- Polymorphic attachments/notes possible if test includes media
- Aligns with overall design: Deterministic assignment, consistent ledger (if any financial tie-in), safe reservations N/A here"
229,webhook,List Webhooks,Paginated webhooks,api/webhooks,get,Admin,Implement GET /api/webhooks - List Paginated Webhooks,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs over a normalized ERD, this issue covers implementing the 'List Webhooks' endpoint. Deshio manages core entities such as products/categories/vendors with attributes (fields/features), media (product_images), barcodes, pricing (price_overrides), and promotions; stores/branches; customers with tags/blacklists.

Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to stores, notes/attachments, promotions, taxes, and fraud flags.

Fulfillment handles shipments (shipment/shipment_item) and inter-store dispatches (dispatch + tracking, scan events, POD) with transactional stock movements. Returns manage RMAs (return/return_item), receiving/restocking/scrap, refunds, and exchanges (exchange_order).

Payments involve intent→payment capture/void; refund lifecycles; and order.payment_status synchronization. Accounting uses transaction headers + ledger_entry lines for all movements, reversals, and reconciliation/export.

Services include service/service_order with lifecycles and profitability. Integrations cover carriers & accounts, waybills/rates/tracking; webhooks with deliveries; and notification templates (email/SMS).

Security & identity: users/roles/permissions with abilities (role↔perm) and user_roles (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_events, logs, request-ids, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint provides a paginated list of webhooks, fitting into the integrations layer for webhook deliveries and notifications.

## API Specifications

- **Category:** webhook
- **Title:** List Webhooks
- **Description:** Paginated webhooks
- **Route:** api/webhooks
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint returns a paginated list of webhooks with standard pagination metadata (e.g., current_page, last_page, per_page, total)
- [ ] Supports query parameters for pagination (page, per_page) and optional filters (e.g., status, type if applicable)
- [ ] Returns 200 OK with JSON response for successful requests
- [ ] Handles unauthorized access with 401 Unauthorized
- [ ] Handles insufficient permissions with 403 Forbidden
- [ ] Includes proper rate limiting and throttling
- [ ] Integrates with middleware stack: auth, RBAC, request-id, etc.
- [ ] Logs audit events for access
- [ ] Unit and integration tests cover happy path, edge cases, and errors
- [ ] Documentation updated with OpenAPI/Swagger specs
- [ ] Response includes relevant webhook fields (e.g., id, url, events, status, created_at)

## Technical Requirements

- Implement in Laravel: Define route in api.php, create WebhookController with index method
- Use Eloquent for querying webhooks table/model, with pagination via LengthAwarePaginator or simplePaginate
- Apply scopes/filters based on admin authentication and branch scope if applicable
- Input validation: Validate query params (page as integer >0, per_page 1-100)
- Error handling: Use RFC7807 problem+json for validation errors or conflicts; try-catch for database issues
- Optimize queries with indexing on webhook fields like status, created_at
- Ensure soft deletes are respected if webhooks support archival
- Integrate with state machines if webhook status transitions are managed
- Add caching/etag support via middleware
- Queue any background tasks if listing triggers notifications

## Authentication/Authorization Requirements

- Requires Admin authentication: JWT, session, or API key
- Enforce RBAC: User must have 'view_webhooks' permission via role/permission checks
- Middleware chain: auth → active user → email-verified → 2FA (if enabled) → RBAC & permission checks → branch scope
- For admin-only, ensure no tenancy isolation unless optional tenancy is active
- Reject inactive/suspended users or unverified emails

## Expected Request/Response Format Considerations

- **Request:** GET /api/webhooks?page=1&per_page=15&status=active (query params optional)
- **Response (200 OK):** JSON object with 'data' array of webhook objects, each including id, name/url, subscribed_events array, status (active/inactive), secret (masked), created_at, updated_at; plus pagination info: current_page, data (array), first_page_url, from, last_page, last_page_url, links (array), next_page_url, path, per_page, prev_page_url, to, total
- **Error Responses:** 400 Bad Request for invalid params (problem+json with type, title, detail, instance); 401 for auth failure; 403 for permission denial; 429 for throttling
- Use content-negotiation for JSON; versioned API (e.g., /api/v1/webhooks)
- Timestamps in UTC ISO format; PII masking if any sensitive data in webhooks

## Relevant Business Logic

- Webhooks are part of integrations for event deliveries (e.g., order updates, shipment tracking, payments)
- Listing should respect idempotency and replay defense if webhooks involve signatures
- Paginated to handle large volumes efficiently, aligning with reporting/analytics needs
- Ensure consistency with notification templates (email/SMS) and carrier integrations
- On list access, post audit_event for compliance/observability
- If webhooks tie into state machines (e.g., delivery confirmations), include status transitions in response
- Support bulk operations context: This list can feed into export/reindex or maintenance tasks"
230,webhook,Create Webhook,Create webhook,api/webhooks,post,Admin,Implement Create Webhook API Endpoint (POST /api/webhooks),"## Overview

Deshio is a Laravel-based ERP system for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. Order domain handles states (pending→confirmed→fulfilled|cancelled), assignments, notes/attachments, promos, taxes, fraud flags. Fulfillment involves shipments, inter-store dispatches with tracking and POD, transactional stock movements. Returns manage RMAs, restock/scrap, refunds, exchanges. Payments include intents, captures/voids, refunds, synchronization. Accounting tracks transaction headers, ledger entries, reversals, reconciliation/export. Services handle service orders with lifecycle and profitability. Integrations cover carriers/accounts, waybills/rates/tracking, webhooks with deliveries, notification templates (email/SMS). Security/identity includes user/role/permission with abilities, sessions, email verification, password reset, TOTP MFA, API keys. Observability/compliance features audit events, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC/permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines ensure legal transitions for orders, items, dispatches, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links. Design enables deterministic admin assignment, safe reservation/consumption, consistent ledger posting.

This issue implements the 'Create Webhook' API endpoint, which allows admins to create webhooks for integrations, particularly for deliveries and notifications, enabling event-driven communication with external systems.

## API Specifications

- **Category:** webhook
- **Title:** Create Webhook
- **Description:** Create webhook
- **Route:** api/webhooks
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST /api/webhooks endpoint to create a new webhook record
- [ ] Validate incoming request data for required fields (e.g., URL, events, secret if applicable)
- [ ] Ensure webhook creation triggers appropriate audit events and logs
- [ ] Handle errors per RFC7807 problem+json for validation failures or conflicts
- [ ] Verify soft delete and UTC storage compliance
- [ ] Integrate with RBAC for admin-only access
- [ ] Test webhook creation in context of deliveries and notifications
- [ ] Add unit/integration tests covering success, validation errors, unauthorized access
- [ ] Document the endpoint in API specs with request/response examples
- [ ] Ensure compatibility with middleware stack (auth, throttling, idempotency)

## Technical Requirements

- Use Laravel controller (e.g., WebhookController@store) and define route in api.php
- Implement input validation using Form Requests or Validator facade (e.g., required URL, valid events array from allowed list like 'delivery.created', 'order.fulfilled')
- Store webhook in database with fields like id, url, events (JSON), secret (hashed), active status, created_at/updated_at; link to user/tenant if applicable
- Apply middleware: auth (Admin), RBAC permission check (e.g., 'webhooks.create'), branch scope if multi-tenant, input sanitizer
- Generate API key or secret for webhook verification; support signature/replay defense for incoming webhooks
- On creation, optionally verify URL reachability or queue initial test event
- Proper error handling: 201 Created on success with webhook resource; 422 Unprocessable Entity for validation; 403 Forbidden for auth; 409 Conflict if duplicate
- Response: JSON with webhook details, ETag for caching, request-id in headers

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have 'webhooks.create' permission via role/ability
- Additional checks: Active user, email-verified, 2FA if enabled
- Scope to branch/tenant if configured; prevent cross-tenant creation

## Expected Request/Response Format Considerations

- **Request:** JSON body, e.g., {""url"": ""https://example.com/webhook"", ""events"": [""delivery.created"", ""order.fulfilled""], ""active"": true, ""secret"": ""optional-provided""}
- Content-Type: application/json; versioned via Accept header (e.g., application/vnd.deshio.v1+json)
- Validation: URL must be HTTPS, events from whitelist, sanitize inputs
- **Response:** 201 Created, JSON: {""id"": 1, ""url"": ""https://..."", ""events"": [...], ""active"": true, ""created_at"": ""UTC ISO""}; include links for self/edit/delete
- Errors: RFC7807, e.g., {""type"": ""https://.../validation"", ""title"": ""Invalid URL"", ""detail"": ""..."", ""status"": 422}
- Headers: X-Request-Id, Cache-Control, ETag

## Relevant Business Logic

- Webhooks enable integrations for real-time notifications on events like deliveries, order updates
- Creation should not immediately trigger events; subscriptions activate on successful creation
- Integrate with notification templates for webhook payloads (e.g., email/SMS fallback)
- Ensure idempotency: Use key (e.g., client-generated) to prevent duplicate creations
- State machine not directly applicable, but ensure creation doesn't conflict with existing subscriptions
- Post-creation, ledger/audit: Log webhook creation as audit_event; no financial impact
- For deliveries: Webhooks can subscribe to shipment/dispatch events with tracking/POD data
- Security: Hash secrets, validate signatures on receipt; PII masking in payloads if sensitive data sent"
231,webhook,Get Webhook,Get by id,api/webhooks/{id},get,Admin,Implement GET /api/webhooks/{id} for Admin Authentication,"## Context

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.
Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

## Overview

This issue covers the implementation of the 'Get Webhook' API endpoint in the Deshio ERP system. This endpoint allows admin users to retrieve a specific webhook by its ID. Webhooks are part of the integrations module, supporting deliveries and other event-driven notifications (e.g., for carriers, tracking, and external systems). The implementation must align with the overall ERP architecture, including security middleware, RBAC, and observability features.

## API Specifications

- **Category:** webhook
- **Title:** Get Webhook
- **Description:** Get by id
- **Route:** api/webhooks/{id}
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint returns the webhook details for a valid ID when authenticated as admin
- [ ] Returns 404 if webhook ID does not exist
- [ ] Enforces admin-only access; non-admin requests return 403
- [ ] Includes proper error handling with RFC7807 problem+json for conflicts or invalid states
- [ ] Supports soft deletes; does not return deleted webhooks
- [ ] Integrates with middleware stack (e.g., auth, RBAC, request-id, throttling)
- [ ] Logs audit events for access
- [ ] Unit and integration tests cover success, failure, auth, and edge cases (e.g., invalid ID)
- [ ] Documentation updated in API specs (e.g., OpenAPI/Swagger)
- [ ] Performance: Handles requests efficiently with caching/etag if applicable

## Technical Requirements

- Use Laravel framework: Define route in api.php, create or extend WebhookController with a show() method
- Implement resource controller pattern for consistency with other endpoints
- Use Eloquent model for webhook entity, assuming webhook table with fields like id, url, event_type, secret, status, etc. (align with integrations context)
- Apply input validation: Ensure {id} is a valid UUID or integer via route model binding
- Error handling: Use Laravel exceptions, return JSON errors with problem+json format for state conflicts
- Database: Query in UTC, respect soft deletes with withTrashed() if needed, but default to non-deleted
- Middleware: Apply full stack including auth (JWT/API key), RBAC (admin permission check), branch scope if relevant, idempotency if applicable
- Response: Return JSON with webhook data, including related entities if needed (e.g., deliveries, signatures)
- Testing: PHPUnit tests for controller, including mocked auth and DB
- Integration: Ensure compatibility with webhook-related features like provider signatures, replay defense, and deliveries

## Authentication/Authorization Requirements

- Requires admin authentication via JWT, session, or API key
- RBAC check: User must have 'webhook.view' permission or equivalent admin role
- Additional guards: Active user, email-verified, 2FA if enabled
- For webhooks context: Ensure secure handling to prevent exposure of secrets (e.g., mask in response if PII)

## Expected Request/Response Format Considerations

- **Request:** GET /api/webhooks/{id} (path param {id} as string/integer; no body)
- **Response (200 OK):** JSON object with webhook details, e.g., {""id"": ""uuid"", ""url"": ""https://example.com"", ""event_type"": ""delivery"", ""status"": ""active"", ""created_at"": ""UTC timestamp""} – include relevant fields from ERD
- **Headers:** Accept: application/json; ETag for caching; X-Request-Id
- **Errors:** 401 Unauthorized, 403 Forbidden, 404 Not Found, 422 Unprocessable (if validation fails), with problem+json body
- Versioning: Use content-negotiation for API version (e.g., /v1/webhooks/{id})
- Locale/TZ: Support via headers, but data in UTC

## Relevant Business Logic

- Webhooks handle event deliveries (e.g., order updates, shipments, payments) to external systems
- Retrieval should not trigger delivery; it's read-only
- Respect state machines if webhook has lifecycle states (e.g., active/inactive)
- Security: Do not expose sensitive data like secrets in response; use masking for PII/compliance
- Auditing: Log access to audit_event table with request-id
- Integrations tie-in: Webhook may relate to carriers/accounts, tracking, or notification templates
- Conflicts: If webhook is in invalid state (e.g., deleted), return appropriate error
- Overall: Ensure deterministic behavior, aligning with ERP's focus on safe reservations, ledger posting, and transactional integrity"
232,webhook,Update Webhook,Update by id,api/webhooks/{id},put,Admin,Implement PUT /api/webhooks/{id} for Updating Webhooks,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue covers implementing the 'Update Webhook' endpoint. This endpoint allows administrators to update an existing webhook by its ID, supporting integrations such as carriers & accounts, waybills/rates/tracking, and webhooks with deliveries. Core entities include user/role/permission with RBAC, and observability features like audit_event, log, request-id, PII masking. The system uses state machines for transitions, conflicts return RFC7807 problem+json, data in UTC, soft deletes, EAV for attributes, and middleware including TLS/HSTS, CORS, auth (JWT/session/API key), RBAC & permission checks, throttles, idempotency, input sanitizer, and cache headers. Inventory is batch-centric, orders have states (pending→confirmed→fulfilled|cancelled), fulfillment involves shipments and dispatches, returns use RMA, payments have intent→capture lifecycles, accounting uses ledger entries, services have profitability tracking, security includes TOTP MFA, and reporting covers revenue, LTV/AOV, etc. APIs support bulk import/export, search, attachments, and maintenance.

## API Specifications

- **Category:** webhook
- **Title:** Update Webhook
- **Description:** Update by id
- **Route:** api/webhooks/{id}
- **HTTP Method:** put
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the PUT endpoint to update a webhook by ID
- [ ] Ensure the endpoint is only accessible to authenticated Admin users with appropriate RBAC permissions
- [ ] Validate the request input, including the webhook ID and update fields (e.g., URL, events, secret, status)
- [ ] Handle successful updates by returning the updated webhook resource or 204 No Content
- [ ] Implement error handling for invalid ID (404), unauthorized access (403), validation failures (422 with RFC7807 problem+json), and other conflicts
- [ ] Log audit events for webhook updates, including request-id and PII masking if applicable
- [ ] Ensure idempotency for repeated requests and apply middleware like throttles, input sanitizer, and cache headers
- [ ] Write unit tests for controller logic, validation, and authorization
- [ ] Write integration tests for end-to-end flow, including database updates and response formats
- [ ] Verify soft deletes and referential integrity are respected
- [ ] Test with versioned content-negotiation, locale/tz, and JSON limits

## Technical Requirements

- Define the route in routes/api.php with Laravel's Route::put('webhooks/{id}', [WebhookController::class, 'update'])
- Create or update WebhookController with an update method using dependency injection for the Webhook model
- Use Eloquent for updating the webhook record: $webhook = Webhook::findOrFail($id); $webhook->update($validatedData)
- Implement input validation via FormRequest class, covering fields like url, events (array of webhook events e.g., order.confirmed, shipment.created), secret, active status, and any EAV attributes
- Apply global middleware stack: RequestId, auth (JWT/session/API key), active user, RBAC & permission checks (e.g., 'webhook.update' permission), branch scope if applicable, throttles, idempotency keys, input sanitizer
- For business logic, ensure updates trigger any necessary state machine transitions if webhooks have states; post to accounting ledgers if financial (unlikely); support polymorphic attachments if webhooks have notes
- Handle file uploads if webhook configs include media (e.g., via upload mime guard)
- Use queues for any async processing post-update, like notifying subscribers
- Ensure deterministic behavior aligning with Deshio's design for safe operations and consistent ledger posting on events
- Follow observability: emit metrics, health checks, and etag caching for responses

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have a role with 'webhook.update' permission via ability (role↔perm) and user_role junction
- Include checks for email-verified, active user, and optional 2FA/TOTP MFA
- Apply branch scope if webhooks are scoped to stores/branches
- Use domain guards for webhook-related actions to prevent invalid updates

## Expected Request/Response Format Considerations

- **Request:** JSON body with partial updates (e.g., {""url"": ""https://example.com/webhook"", ""events"": [""order.confirmed""], ""secret"": ""new-secret"", ""active"": true}); use PATCH-like semantics but via PUT for full resource update
- **Headers:** Accept: application/vnd.deshio.v1+json (versioned), Content-Type: application/json, X-Idempotency-Key (optional), Authorization: Bearer <token>
- **Response (200 OK):** JSON of updated webhook {""id"": 1, ""url"": ""https://example.com/webhook"", ""events"": [""order.confirmed""], ...} with ETag header
- **Errors:** 400/422 with RFC7807 problem+json (e.g., {""type"": ""https://example.com/probs/validation"", ""title"": ""Invalid Data"", ""detail"": ""URL is required""}); 401 Unauthorized, 403 Forbidden, 404 Not Found, 429 Too Many Requests
- Support bulk considerations if extending to multiple IDs, but focus on single ID; use search/autosuggest if needed for related entities

## Relevant Business Logic

- Webhooks are part of integrations for deliveries, notifications (email/SMS templates), and carrier tracking; updates should validate event types against system domains (e.g., order, shipment, payment states)
- Ensure updates do not break active subscriptions; trigger re-verification or replay defense if secret changes
- Align with state machines: If webhook has lifecycle states (e.g., active/inactive), enforce legal transitions
- Post-update, sync with audit_event for compliance, and potentially queue webhook deliveries for testing
- Consider fraud flags or blacklist if webhook targets customer data; apply PII masking in logs
- For omni-channel, ensure webhook scopes match store/branch assignments and inventory reservations if logistics-related"
233,webhook,Delete Webhook,Delete by id,api/webhooks/{id},delete,Admin,Implement DELETE /api/webhooks/{id} for Admin Authentication,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the 'Delete Webhook' API endpoint. This endpoint allows admins to delete a webhook by its ID, supporting integrations with carriers & accounts, waybills/rates/tracking, and webhooks with deliveries.

Core entities include: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint falls under the webhook category and handles deletion by ID, ensuring proper audit logging and compliance with RBAC.

## API Specifications

- **Category:** webhook
- **Title:** Delete Webhook
- **Description:** Delete by id
- **Route:** api/webhooks/{id}
- **HTTP Method:** delete
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the DELETE endpoint to remove a webhook by its ID
- [ ] Ensure only authenticated admins with appropriate RBAC permissions can access the endpoint
- [ ] Validate that the webhook ID exists before deletion; return 404 if not found
- [ ] Handle soft deletes if applicable, or permanent deletion as per business rules
- [ ] Log the deletion event in audit_event for compliance and observability
- [ ] Return appropriate HTTP status codes: 204 on success, 401/403 for auth issues, 404 for not found, 422 for validation errors
- [ ] Integrate with middleware stack including auth, RBAC checks, request ID, and error handling per RFC7807 for problems
- [ ] Write unit and integration tests covering success, auth failure, not found, and invalid ID scenarios
- [ ] Ensure no cascading deletes affect related entities unless specified; update any dependent integrations if needed
- [ ] Verify compatibility with webhook security features like provider signatures and replay defense

## Technical Requirements

- Use Laravel framework: Create or update a WebhookController with a destroy method
- Define the route in api.php: Route::delete('/webhooks/{id}', [WebhookController::class, 'destroy'])->middleware('auth:admin');
- Implement input validation: Ensure {id} is a valid UUID or integer; use FormRequest or manual validation
- Authorization: Use Laravel's Gate or Policy for 'delete' permission on webhook model, tied to admin role
- Business logic: Retrieve webhook by ID, check ownership/scope (e.g., branch scope if applicable), perform delete, trigger any post-delete events like notifications or ledger entries if relevant
- Error handling: Use try-catch for exceptions, return JSON errors in problem+json format for conflicts or invalid states
- Database: Leverage Eloquent model for webhooks with soft deletes; ensure UTC storage and referential integrity
- Integrations: Consider impacts on notification templates, carrier integrations, and webhook deliveries; potentially invalidate caches/etags
- Testing: Include PHPUnit tests for controller, policy, and middleware; mock auth and database
- Documentation: Update API docs with endpoint details, including expected behaviors and edge cases
- Observability: Add metrics for deletion success/failure rates; ensure request-id propagation and PII masking if any sensitive data is involved
- Security: Enforce throttles, idempotency if applicable, and domain guards for webhook-related operations"
234,webhook,Retry Webhook,Retry failed delivery,api/webhooks/{id}/retry,post,Admin,Implement Retry Webhook API Endpoint for Failed Deliveries,"## Overview

Deshio is a Laravel-based ERP system for retail/omni-channel operations, featuring approximately 290 REST APIs built over a normalized ERD that covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes (fields/features), media (product_images), barcodes, pricing (price_overrides), and promotions; stores/branches; customers with tags/blacklists. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers.

The order domain handles order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to stores, notes/attachments, promotions, taxes, and fraud flags. Fulfillment involves shipments (shipment/shipment_item) and inter-store dispatches (dispatch + tracking, scan events, POD) with transactional stock movements. Returns manage RMAs (return/return_item), receive/restock/scrap, refunds, and exchanges (exchange_order). Payments cover intent→payment capture/void lifecycles, refunds, and order.payment_status synchronization.

Accounting uses transaction headers + ledger_entry lines for all movements, including reversals and reconciliation/export. Services include service/service_order with lifecycles and profitability. Integrations handle carriers & accounts, waybills/rates/tracking, and webhooks with deliveries; notification templates for email/SMS.

Security & identity features user/role/permission with abilities (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance include audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware encompasses TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines enforce legal transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across junctions. The design ensures deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint focuses on the webhook category, allowing admins to retry failed webhook deliveries, ensuring reliable integration with external services like carriers or notifications.

## API Specifications

- **Category:** webhook
- **Title:** Retry Webhook
- **Description:** Retry failed delivery
- **Route:** api/webhooks/{id}/retry
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint successfully retries a failed webhook delivery by resending the payload to the original endpoint
- [ ] Validates the webhook ID exists and is in a failed state before retrying
- [ ] Updates the webhook status to 'retrying' during processing and 'succeeded' or 'failed' post-retry
- [ ] Handles idempotency to prevent duplicate deliveries on retries
- [ ] Logs audit events for retry attempts, including success/failure details
- [ ] Returns appropriate HTTP status codes: 200 for success, 404 for invalid ID, 403 for unauthorized access
- [ ] Integrates with existing middleware stack, including auth, RBAC, request-id, and error handling per RFC7807
- [ ] Includes unit and integration tests covering happy path, edge cases (e.g., network failure during retry), and security scenarios
- [ ] Documentation updated in API specs with request/response examples and error cases
- [ ] Performance tested for queue integration if retries involve async processing

## Technical Requirements

- Implement in Laravel using a dedicated controller (e.g., WebhookController@retry) and register the route in api.php with proper versioning
- Use Eloquent models for webhook entities, assuming a webhooks table with fields like id, endpoint_url, payload, status (pending/delivered/failed/retrying), retry_count, last_attempt_at, created_at/updated_at
- Integrate with queues for async retry processing to avoid blocking the API response
- Apply input validation using Laravel's FormRequest or Validator for the {id} parameter (UUID or integer)
- Handle errors with try-catch, logging via Laravel's Log facade, and return JSON responses with problem+json for failures
- Ensure soft deletes and UTC handling for timestamps
- Tie into observability: generate request-id, audit_event for actions, and metrics for retry success rates
- Consider polymorphic relations if webhooks attach to entities like orders or shipments

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have a role with permission to manage webhooks (e.g., 'webhook.retry')
- Apply middleware chain: auth, active user, email-verified, 2FA (if enabled), RBAC & permission checks, branch scope (if applicable), throttles, idempotency
- Reject unauthorized requests with 403 Forbidden and detailed error message

## Expected Request/Response Format Considerations

- **Request:** POST to /api/webhooks/{id}/retry; no body required, but {id} must be validated as existing failed webhook
- **Response (Success - 200):** JSON { ""message"": ""Webhook retry initiated"", ""webhook_id"": ""{id}"", ""status"": ""retrying"" }
- **Response (Not Found - 404):** RFC7807 problem+json { ""type"": ""https://example.com/probs/webhook-not-found"", ""title"": ""Webhook not found"", ""status"": 404, ""detail"": ""The specified webhook ID does not exist or is not failed"" }
- **Response (Unauthorized - 403):** RFC7807 problem+json { ""type"": ""https://example.com/probs/unauthorized"", ""title"": ""Insufficient permissions"", ""status"": 403 }
- Use JSON API content-type, versioned via header or path, with ETag for caching if applicable; sanitize inputs to prevent injection

## Relevant Business Logic

- Webhooks are critical for integrations (e.g., carrier tracking updates, payment notifications, order status deliveries)
- Retries should respect replay defense and signatures to avoid invalid resends
- Limit retry attempts (e.g., max 3) to prevent infinite loops; escalate to manual review if exceeded
- On retry success, update related entities (e.g., sync order status if webhook was for fulfillment)
- Ensure transactional integrity: if retry fails, rollback any partial updates and post to ledger if financial impact
- Align with state machines: only allow retry if webhook state permits (failed); transition states deterministically
- Integrate with notifications: alert admins on repeated failures via email/SMS templates"
235,webhook,Deliveries,List webhook deliveries,api/webhooks/{id}/deliveries,get,Admin,Implement API: List Webhook Deliveries (GET /api/webhooks/{id}/deliveries),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the 'Deliveries' endpoint in the webhook category. This endpoint lists webhook deliveries for a specific webhook ID.

Deshio core entities include: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability.

Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint supports webhook integrations by listing delivery attempts and statuses for a given webhook.

## API Specifications

- **Category:** webhook
- **Title:** Deliveries
- **Description:** List webhook deliveries
- **Route:** api/webhooks/{id}/deliveries
- **Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET endpoint to list webhook deliveries for the specified webhook ID
- [ ] Ensure the endpoint requires Admin authentication and proper RBAC checks
- [ ] Support pagination, filtering, and sorting for delivery listings (e.g., by status, timestamp)
- [ ] Handle errors with RFC7807 problem+json format for invalid webhook ID or unauthorized access
- [ ] Include audit logging for endpoint access via audit_event
- [ ] Add unit and integration tests covering success, error, and edge cases (e.g., non-existent webhook ID)
- [ ] Verify soft deletes are respected in listings
- [ ] Ensure response includes relevant fields like delivery ID, status, payload summary, timestamp, and retry attempts
- [ ] Test middleware integration: auth, RBAC, request-id, throttles, idempotency

## Technical Requirements

- Use Laravel controller (e.g., WebhookController) and define route in api.php with {id} parameter binding
- Implement query builder or Eloquent for fetching deliveries associated with the webhook (e.g., via webhook_deliveries table with fields: id, webhook_id, status, response_code, payload_hash, delivered_at, retries, error_message)
- Apply input validation for {id} (UUID or integer) and any query params (e.g., ?page=1&per_page=20&status=success&from=2023-01-01)
- Use Laravel's pagination for large result sets
- Integrate with observability: add request-id to logs, PII masking if payloads contain sensitive data
- Handle caching/etag for repeated requests if applicable
- Ensure UTC timestamps in responses
- Proper error handling: 404 for non-existent webhook, 403 for unauthorized, 422 for invalid params
- Follow Deshio's state machine patterns if deliveries have lifecycle states

## Authentication/Authorization Requirements

- Requires Admin role via JWT/session/API key
- Enforce RBAC: user must have permission to view webhooks and deliveries (e.g., 'webhook.view')
- Apply branch scope if webhooks are branch-specific
- Include active user, email-verified, and 2FA checks via middleware
- Use domain guards for webhook access

## Expected Request/Response Format Considerations

- **Request:** GET /api/webhooks/{id}/deliveries with optional query params for pagination (page, per_page), filtering (status: pending|success|failed, from/to dates), and sorting (sort_by: delivered_at, direction: desc)
- **Response:** JSON array of delivery objects, e.g., {
  ""data"": [
    {
      ""id"": ""uuid"",
      ""webhook_id"": ""uuid"",
      ""status"": ""success"",
      ""response_code"": 200,
      ""payload_hash"": ""sha256"",
      ""delivered_at"": ""2023-10-01T12:00:00Z"",
      ""retries"": 3,
      ""error_message"": null
    }
  ],
  ""meta"": { ""current_page"": 1, ""last_page"": 1, ... }
}
- Use versioned content-negotiation (e.g., Accept: application/vnd.deshio.v1+json)
- Include cache headers and ETag for conditional requests
- For errors: RFC7807 format, e.g., { ""type"": ""https://problems.deshio.com/invalid-webhook"", ""title"": ""Invalid Webhook ID"", ""status"": 404 }

## Relevant Business Logic

- Webhook deliveries track attempts to send events (e.g., order updates, payment confirmations) to external integrations
- Support retry logic for failed deliveries (e.g., exponential backoff up to max retries)
- Integrate with notification templates for delivery failure alerts (email/SMS)
- Ensure transactional consistency: deliveries link to audit_event and log for observability
- Respect idempotency for replay defense in webhook processing
- Align with broader integrations: carriers, waybills, tracking; prevent PII exposure in delivery logs via masking
- State transitions for deliveries (e.g., pending → sent → success|failed) may use state machines, rejecting invalid transitions with problem+json"
236,integration,List Carriers,Available shipping carriers,api/integrations/carriers,get,Admin,Implement GET /api/integrations/carriers - List Carriers,"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.
Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint provides a list of available shipping carriers for integrations, supporting waybills, rates, and tracking in the fulfillment domain.

## API Specifications

- **Category:** integration
- **Title:** List Carriers
- **Description:** Available shipping carriers
- **Route:** api/integrations/carriers
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET endpoint to retrieve a list of available shipping carriers
- [ ] Ensure only authenticated admins can access the endpoint
- [ ] Return a JSON array of carrier objects with relevant details (e.g., id, name, accounts)
- [ ] Handle empty list gracefully (e.g., empty array response)
- [ ] Include proper HTTP status codes (200 for success, 401/403 for auth errors)
- [ ] Add unit and integration tests for the endpoint
- [ ] Document the response schema in API docs
- [ ] Ensure compliance with middleware (e.g., RBAC checks, request ID)
- [ ] Use RFC7807 problem+json for any errors

## Technical Requirements

- Create a Laravel controller (e.g., CarrierController) with an index method
- Define the route in api.php or integrations routes group
- Use Eloquent or query builder to fetch carriers from the database (e.g., carriers table with accounts)
- Implement input validation if query params are added (e.g., pagination, filters); currently none specified
- Apply soft deletes filter if applicable
- Add caching/etag support via middleware
- Ensure data in UTC and proper serialization
- Integrate with observability: log requests, audit events for admin actions

## Authentication/Authorization Requirements

- Require JWT/session/API key authentication
- Enforce Admin role via RBAC & permission checks (e.g., 'view-carriers' permission)
- Apply active user, email-verified, and 2FA middleware
- Optional branch scope if carriers are branch-specific
- Return 401 Unauthorized or 403 Forbidden for insufficient permissions

## Expected Request/Response Format Considerations

- **Request:** No body; optional query params for filtering/pagination (e.g., ?page=1&per_page=20) if extended
- **Response:** 200 OK with JSON array:
  [
    {
      ""id"": 1,
      ""name"": ""Carrier Name"",
      ""description"": ""Optional desc"",
      ""accounts"": [...],
      ""active"": true
    }
  ]
- Include pagination metadata if implemented (e.g., links, total)
- Error responses: RFC7807 format, e.g., {""type"": ""https://example.com/errors/unauthorized"", ""title"": ""Unauthorized""}
- Headers: Cache-Control, ETag, Request-Id

## Relevant Business Logic

- Carriers support integrations for fulfillment: waybills/rates/tracking, linked to shipments and dispatches
- List should include configured/active carriers with associated accounts
- Ensure referential integrity with other entities (e.g., no dangling links)
- Align with state machines if carrier status affects fulfillment transitions
- Support for bulk operations or search if extended in future APIs"
237,integration,Connect Carrier,Connect shipping account,api/integrations/carriers,post,Admin,Implement Connect Carrier API Endpoint for Shipping Accounts,"## Overview

Deshio is a Laravel-based ERP system for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. Order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment covers shipments (shipment/shipment_item) and inter-store dispatch with tracking, scan events, POD, and transactional stock movements. Returns handle RMA (return/return_item), receive/restock/scrap, refunds, exchanges. Payments manage intent→payment capture/void, refund lifecycle, order.payment_status sync. Accounting includes transaction headers + ledger_entry lines, reversals, reconciliation/export. Services cover service/service_order lifecycle and profitability. Integrations include carriers & accounts, waybills/rates/tracking; webhooks, notification templates (email/SMS). Security & identity: user/role/permission with abilities, multi-role; sessions, email verification, password reset, TOTP MFA + backup codes, API keys. Observability: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines ensure legal transitions for orders, items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data in UTC; soft deletes; EAV for attributes; polymorphic notes/attachments; strict referential links. Design enables deterministic admin assignment, safe reservation/consumption, consistent ledger posting.

This issue is for implementing the 'Connect Carrier' API endpoint in the integration category, which allows connecting a shipping account to enable carrier integrations for waybills, rates, tracking, and related logistics features.

## API Specifications

- **Category:** integration
- **Title:** Connect Carrier
- **Description:** Connect shipping account
- **Route:** api/integrations/carriers
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST endpoint at api/integrations/carriers to connect a shipping carrier account
- [ ] Validate input data for carrier connection details (e.g., carrier type, credentials, account ID)
- [ ] Store carrier connection securely (e.g., encrypted credentials) and associate with the admin's scope
- [ ] Handle successful connection by creating/updating a carrier account record and enabling related features like waybills/rates/tracking
- [ ] Return appropriate success response with connection status and carrier details
- [ ] Implement error handling for invalid credentials, duplicate connections, or carrier-specific issues using RFC7807 problem+json
- [ ] Ensure endpoint respects middleware stack: auth (Admin JWT/session/API key), RBAC permissions for integrations, input sanitizer, throttles, idempotency
- [ ] Add comprehensive unit/integration tests covering happy path, validation errors, auth failures, and business rule violations
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger) with request/response examples
- [ ] Verify integration with existing carrier models and audit logging for connection events

## Technical Requirements

- Use Laravel framework: Define route in api.php, create CarrierController with connect method
- Implement input validation using Form Requests or Validator facade (e.g., required fields for carrier_name, api_key, account_id, carrier_type enum)
- Store data in carriers table (or integrations_carriers) with fields for type, credentials (encrypted via Laravel's encryption), status, linked_account
- Integrate with existing ERD: Link to user/branch scope, audit_event for connection actions
- Handle state: Use state machine if carrier connection has lifecycle (e.g., pending→active→suspended)
- Proper error handling: Throw ValidationException, or custom exceptions mapped to problem+json responses
- Observability: Log connection attempts with request-id, audit_event for compliance
- Security: Encrypt sensitive data (credentials), validate webhook signatures if applicable for carrier callbacks
- Performance: Consider caching for carrier config, etag for responses
- Testing: PHPUnit tests for controller, validation, DB interactions; feature tests for full flow

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC check: User must have role/permission for 'integrations.carriers.connect' or equivalent ability
- Enforce active user, email-verified, 2FA if enabled
- Branch scope: Limit to admin's accessible branches/stores
- Optional tenancy if multi-tenant setup

## Expected Request/Response Format Considerations

- **Request:** JSON body, e.g., {""carrier_type"": ""fedex"", ""account_id"": ""12345"", ""api_key"": ""secret"", ""api_secret"": ""secret2"", ""sandbox"": true}
- Validation: Carrier_type as enum (e.g., fedex, ups, dhl), required strings for credentials, boolean for sandbox
- **Response:** 201 Created on success, e.g., {""id"": 1, ""carrier_type"": ""fedex"", ""status"": ""active"", ""connected_at"": ""2023-01-01T00:00:00Z""}
- Errors: 400 Bad Request for validation, 401 Unauthorized, 403 Forbidden, 422 Unprocessable Entity with problem+json details
- Content negotiation: Versioned API (e.g., /v1/), JSON only, cache headers
- Idempotency: Support idempotency keys to prevent duplicate connections

## Relevant Business Logic

- Connecting a carrier enables logistics features: Generate waybills/rates, track shipments/dispatches, integrate with fulfillment (shipments, inter-store dispatch)
- Validate credentials against carrier API if possible (e.g., test connection endpoint)
- Handle multiple carriers per store/branch; prevent duplicates for same account/carrier_type
- On connection, update inventory/logistics availability; trigger webhooks/notifications if configured
- Ensure transactional integrity: Rollback on failure, post to audit ledger
- Comply with PII masking if account details include sensitive info; soft delete for disconnection
- Integrate with reporting: Track carrier usage in analytics (e.g., dispatch performance, SLA)"
238,integration,Disconnect Carrier,Disconnect carrier,api/integrations/carriers/{id},delete,Admin,Implement DELETE /api/integrations/carriers/{id} - Disconnect Carrier,"## Overview

Implement the API endpoint to disconnect a carrier integration in the Deshio ERP system. This endpoint allows administrators to remove the connection to a specific carrier, which is part of the integrations module handling carriers & accounts, waybills/rates/tracking. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, ledgers. Order domain includes states, assignment, notes, promos, taxes, fraud. Fulfillment covers shipments, inter-store dispatch with tracking. Returns handle RMA, restock, refunds, exchanges. Payments manage intents, captures, refunds. Accounting tracks transactions, ledgers, reversals. Services include service orders. Integrations encompass carriers, webhooks, notifications. Security features user/role/permission, sessions, MFA, API keys. Observability includes audits, logs, PII masking, metrics. Middleware enforces TLS, CORS, auth (JWT/session/API key), RBAC, throttles, etc. Reporting covers revenue, LTV, inventory aging, etc. State machines ensure legal transitions; conflicts return RFC7807 problem+json. APIs support bulk operations, search, attachments, etc. Data in UTC, soft deletes, EAV, polymorphic relations. Design supports deterministic assignments, safe reservations, consistent ledger posting.

## API Specifications

- **Category:** integration
- **Title:** Disconnect Carrier
- **Description:** Disconnect carrier
- **Route:** api/integrations/carriers/{id}
- **HTTP Method:** delete
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint returns 204 No Content on successful disconnection
- [ ] Endpoint returns 404 if carrier ID not found
- [ ] Endpoint returns 403 if user lacks admin permissions
- [ ] Carrier integration is fully disconnected, including any active accounts or tracking references
- [ ] Audit event is logged for the disconnection action
- [ ] Soft delete or removal handles any related data without breaking referential integrity
- [ ] Tests cover success, not found, unauthorized, and invalid ID scenarios
- [ ] Endpoint respects middleware: auth, RBAC, throttles, idempotency
- [ ] Response includes proper cache headers and request-id

## Technical Requirements

- Implement in Laravel: Add route to api.php, create or update CarrierController with destroy method
- Use Eloquent model for carriers with soft deletes
- Input validation: Ensure {id} is a valid UUID or integer via route model binding
- Handle business logic: Verify carrier exists, check for dependencies (e.g., active shipments), perform disconnection (e.g., revoke API keys, clear accounts), post ledger entries if financial impact, trigger state machine if applicable
- Error handling: Use RFC7807 problem+json for conflicts, validation errors, or domain guards (e.g., if carrier in use for active orders/dispatches)
- Integration with observability: Log audit_event, include request-id, mask PII if any
- Queues/caching: Invalidate any related caches/etags for carrier data
- Testing: Unit tests for controller logic, feature tests for full endpoint, integration tests with auth/RBAC

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC check: User must have 'admin' role or specific permission for carrier management
- Middleware chain: auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope (if applicable)
- Optional: Tenancy if multi-tenant setup

## Expected Request/Response Format Considerations

- **Request:** No body required; path param {id} for carrier ID (e.g., UUID)
- **Response:** 
  - Success: 204 No Content
  - Error: 4xx/5xx with JSON problem details (title, detail, type per RFC7807)
- Content negotiation: Versioned, JSON only, with etag/cache headers
- Idempotency: Support for safe retries if disconnection is partial

## Relevant Business Logic

- Disconnecting a carrier should prevent further integrations like waybills/rates/tracking or webhook deliveries
- Ensure no active shipments/dispatches are impacted; queue migrations or flag for manual handling if needed
- Update related entities: Clear carrier references in orders, shipments, or accounts
- Trigger notifications (email/SMS) if configured via templates
- Maintain consistency: Post reversals to ledgers if disconnection affects ongoing financial events
- Comply with security: Validate webhook signatures/replay defense before any pre-disconnect actions
- State machines: If carrier state transition needed, enforce legality; return problem+json on conflicts"
239,integration,Rate Shipment,Get shipping rates,api/integrations/carriers/{id}/rates,post,Employee,Implement POST /api/integrations/carriers/{id}/rates - Get Shipping Rates,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue covers the implementation of the 'Rate Shipment' API endpoint. Deshio handles core entities like products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flags. Fulfillment involves shipments/shipment_items and inter-store dispatch with tracking, scan events, POD, and transactional stock movements. Returns use RMA (return/return_item) for receive/restock/scrap, refunds, exchanges. Payments cover intent→payment capture/void, refund lifecycle, and order.payment_status sync. Accounting includes transaction headers + ledger_entry lines for movements, reversals, reconciliation/export. Services handle service/service_order with lifecycle and profitability. Integrations include carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with abilities, multi-role user_role; sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive transitions for orders, items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data in UTC; soft deletes; EAV for attributes; polymorphic notes/attachments; strict referential links. Design enables deterministic admin assignment, safe reservation/consumption, consistent ledger posting.

This endpoint, in the 'integration' category, allows getting shipping rates for a specific carrier, supporting fulfillment and logistics integrations with carriers & accounts for waybills/rates/tracking.

## API Specifications

- **Category:** integration
- **Title:** Rate Shipment
- **Description:** Get shipping rates
- **Route:** api/integrations/carriers/{id}/rates
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST endpoint to retrieve shipping rates from the specified carrier
- [ ] Validate input parameters for shipment details (e.g., origin, destination, weight, dimensions)
- [ ] Integrate with carrier APIs or services to fetch real-time rates
- [ ] Handle successful responses with rate options (e.g., service types, costs, transit times)
- [ ] Implement error handling for invalid carrier ID, unavailable rates, or integration failures using RFC7807 problem+json
- [ ] Ensure state machine compliance if rates tie into order/shipment transitions
- [ ] Add unit/integration tests covering happy path, edge cases, and errors
- [ ] Document request/response schemas in OpenAPI/Swagger
- [ ] Verify middleware application (auth, RBAC, throttles, etc.)
- [ ] Test for idempotency and caching where applicable

## Technical Requirements

- Use Laravel controller and define routes in api.php with versioning
- Implement input validation using Form Requests or Validator for required fields like from_address, to_address, package_weight, etc.
- Integrate with carrier provider (e.g., via SDK or HTTP calls) for rate quotes, ensuring secure handling of API keys/accounts
- Proper error handling with HTTP status codes (e.g., 200 OK, 400 Bad Request, 404 Not Found, 503 Service Unavailable)
- Log audit events for rate requests, especially if tied to orders/shipments
- Support bulk or multi-rate queries if business needs evolve
- Ensure transactional consistency if rates affect reservations or pricing overrides
- Use ETag/caching for repeated rate queries to optimize performance
- Align with observability: add metrics for rate fetch latency/SLA, request-id tracing

## Authentication/Authorization Requirements

- Require Employee authentication via JWT/session/API key
- Enforce RBAC: Employee must have permissions for carrier integrations (e.g., view_rates ability on role)
- Apply branch scope if rates are store-specific
- Include active user, email-verified, 2FA checks via middleware
- Optional tenancy isolation if multi-tenant setup

## Expected Request/Response Format Considerations

- **Request:** JSON body with shipment details, e.g., {""from"": {""address"": ""...""}, ""to"": {""address"": ""...""}, ""packages"": [{""weight"": 1.5, ""dimensions"": {...}}], ""services"": [""express"", ""standard""]}. Carrier {id} as path param (UUID/int referencing carriers table).
- **Response:** 200 OK with JSON array of rates, e.g., [{""service"": ""express"", ""rate"": 12.99, ""transit_days"": 2, ""carrier"": ""UPS""}]. Use RFC7807 for errors, e.g., {""type"": ""https://problems.deshio.com/rate-unavailable"", ""title"": ""Rates unavailable"", ""status"": 503}.
- Support content-negotiation for JSON; versioned (e.g., /v1/); locale/tz for date/time in addresses if applicable.
- PII masking for addresses in logs; input sanitizer for addresses/packages.

## Relevant Business Logic

- Fetch rates based on carrier configuration (accounts, credentials) to support fulfillment: shipments/shipment_items with transactional stock movements.
- Rates may influence order totals, promos, taxes; integrate with pricing/override logic.
- Handle carrier-specific rules (e.g., dimensional weight, zones); support inter-store dispatch if applicable.
- Ensure determinism for admin assignment of online orders; tie rates to reservation/consumption safety.
- Post ledger entries if rate selection leads to financial commitments; reverse on failures.
- Align with state machines for shipment/order transitions (e.g., rates required for confirmed→fulfilled).
- Support integrations like webhooks for rate updates or tracking; notification templates for rate alerts (e.g., low-cost options)."
240,integration,Create Waybill,Create carrier waybill,api/integrations/carriers/{id}/waybill,post,Employee,Implement POST api/integrations/carriers/{id}/waybill - Create Waybill,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the 'Create Waybill' API endpoint. This endpoint falls under the 'integration' category and enables the creation of a carrier waybill, supporting fulfillment processes such as shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Core entities include carriers & accounts, waybills/rates/tracking. The system features state machines for legality of transitions, conflicts returning RFC7807 problem+json, data in UTC, soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential links. Middleware includes TLS/HSTS, CORS, auth (JWT/session/API key), RBAC & permission checks, branch scope, throttles, idempotency, input sanitizer, and provider webhook signatures + replay defense.

## API Specifications

- **Category:** integration
- **Title:** Create Waybill
- **Description:** Create carrier waybill
- **Route:** api/integrations/carriers/{id}/waybill
- **HTTP Method:** POST
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST endpoint to create a waybill for the specified carrier ID
- [ ] Validate input parameters, including carrier ID and waybill details (e.g., shipment reference, dimensions, weight, addresses)
- [ ] Ensure the endpoint integrates with shipment and dispatch entities, updating tracking and stock movements transactionally
- [ ] Handle errors per RFC7807 problem+json for invalid states, permissions, or conflicts
- [ ] Add unit and integration tests covering success, validation failures, auth errors, and business rule violations
- [ ] Verify response includes created waybill details, such as waybill number, status, and tracking URL
- [ ] Confirm idempotency support via request headers to prevent duplicate waybills
- [ ] Test RBAC: only authenticated employees with appropriate permissions (e.g., logistics roles) can access
- [ ] Ensure audit_event logging for waybill creation and any state transitions
- [ ] Validate middleware application: auth, RBAC checks, branch scope, input sanitization, and cache headers

## Technical Requirements

- Use Laravel framework: Define route in api.php, create a dedicated controller (e.g., CarrierWaybillController) with a store method
- Implement input validation using Form Requests or Validator, covering required fields like shipment_id, carrier_service, package_details, and optional promos/taxes
- Integrate with Eloquent models for carriers, shipments, waybills; use transactions for atomicity in stock movements and ledger posting
- Handle business logic: Check shipment state (e.g., confirmed/pending fulfillment), assign to store/branch, apply reservations if needed, post to accounting ledger (transaction headers + ledger_entry lines)
- Support attachments/media for waybill (e.g., labels, POD), with upload mime guard
- For responses: Return JSON with HTTP 201 on success, including waybill object; use ETag/caching for subsequent tracking queries
- Error handling: Unauthorized (401), Forbidden (403) for RBAC, Not Found (404) for carrier/shipment, Bad Request (400) for validation, with problem+json details
- Observability: Include request-id, log events, PII masking; integrate with queues if async processing (e.g., carrier API calls) is needed
- Reporting tie-in: Ensure waybill data contributes to analytics like dispatch performance, SLA, and inventory aging

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT/session/API key
- RBAC enforcement: User must have role/permission for carrier integrations (e.g., ability role↔perm for 'create-waybill')
- Additional checks: Active user, email-verified, optional 2FA/TOTP MFA; branch scope to limit to assigned stores
- Middleware chain: auth → active user → email-verified → 2FA → RBAC & permission checks → branch scope

## Expected Request/Response Format Considerations

- **Request:** JSON body with fields like {""shipment_id"": ""uuid"", ""carrier_service"": ""express"", ""packages"": [{ ""weight"": 5.0, ""dimensions"": { ... }, ""items"": [...] }], ""from_address"": { ... }, ""to_address"": { ... }, ""notes"": ""string"", ""attachments"": [file_ids]}
- **Response (201):** {""data"": { ""id"": ""uuid"", ""waybill_number"": ""string"", ""status"": ""pending"", ""tracking_url"": ""url"", ""created_at"": ""utc-timestamp"", ""shipment"": { reference } }, ""links"": { self, tracking }}
- **Error Response:** {""type"": ""https://problem+json"", ""title"": ""Validation Error"", ""detail"": ""..."", ""status"": 400, ""problems"": [{ field, message }]}
- Content negotiation: Versioned API, JSON limits, locale/tz handling; all timestamps in UTC

## Relevant Business Logic

- Waybill creation triggers state machine transition for shipment/dispatch (e.g., confirmed → in-transit)
- Transactional: On success, update shipment status, reserve/consume inventory, post ledger entries for costs; on failure, reverse changes
- Integrations: Call external carrier API for rate/booking if configured; handle webhooks for updates with signature verification and replay defense
- Conflicts: Prevent creation if shipment is cancelled/fulfilled, or carrier inactive; fraud flag check on order
- Supports returns/exchanges via linked RMA; enables notifications (email/SMS) via templates
- Ensures deterministic assignment for online orders, safe reservation/consumption, and consistent ledger posting on every event
- Bulk operations: Consider future extension for bulk waybills; search/autosuggest for carriers/services
- Compliance: Soft deletes for archival, audit trails, feature flags for enabling/disabling"
241,integration,Track Waybill,Track shipment via carrier,api/integrations/carriers/{id}/track/{waybill},get,Employee,Implement Track Waybill API Endpoint for Carrier Integration,"## Overview

This GitHub issue is for implementing the 'Track Waybill' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs built over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes (fields/features), media (product images), barcodes, pricing (price overrides), and promotions; stores/branches; customers with tags/blacklists. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers.

The order domain handles order/order_item states (pending → confirmed → fulfilled|cancelled), assignment to stores, notes/attachments, promotions, taxes, and fraud flags. Fulfillment involves shipments (shipment/shipment_item) and inter-store dispatches (dispatch + tracking, scan events, POD) with transactional stock movements. Returns are managed via RMA (return/return_item), including receive/restock/scrap, refunds, and exchanges (exchange_order). Payments follow intent → payment capture/void lifecycles, with refund handling and order.payment_status synchronization.

Accounting uses transaction headers + ledger_entry lines for all movements, supporting reversals, reconciliation, and exports. Services include service/service_order with lifecycle and profitability tracking. Integrations cover carriers & accounts, waybills/rates/tracking; webhooks with deliveries; and notification templates (email/SMS).

Security and identity features include user/role/permission with abilities (role ↔ perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; and API keys. Observability and compliance involve audit_event, logs, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, and cache headers.

Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, and activity. State machines ensure legal transitions for orders, order items, dispatch, shipments, returns, payments, and cycle counts; conflicts return RFC7807 problem+json.

APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC with soft deletes for archival; EAV for attributes; polymorphic notes/attachments; and strict referential links across junctions. The design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The 'Track Waybill' endpoint allows tracking shipments via carriers, fitting into the integrations category for logistics and fulfillment.

## API Specifications

- **Category:** integration
- **Title:** Track Waybill
- **Description:** Track shipment via carrier
- **Route:** api/integrations/carriers/{id}/track/{waybill}
- **HTTP Method:** GET
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET endpoint at api/integrations/carriers/{id}/track/{waybill}
- [ ] Validate path parameters: carrier {id} (exists in carriers table) and {waybill} (string, valid format)
- [ ] Integrate with carrier API or service to fetch real-time tracking data
- [ ] Return tracking information in a standardized JSON response, including status, events, and estimated delivery
- [ ] Handle errors per RFC7807 (e.g., 404 for invalid carrier/waybill, 503 for carrier service unavailable)
- [ ] Ensure endpoint is secured with Employee authentication and appropriate RBAC permissions
- [ ] Write unit and integration tests covering success, validation failures, and error scenarios
- [ ] Add API documentation in OpenAPI/Swagger format
- [ ] Verify middleware application (e.g., auth, throttles, request-id)
- [ ] Test integration with shipment/shipment_item entities for waybill linkage

## Technical Requirements

- Use Laravel framework: Define route in api.php, create a dedicated controller (e.g., CarrierController@trackWaybill)
- Implement input validation using Form Requests or Validator for path params ({id} as UUID/integer, {waybill} as string)
- Leverage Eloquent models for carriers, shipments, and related entities; query shipment by waybill if linked
- Integrate with external carrier APIs (e.g., via HTTP client like Guzzle) for tracking; handle retries and timeouts
- Apply state machine checks if waybill relates to dispatch/shipment states
- Ensure transactional consistency for any audit_event logging or ledger updates if tracking affects fulfillment
- Use soft deletes and UTC timestamps; apply caching/etag for performance if tracking data is stable
- Include proper error handling with problem+json responses for conflicts or invalid states
- Add audit logging for endpoint access per observability requirements

## Authentication/Authorization Requirements

- Require Employee authentication (JWT/session/API key)
- Enforce RBAC: User must have permission in role/permission for 'integrations.carriers.track' or similar ability
- Apply active user, email-verified, and 2FA checks via middleware
- Scope to branch if waybill/dispatch is branch-specific
- Use idempotency if applicable for repeated tracking requests

## Expected Request/Response Format Considerations

- **Request:** No body (GET); path params: {id} (carrier ID, e.g., integer/UUID), {waybill} (string, e.g., 'WB123456789'). Query params optional: e.g., ?details=full for extended info.
- **Response (200 OK):** JSON object, e.g., {
  ""waybill"": ""WB123456789"",
  ""carrier"": {""id"": 1, ""name"": ""CarrierX""},
  ""status"": ""in_transit"",
  ""events"": [
    {""timestamp"": ""2023-10-01T12:00:00Z"", ""location"": ""Warehouse A"", ""description"": ""Shipped""}
  ],
  ""estimated_delivery"": ""2023-10-05T00:00:00Z""
}
- **Errors:** 400 (validation), 401 (unauth), 403 (forbidden), 404 (not found), 422 (unprocessable), 5xx (server/carrier errors) with RFC7807 format: {
  ""type"": ""https://example.com/errors/invalid-waybill"",
  ""title"": ""Invalid Waybill"",
  ""status"": 404,
  ""detail"": ""Waybill not found for this carrier""
}
- Content negotiation: JSON only, versioned (e.g., /v1/), with cache headers

## Relevant Business Logic

- Link waybill to existing shipment/shipment_item or dispatch entities; if not found, allow standalone tracking for integrations
- Update shipment status or add scan events based on tracking response, triggering state machine transitions (e.g., confirmed → in_transit)
- Post to ledger if tracking affects inventory movements (e.g., delivery confirmation)
- Trigger notifications (email/SMS) on status changes via templates
- Ensure PII masking in logs/audits for customer-related tracking data
- Support webhook delivery for real-time updates if carrier provides
- Handle carrier-specific formats/rates; use polymorphic attachments for POD if available
- Prevent fraud by validating waybill against order fraud flags or domain guards"
242,pricing,Set Price,Set product price at store/batch,api/pricing,post,Admin,Implement POST /api/pricing - Set Product Price at Store/Batch,"## Overview

This GitHub issue covers the implementation of the 'Set Price' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD that covers catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes (fields/features), media (product images), barcodes, and pricing (price overrides). Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. Pricing involves price overrides, promotions, and integration with orders, inventory, and accounting ledgers. This endpoint allows administrators to set or update product prices at specific stores/branches or batches, ensuring deterministic pricing for orders and consistent ledger posting on financial events. All data is stored in UTC, with soft deletes for archival, EAV for attributes, polymorphic notes/attachments, and strict referential links. State machines enforce legal transitions, and conflicts return RFC7807 problem+json responses. Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards (including pricing/override), upload mime guard, provider webhook signatures + replay defense, and cache headers. Reporting/analytics include revenue/pricing history, promo impact, and price change history.

## API Specifications

- **Category:** pricing
- **Title:** Set Price
- **Description:** Set product price at store/batch
- **Route:** api/pricing
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST /api/pricing endpoint in Laravel controller
- [ ] Ensure endpoint requires Admin authentication and RBAC permissions for pricing updates
- [ ] Validate request inputs for product_id, store_id/batch_id, price value, and optional effective_date
- [ ] Handle successful price setting with price override creation/update and ledger entry for accounting
- [ ] Integrate with batch-centric inventory and store/branch scoping
- [ ] Return appropriate success response (e.g., 200 OK with updated price details)
- [ ] Handle errors (e.g., invalid product/store, permission denied) using RFC7807 problem+json format
- [ ] Ensure idempotency for repeated requests and apply middleware (throttles, branch scope, input sanitizer, domain guards for pricing/override)
- [ ] Add unit/integration tests covering happy path, validation errors, auth failures, and business rule violations
- [ ] Document request/response schemas and include in API specs
- [ ] Verify integration with promotions, orders, and accounting (transaction headers + ledger_entry lines for price changes)
- [ ] Test for UTC handling, soft deletes, and referential integrity
- [ ] Include observability: audit_event logging, request-id tracing, PII masking if applicable

## Technical Requirements

- Use Laravel framework: Define route in api.php, create dedicated PricingController with setPrice method
- Implement input validation using Laravel's FormRequest or Validator, enforcing required fields (e.g., product_id as UUID/int, store_id/batch_id, price as decimal >0)
- Apply business logic: Check product existence, store/batch validity, user branch scope; create/update price_override record; post to accounting ledger for financial movement; handle reversals if needed
- Proper error handling: Use Laravel exceptions, return standardized JSON errors per RFC7807 (e.g., {type, title, status, detail})
- Database interactions: Use Eloquent models for Product, Store, Batch, PriceOverride; ensure transactions for atomicity
- Integrate with state machines if price changes affect order/promotion states
- Support bulk operations if extensible, but focus on single set for now
- Add caching/etag for pricing queries post-update

## Authentication/Authorization Requirements

- Authentication: Admin via JWT, session, or API key; enforce active user, email-verified, and TOTP MFA + backup codes
- Authorization: RBAC with user/role/permission checks; require 'pricing.update' permission; multi-role support via user_role; branch scope to limit to assigned stores/branches
- Middleware chain: auth → active user → email-verified → 2FA → RBAC & permission checks → branch scope

## Expected Request/Response Format Considerations

- **Request:** JSON body, e.g., {""product_id"": ""uuid"", ""store_id"": ""uuid"", ""batch_id"": ""optional uuid"", ""price"": 29.99, ""currency"": ""USD"", ""effective_date"": ""optional YYYY-MM-DDTHH:MM:SSZ""}; Use idempotency-key header
- **Response:** 200 OK on success, e.g., {""id"": ""price_override_uuid"", ""product_id"": ""uuid"", ""store_id"": ""uuid"", ""price"": 29.99, ""updated_at"": ""UTC timestamp""}; 4xx/5xx for errors in problem+json
- Content negotiation: Versioned (e.g., /api/v1/pricing), JSON only; Limits on payload size
- Headers: Request-Id, Cache-Control; Locale/tz from Accept-Language/X-Timezone

## Relevant Business Logic

- Price setting creates/updates price_override for product at store/batch level, overriding base pricing
- Ensure compatibility with promotions (e.g., no conflicts with active promos), orders (deterministic assignment), and inventory valuation
- Trigger ledger_entry for accounting transaction header on price change; support reversals and reconciliation/export
- Validate against fraud flags, cycle counts, and low stock; integrate with reporting for price change history and promo impact
- Enforce legality via state machines (e.g., cannot set price if batch reserved); Use domain guards for pricing/override
- For batches: Optional per-unit pricing if inventory is unit-based; Handle reservations/consumption safely
- Polymorphic attachments/notes for price records if needed; EAV attributes for custom pricing fields
- Observability: Log audit_event for price changes; Metrics for pricing API usage; Queues for async ledger posting if high-volume"
243,pricing,Get Price,Get effective price,api/pricing,get,Employee,Implement Get Price API Endpoint in Pricing Category,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD, this issue covers implementing the 'Get Price' endpoint in the pricing category. Deshio manages core entities like product/category/vendor with attributes, media, barcodes, pricing (including price_override), and promotions. Inventory is batch-centric with reservations, adjustments, and ledgers. The pricing domain handles effective prices considering overrides, promotions, taxes, and store/branch specifics. This endpoint retrieves the effective price for products, supporting deterministic pricing in orders, inventory, and reporting. Data is stored in UTC, with soft deletes, EAV for attributes, polymorphic relations, and strict referential integrity. State machines ensure legal transitions, with conflicts returning RFC7807 problem+json. Middleware includes auth (JWT/session/API key), RBAC, branch scope, throttles, idempotency, and input sanitization. Reporting includes price change history and promo impact.

## API Specifications

- **Category:** pricing
- **Title:** Get Price
- **Description:** Get effective price
- **Route:** api/pricing
- **HTTP Method:** GET
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint returns effective price for a product, considering overrides, promotions, taxes, and store/branch context
- [ ] Supports query parameters for product_id, store_id, customer_id (for personalized pricing), quantity, and date (for historical pricing)
- [ ] Handles authentication for Employee roles with necessary permissions (e.g., view_pricing)
- [ ] Includes proper error handling for invalid inputs, unauthorized access, or non-existent resources (RFC7807 format)
- [ ] Integrates with state machines for pricing validity (e.g., active promotions)
- [ ] Unit and integration tests cover happy path, edge cases (e.g., no override, expired promo), and errors
- [ ] Documentation updated with OpenAPI spec, including request/response examples
- [ ] Performance optimized for bulk or high-traffic scenarios, with caching/etag support
- [ ] Audit events logged for price queries
- [ ] Compatible with bulk import/export and search/autosuggest features

## Technical Requirements

- Implement in Laravel: Define route in api.php, create PricingController with getPrice method
- Use Eloquent models for Product, PriceOverride, Promotion, Store, and related entities
- Input validation via FormRequest: Required params (e.g., product_id), optional (store_id, quantity), with sanitization and domain guards
- Compute effective price logic: Base price + overrides - promotions + taxes, respecting customer tags/blacklist and fraud flags
- Response in JSON with request-id, etag for caching; support versioned content-negotiation and locale/tz
- Error handling: 4xx for validation/auth, 5xx for server issues, with PII masking in logs
- Database: UTC timestamps, soft deletes; ensure transactional consistency for price calculations
- Middleware: Apply auth, RBAC (role/permission checks for pricing access), branch scope, throttles, idempotency
- Integrations: Link to orders (for order_item pricing), inventory (valuation), accounting (ledger entries), and reporting (price history)
- Testing: PHPUnit for controller, feature tests for full flow; cover reservations/consumption impacts
- Observability: Log requests with request-id, metrics for SLA, queues if async computation needed
- Security: TLS/HSTS, CORS, JSON limits, upload guards (if attachments involved), feature flags for pricing rules

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- RBAC: User must have role with permission to view pricing (e.g., ability: view_pricing)
- Multi-role support via user_role; active user, email-verified, optional 2FA/TOTP
- Branch scope: Limit to user's assigned stores/branches
- Optional tenancy; domain guards for pricing overrides and promos
- Provider webhook signatures if external pricing feeds integrated

## Expected Request/Response Format Considerations

- **Request:** GET /api/pricing?product_id=123&store_id=456&customer_id=789&quantity=1&date=2023-01-01
  - Headers: Authorization (Bearer/JWT), Accept (application/json), X-Request-Id, X-Locale, X-Timezone
  - Query params validated; defaults to current store/date if omitted
- **Response (200 OK):** {""data"": {""effective_price"": 29.99, ""breakdown"": {""base"": 25.00, ""override"": 0, ""promo_discount"": -5.00, ""tax"": 9.99}, ""currency"": ""USD"", ""valid_until"": ""2023-12-31T23:59:59Z""}, ""meta"": {""request_id"": ""uuid""}}
  - JSON structure: Consistent with Deshio APIs; include etag for caching
  - Errors: 400 {""title"": ""Invalid Input"", ""detail"": ""Product not found"", ""type"": ""https://problem+json""}
- Support bulk: Optional ?product_ids[]=123&product_ids[]=456 for array response
- Content negotiation: Versioned (e.g., /v1/pricing), locale-aware formatting

## Relevant Business Logic

- Effective price calculation: Start with product base price, apply store/branch overrides, customer-specific promos (tags/blacklist), quantity tiers, and taxes
- Consider order context: Sync with order_item states (pending→confirmed), fraud flags, reservations
- Promotions: Active only if state machine allows; impact on LTV/AOV reporting
- Inventory ties: Price for valuation, low stock alerts, cycle count accuracy
- Accounting: Log price in ledger_entry for transactions; support reversals/reconciliation
- Fulfillment/Returns: Price consistency in shipments, RMAs, refunds/exchanges
- Services: Extend to service_order profitability
- Compliance: Audit price queries; PII masking for customer pricing; export for analytics (revenue by product/store)
- Edge cases: Historical pricing via date param; zero/negative prices handled gracefully; conflicts (e.g., inactive promo) via state machine validation"
244,pricing,Price Overrides,Store-level overrides,api/pricing/overrides,post,Admin,Implement POST /api/pricing/overrides for Store-level Price Overrides,"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.
Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint enables administrators to create store-level price overrides, allowing customization of product or category prices specific to individual stores or branches within the Deshio ERP system. It integrates with the pricing module, leveraging the price_override entity to handle overrides while ensuring compatibility with promotions, inventory, and order pricing logic.

## API Specifications

- **Category:** pricing
- **Title:** Price Overrides
- **Description:** Store-level overrides
- **Route:** api/pricing/overrides
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST endpoint to create store-level price overrides
- [ ] Validate required inputs such as product_id, store_id, override_price, and optional effective_date or expiry_date
- [ ] Ensure overrides are scoped to specific stores/branches and do not affect global pricing
- [ ] Handle conflicts with existing promotions or base prices, returning appropriate errors via RFC7807 problem+json
- [ ] Integrate with state machines for pricing transitions if applicable
- [ ] Add audit logging for override creations
- [ ] Write unit tests for controller logic and validation
- [ ] Write integration tests for database persistence and retrieval
- [ ] Ensure response includes the created override details on success (201 Created)
- [ ] Document the endpoint in API specs with examples
- [ ] Verify compatibility with reporting/analytics for price change history

## Technical Requirements

- Develop a Laravel controller (e.g., PricingOverrideController) to handle the POST request
- Define the route in routes/api.php with proper middleware stack (auth, RBAC, branch scope)
- Use Laravel's FormRequest for input validation, including rules for numeric prices, valid store/product IDs, and date formats
- Persist data to the price_override entity in the normalized ERD, with soft deletes enabled
- Implement proper error handling: validation errors (422), unauthorized (401), forbidden (403), and conflicts (409) using RFC7807 format
- Ensure UTC storage and timezone handling via middleware
- Add caching/etag support for related pricing queries if overrides affect lookups
- Include idempotency key support to prevent duplicate overrides
- Use Eloquent relationships to link overrides to products, categories, stores, and optionally promotions
- Trigger any relevant webhooks or notifications for price changes

## Authentication/Authorization Requirements

- Require Admin-level authentication via JWT, session, or API key
- Enforce RBAC: Users must have permissions for pricing overrides (e.g., 'pricing.override.create')
- Apply branch scope middleware to restrict overrides to authorized stores/branches
- Include active user check, email verification, and optional 2FA enforcement
- Use domain guards for override-specific validations to prevent invalid pricing scenarios

## Expected Request/Response Format Considerations

**Request Body (JSON):**
{
  ""product_id"": 123,
  ""store_id"": 456,
  ""override_price"": 29.99,
  ""currency"": ""USD"",
  ""effective_date"": ""2023-10-01T00:00:00Z"",
  ""expiry_date"": ""2023-12-31T23:59:59Z"",
  ""idempotency_key"": ""unique-key-123""
}

**Success Response (201 Created):**
{
  ""data"": {
    ""id"": 789,
    ""product_id"": 123,
    ""store_id"": 456,
    ""override_price"": 29.99,
    ""currency"": ""USD"",
    ""effective_date"": ""2023-10-01T00:00:00Z"",
    ""expiry_date"": ""2023-12-31T23:59:59Z"",
    ""created_at"": ""2023-09-01T10:00:00Z""
  },
  ""message"": ""Price override created successfully""
}

**Error Response (e.g., 422 Unprocessable Entity):**
{
  ""type"": ""https://tools.ietf.org/html/rfc7231#section-6.5.1"",
  ""title"": ""Validation Error"",
  ""detail"": ""The override_price must be a positive number."",
  ""status"": 422,
  ""errors"": {
    ""override_price"": [""The override_price must be a positive number.""]
  }
}

Use versioned content-negotiation (e.g., Accept: application/vnd.deshio.v1+json) and JSON limits middleware.

## Relevant Business Logic

- Price overrides are store-specific and take precedence over base product pricing but must not conflict with active promotions (validate against promo rules)
- Support overrides for products, categories, or vendors as per ERD; ensure referential integrity with strict links
- On creation, post to accounting ledger if overrides impact financials (e.g., track price change history for reporting)
- Integrate with inventory valuation: overrides may affect order item pricing during confirmation
- Handle soft deletes: overrides can be archived without affecting active periods
- Ensure determinism in pricing calculations for orders assigned to stores with overrides
- Prevent fraud: Include optional fraud flag or validation for extreme price deviations
- Tie into analytics: Track override impact on AOV, revenue by store/product, and promo effectiveness"
245,pricing,Delete Override,Remove override,api/pricing/overrides/{id},delete,Admin,Implement Delete Override API Endpoint in Pricing Category,"## Overview

This GitHub issue is for implementing the 'Delete Override' API endpoint in the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations. The endpoint allows admins to remove a specific price override, which is part of the pricing module handling price_override entities. Deshio features ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes, media, barcodes, pricing (including price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The design ensures deterministic admin assignment, safe reservation/consumption, and consistent ledger posting on stock/financial events. Data is stored in UTC, uses soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential links. State machines drive transitions for orders, shipments, returns, payments, etc., with conflicts returning RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

The endpoint removes an override, ensuring proper cleanup of related pricing data while adhering to middleware (TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers). Observability includes audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Reporting covers revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

## API Specifications

- **Category:** pricing
- **Title:** Delete Override
- **Description:** Remove override
- **Route:** api/pricing/overrides/{id}
- **HTTP Method:** DELETE
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint successfully deletes a price override by ID if it exists and the user has admin permissions
- [ ] Returns 204 No Content on successful deletion
- [ ] Returns 404 Not Found if the override ID does not exist
- [ ] Returns 403 Forbidden if the user lacks admin authentication or RBAC permissions
- [ ] Implements soft delete for the price_override entity to support archival
- [ ] Triggers audit_event for the deletion action, including request-id and user details
- [ ] Ensures idempotency: repeated DELETE requests on the same ID do not error after first deletion
- [ ] Handles concurrent requests with proper locking if overrides affect active pricing (e.g., promotions or reservations)
- [ ] Integrates with ledger posting if deletion impacts financial records (reversals if needed)
- [ ] Adds unit and integration tests covering success, failure, and edge cases (e.g., non-existent ID, unauthorized access)
- [ ] Validates route parameter {id} as a valid UUID or integer ID for the price_override
- [ ] Complies with middleware chain: auth, RBAC checks, branch scope, throttles, input sanitizer, domain guards (pricing/override)
- [ ] Caches invalidation if pricing data is cached (e.g., etag updates)
- [ ] Documents the endpoint in API specs (e.g., OpenAPI/Swagger)

## Technical Requirements

- Use Laravel framework: Define the route in api.php with resource naming (e.g., Route::delete('/pricing/overrides/{id}', [PricingOverrideController::class, 'destroy']);)
- Implement in a dedicated controller (e.g., PricingOverrideController) with dependency injection for repositories/services
- Use Eloquent model for price_override with soft deletes enabled
- Input validation: Ensure {id} is required and exists in the database before deletion
- Error handling: Use RFC7807 problem+json for errors (e.g., validation failures, not found, forbidden); log errors with request-id
- Business logic: Before deletion, check if the override is in use (e.g., linked to active orders, promotions, or reservations); if so, prevent deletion or queue for archival; post-deletion, update related pricing caches and potentially trigger price change history logging
- Integrate with accounting if applicable: Create reversal ledger_entry if the override affected transactions
- Observability: Emit audit_event on deletion; mask any PII in logs; support metrics for deletion rate
- Testing: PHPUnit tests for controller, including mocking auth/RBAC; feature tests simulating HTTP requests
- Security: Enforce admin role/permission via middleware (e.g., 'admin' guard with ability checks); validate against CSRF if session-based, but primarily JWT/API key

## Authentication/Authorization Requirements

- Requires admin authentication via JWT, session, or API key
- RBAC enforcement: User must have 'admin' role or specific permission (e.g., 'delete-pricing-override') via role↔perm and user_role mappings
- Additional checks: Active user status, email-verified, 2FA if enabled; branch scope to ensure override belongs to the user's accessible branches/stores
- Middleware sequence: auth → active user → email-verified → 2FA → RBAC & permission checks → branch scope
- Security & identity features: Sessions, email verification, password reset, TOTP MFA + backup codes, API keys

## Expected Request/Response Format Considerations

- **Request:** No body required; path parameter {id} (e.g., UUID or integer) for the price_override to delete. Headers: Authorization (Bearer token), Accept: application/json, Content-Type: application/json (though not used).
- **Response:** 
  - Success (204): No content.
  - Error (4xx/5xx): JSON with RFC7807 format, e.g., {""type"": ""https://example.com/probs/not-found"", ""title"": ""Not Found"", ""status"": 404, ""detail"": ""Override not found""}.
- Versioned: Support content-negotiation for API version (e.g., v1).
- Locale/TZ: Handle via headers, but deletion is idempotent and UTC-based.
- Idempotency: Use key from header if provided to prevent duplicate deletions.

## Relevant Business Logic

Price overrides (price_override) allow custom pricing for products/categories/vendors, potentially overriding base prices, promotions, or taxes. Deletion should:
- Not affect historical data (use soft deletes).
- Invalidate related caches (e.g., product pricing views).
- Check for dependencies: If override is assigned to active orders or reservations, return error or require confirmation; otherwise, proceed.
- Sync with order/payment status if impacted (e.g., recalculate totals post-deletion, but typically deletion is for inactive overrides).
- Ensure transactional integrity: Wrap in DB transaction; on failure, rollback and log.
- Align with state machines: If overrides have states, ensure deletion is a valid transition.
- Support integrations: If linked to reporting (price change history), log the deletion event.
- Fulfillment/returns/payments: No direct impact, but ensure ledger consistency if financial."
246,promotion,List Promotions,Paginated promotions,api/promotions,get,Admin,Implement GET /api/promotions - List Promotions Endpoint,"## Overview

This GitHub issue covers the implementation of the List Promotions API endpoint for the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. This endpoint provides a paginated list of promotions, enabling admins to retrieve promotion data efficiently.

Core entities include: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

## API Specifications

- **Category:** promotion
- **Title:** List Promotions
- **Description:** Paginated promotions
- **Route:** api/promotions
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET /api/promotions endpoint to return a paginated list of promotions
- [ ] Support standard pagination query parameters (e.g., page, per_page)
- [ ] Enforce Admin authentication and RBAC permission checks for accessing promotions
- [ ] Include relevant promotion fields such as ID, name, type, start/end dates, conditions, and associated entities (e.g., products/categories)
- [ ] Handle soft deletes by excluding archived promotions unless specified
- [ ] Return responses in JSON format with proper HTTP status codes (200 for success)
- [ ] Implement error handling for unauthorized access (401), not found (404), and other RFC7807 problem+json errors
- [ ] Add unit tests for controller logic, integration tests for endpoint, and tests for pagination and authentication
- [ ] Ensure endpoint respects middleware chain including auth, RBAC, throttling, and idempotency
- [ ] Log audit events for endpoint access
- [ ] Optimize for performance with Eloquent queries, caching/etag where applicable
- [ ] Support optional filters/sorting for promotions (e.g., by status, date, store)

## Technical Requirements

- Use Laravel framework: Define route in api.php, create or use PromotionsController with index method
- Leverage Eloquent models for promotions entity, including relationships to products, categories, pricing, etc.
- Implement pagination using Laravel's LengthAwarePaginator or simplePaginate
- Apply input validation/sanitization via Form Requests for query parameters
- Integrate with existing middleware stack: auth (JWT/session/API key), RBAC & permission checks (admin role required), branch scope if applicable, throttles, input sanitizer, domain guards for promo
- Use state machines if promotions have lifecycle states; ensure legality of data exposure
- Handle UTC timestamps, soft deletes, and EAV attributes for promotion details
- Response format: JSON array of promotion objects with pagination metadata (e.g., {""data"": [...], ""current_page"": 1, ""total"": 50})
- Error responses: RFC7807 problem+json for conflicts or validation errors
- Add observability: request-id, audit_event logging, PII masking if promotions contain sensitive data
- Ensure consistency with other APIs: bulk export compatibility, search/autosuggest if extended, feature flags for endpoint

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC: User must have admin role/permission to list promotions (e.g., 'view_promotions' ability)
- Additional checks: Active user, email-verified, 2FA if enabled, branch scope for store-specific promotions
- Unauthorized requests return 401; insufficient permissions return 403

## Expected Request/Response Format Considerations

- **Request:** GET /api/promotions?page=1&per_page=20&status=active&sort=created_at (optional query params for pagination, filters, sorting)
- **Response (Success - 200):** 
{
  ""data"": [
    {
      ""id"": 1,
      ""name"": ""Summer Sale"",
      ""type"": ""percentage_discount"",
      ""start_date"": ""2023-06-01T00:00:00Z"",
      ""end_date"": ""2023-08-31T23:59:59Z"",
      ""conditions"": {...},
      ""products"": [1, 2],
      // other fields
    }
  ],
  ""current_page"": 1,
  ""per_page"": 20,
  ""total"": 100,
  // pagination info
}
- **Response (Error - 401):** {""title"": ""Unauthorized"", ""detail"": ""Admin access required""} (RFC7807 format)
- Content negotiation: JSON only, versioned if applicable, cache headers
- Idempotency: Supported via middleware for repeated requests

## Relevant Business Logic

- Promotions integrate with pricing (price_override), orders (promos application), and reporting (promo impact on revenue/AOV)
- Ensure promotions are filtered by current date (active vs. expired) unless specified
- Support for polymorphic attachments/notes on promotions
- Transactional consistency: No direct stock/financial movements, but link to ledger if promo affects accounting
- Conflicts (e.g., overlapping promos) handled via domain guards, returning problem+json
- Align with overall design: Deterministic application in orders, safe consumption in reservations"
247,promotion,Create Promotion,Create promotion,api/promotions,post,Admin,Implement Create Promotion API Endpoint,"## Overview

This GitHub issue is for implementing the 'Create Promotion' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD. It covers domains including catalog (product/category/vendor with attributes, media, barcodes, pricing, promotions), orders, inventory (batch-centric with reservations, adjustments, cycle counts, valuation, ledgers), logistics (shipments, dispatches, tracking), payments, RBAC, and audits.

Core entities include stores/branches, customers with tags/blacklist. Order domain handles states (pending→confirmed→fulfilled|cancelled), assignments, notes/attachments, promos, taxes, fraud flags. Fulfillment involves shipments/shipment_items and inter-store dispatches with stock movements. Returns manage RMA (return/return_item), restock/scrap, refunds, exchanges. Payments track intents, captures/voids, refunds, and order synchronization. Accounting uses transaction headers + ledger_entries for movements, reversals, reconciliation/export. Services include service/service_order lifecycles. Integrations cover carriers, waybills/rates/tracking, webhooks, notifications.

Security features user/role/permission with multi-roles, sessions, email verification, password reset, TOTP MFA, API keys. Observability includes audit_events, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware encompasses TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC/permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines ensure legal transitions for orders, items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links. Design supports deterministic admin assignment, safe reservation/consumption, consistent ledger posting on stock/financial events.

The 'Create Promotion' endpoint allows admins to create new promotions, which are integral to pricing strategies, including price_overrides and promotional logic integrated with orders, inventory, and reporting.

## API Specifications

- **Category:** promotion
- **Title:** Create Promotion
- **Description:** Create promotion
- **Route:** api/promotions
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST /api/promotions endpoint to create a new promotion record
- [ ] Ensure the endpoint requires Admin authentication and RBAC permissions for promotion creation
- [ ] Add input validation for promotion fields (e.g., name, type, conditions, discounts, validity dates, applicable entities like products/categories/stores)
- [ ] Handle business logic for promotion creation, including integration with pricing, state machines, and ledger posting if applicable
- [ ] Return appropriate success response with the created promotion details and 201 Created status
- [ ] Implement error handling for invalid inputs, unauthorized access, or conflicts (e.g., duplicate promotion names), using RFC7807 problem+json
- [ ] Add unit and integration tests covering happy path, validation errors, auth failures, and edge cases
- [ ] Ensure compatibility with middleware (e.g., auth, RBAC, idempotency, input sanitizer, domain guards for promo)
- [ ] Document the endpoint in API specs, including request/response examples
- [ ] Verify integration with related entities (e.g., products, orders, reporting for promo impact)

## Technical Requirements

- Use Laravel controller (e.g., PromotionController@store) and define route in api.php with 'admin' middleware group
- Implement input validation using Form Requests or Validator, covering required fields like promotion type (e.g., percentage discount, fixed amount, buy-one-get-one), rules (min/max spend, quantity limits), dates (start/end), scopes (all stores, specific branches, products/categories/vendors/customers/tags)
- Integrate with Eloquent models for promotions, using soft deletes, UTC timestamps, and relationships to catalog entities (products/categories), orders, and pricing overrides
- Apply state machine for promotion lifecycle if applicable (e.g., draft→active→expired)
- Ensure transactional consistency for any related ledger entries or inventory reservations tied to promotions
- Use JSON responses with proper HTTP codes; include request-id in responses/logs
- Add logging/auditing via audit_event for creation actions, with PII masking
- Support bulk creation if extensible, but focus on single creation; consider idempotency keys for retries
- Optimize for caching/etag if promotions are frequently read

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have 'create-promotion' permission assigned via role→permission mapping
- Apply branch scope if promotions are store-specific
- Include middleware for active user, email-verified, 2FA if enabled
- Reject unauthorized requests with 401/403, using problem+json details

## Expected Request/Response Format Considerations

- **Request:** JSON body with fields like {""name"": ""Summer Sale"", ""type"": ""percentage"", ""discount"": 20, ""start_date"": ""2023-06-01"", ""end_date"": ""2023-08-31"", ""applies_to"": {""products"": [1,2], ""stores"": [1]}, ""conditions"": {""min_amount"": 50}}
- Validate MIME types if attachments/notes are included (polymorphic)
- **Response:** 201 Created with JSON {""id"": 1, ""name"": ""Summer Sale"", ... , ""created_at"": ""UTC timestamp""}; include links for related resources (e.g., self, products)
- Error responses: 400 for validation (problem+json with field errors), 409 for conflicts (e.g., overlapping promotions), 422 for unprocessable entity
- Use content-negotiation for versioned API (e.g., v1/promotions); support locale/tz for date fields

## Relevant Business Logic

- Promotions integrate with order processing: Apply during order creation/confirmation if conditions met, affecting pricing, taxes, and totals; sync with order_item states and promos field
- Ensure no conflicts with existing promotions (e.g., validate overlaps via domain guard)
- Trigger ledger postings for any financial impacts (e.g., promo-related adjustments)
- Support reporting: Track promo impact on revenue, AOV, units sold; include in analytics queries
- Handle edge cases like promotions on blacklisted customers or fraud-flagged orders
- Use state machines to validate creation transitions; ensure referential integrity with linked entities (e.g., delete cascades or soft deletes)
- Consider integrations: Webhooks for promo creation if subscribed; notifications for activation"
248,promotion,Get Promotion,Get by id,api/promotions/{id},get,Admin,Implement GET /api/promotions/{id} for Admin Users,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD, this issue covers implementing the 'Get Promotion' API endpoint. Deshio manages core entities including product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.

Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.

Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.

Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).

Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.

Services: service/service_order with lifecycle and profitability.

Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.

Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint retrieves a specific promotion by ID, supporting the promotion category in pricing and order domains.

## API Specifications

- **Category:** promotion
- **Title:** Get Promotion
- **Description:** Get by id
- **Route:** api/promotions/{id}
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint returns the promotion details for a valid ID when authenticated as Admin
- [ ] Endpoint returns 404 for non-existent ID
- [ ] Endpoint enforces Admin authentication and RBAC permissions
- [ ] Response follows JSON API standards with proper structure
- [ ] Includes audit logging for the request
- [ ] Handles soft deletes appropriately (e.g., does not return deleted promotions)
- [ ] Integrates with middleware stack including auth, RBAC, request-id, etc.
- [ ] Unit and integration tests cover success, error cases, and edge cases
- [ ] Documentation updated for the endpoint
- [ ] Performance considerations: caching if applicable, efficient DB query

## Technical Requirements

- Implement in Laravel: Create controller method in PromotionController (or similar), add route to api.php
- Use Eloquent model for promotions, fetch by ID with appropriate relations (e.g., linked products, rules)
- Input validation: Ensure {id} is a valid UUID or integer
- Proper error handling: Use RFC7807 problem+json for errors (e.g., 401 Unauthorized, 403 Forbidden, 404 Not Found)
- Response formatting: Return JSON with promotion data, including attributes, conditions, linked entities
- Consider state machines if promotions have lifecycle states
- Ensure UTC handling and timezone awareness via middleware
- Add to OpenAPI/Swagger docs
- Follow Deshio conventions: Soft deletes, EAV for attributes, polymorphic relations if applicable

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC check: User must have permission to view promotions (e.g., 'promotion.view')
- Middleware: auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope
- Scope to branch/store if promotions are store-specific

## Expected Request/Response Format Considerations

- **Request:** GET /api/promotions/{id} (path param {id}), optional query params for includes/fields if supported
- **Response (200 OK):** JSON object with promotion data, e.g., {""data"": {""id"": ""uuid"", ""name"": ""string"", ""type"": ""discount"", ""rules"": [...], ""valid_from"": ""datetime"", ""valid_to"": ""datetime"", ""linked_products"": [...], ""stores"": [...]}}
- Use content-negotiation for versioned responses
- Cache headers and ETag for observability
- Error responses: Standard problem+json, e.g., {""type"": ""https://example.com/probs/not-found"", ""title"": ""Not Found"", ""status"": 404}
- PII masking if promotion data includes sensitive info

## Relevant Business Logic

- Promotions integrate with pricing (price_override), orders (promos application), and reporting (promo impact)
- Fetch includes related entities like products/categories/vendors, stores/branches
- Respect soft deletes: Do not return deleted promotions
- If promotion has states, ensure it's active/valid
- Transactional consistency: Read from current state, no modifications here
- Audit event logging for access
- Idempotency not applicable for GET, but ensure safe reads
- Domain guards for promo-related checks if needed"
249,promotion,Update Promotion,Update by id,api/promotions/{id},put,Admin,Implement Update Promotion API Endpoint (PUT /api/promotions/{id}),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs over a normalized ERD, this issue covers implementing the Update Promotion API endpoint. Deshio manages core entities including products/categories/vendors with attributes (fields/features), media (product images), barcodes, pricing (price overrides), and promotions. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers.

The order domain handles order/order_item states (pending → confirmed → fulfilled|cancelled), assignment to stores, notes/attachments, promos, taxes, and fraud flags. Fulfillment includes shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns manage RMA (return/return_item), receive/restock/scrap, refunds, and exchanges (exchange_order). Payments involve intent → payment capture/void, refund lifecycles, and order.payment_status synchronization.

Accounting features transaction headers + ledger_entry lines for all movements, reversals, and reconciliation/export. Services include service/service_order with lifecycle and profitability. Integrations cover carriers & accounts, waybills/rates/tracking, webhooks with deliveries, and notification templates (email/SMS).

Security & identity: user/role/permission with ability (role ↔ perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint allows updating an existing promotion by ID, ensuring integration with pricing, orders, and promotions logic while adhering to security, observability, and business rules.

## API Specifications

- **Category:** promotion
- **Title:** Update Promotion
- **Description:** Update by id
- **Route:** api/promotions/{id}
- **HTTP Method:** put
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the PUT /api/promotions/{id} endpoint in the Laravel controller
- [ ] Validate input data for promotion updates, including fields like name, description, discount type, applicability (e.g., products/categories), start/end dates, and conditions
- [ ] Ensure updates respect business logic, such as checking for active orders affected by the promotion and handling state transitions if applicable
- [ ] Add RBAC checks to restrict access to admin users with promotion update permissions
- [ ] Implement proper error handling, returning RFC7807 problem+json for validation failures, unauthorized access, or conflicts (e.g., promotion in use)
- [ ] Write unit and integration tests covering successful updates, validation errors, authorization failures, and edge cases like soft-deleted promotions
- [ ] Update API documentation with request/response examples and OpenAPI specs
- [ ] Ensure endpoint integrates with middleware stack, including auth, throttling, idempotency, and audit logging
- [ ] Verify compatibility with promotions in order domain (e.g., promos applied to orders) and reporting (e.g., promo impact analytics)
- [ ] Test for data integrity, using UTC timestamps and EAV attributes if promotions have custom fields

## Technical Requirements

- Use Laravel controller and routes: Define the route in api.php with {id} parameter binding to Promotion model
- Input validation: Leverage Form Requests or Validator for required/optional fields (e.g., string for name, numeric for discount percentage, dates for validity period); sanitize inputs per middleware
- Model interactions: Fetch Promotion by ID (with soft deletes check), apply updates, save with audit_event logging for changes
- Database: Ensure referential integrity with linked entities (e.g., products/categories/vendors); use transactions for atomic updates if involving pricing overrides or ledgers
- Response: Return updated promotion JSON (201 or 200), with ETag for caching; include problem+json for errors
- Integration: Hook into state machines if promotions have lifecycle states; post to ledgers if update affects financials; notify via webhooks if configured
- Testing: PHPUnit tests for controller, feature tests for full flow; mock auth and RBAC
- Observability: Log requests with request-id, mask PII in promotion data (e.g., customer tags if applicable)

## Authentication/Authorization Requirements

- Require Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have 'update' permission on 'promotion' resource via role/permission checks in middleware
- Additional guards: Active user, email-verified, 2FA if enabled; branch scope if promotions are store-specific
- Reject unauthorized requests with 401/403, using problem+json

## Expected Request/Response Format Considerations

- **Request:** JSON body with updatable fields (e.g., {""name"": ""Summer Sale"", ""discount_type"": ""percentage"", ""discount_value"": 20, ""start_date"": ""2023-06-01T00:00:00Z"", ""end_date"": ""2023-08-31T23:59:59Z"", ""applicable_to"": [1,2] for product IDs}); support partial updates
- **Headers:** Accept: application/json, Content-Type: application/json, Authorization: Bearer <token>, X-Request-Id, If-Match for ETag
- **Response (Success):** 200 OK with JSON of updated promotion (include id, updated_at, relations if requested via ?include=)
- **Response (Error):** 400 for validation (e.g., {""type"": ""https://example.com/probs/validation"", ""title"": ""Invalid Input"", ""detail"": ""Discount value must be positive""}); 404 if ID not found; 409 for conflicts (e.g., active usage)
- Versioning: Use content-negotiation for API version (e.g., /v1/promotions/{id})
- Idempotency: Support Idempotency-Key header for safe retries

## Relevant Business Logic

- Promotions integrate with catalog (products/categories), pricing (overrides), and orders (promos application)
- Updates must validate legality: e.g., cannot end a promotion prematurely if orders are pending fulfillment; use state machines for transitions
- Ensure transactional consistency: If update affects inventory reservations or ledgers, post entries accordingly
- Handle soft deletes: Prevent updates on deleted promotions, or restore if needed
- Analytics impact: Track changes for promo impact reporting, price change history
- Domain guards: Apply promo-specific guards for fraud/override checks during updates
- Polymorphic relations: Support notes/attachments on promotions if updated"
250,promotion,Delete Promotion,Delete by id,api/promotions/{id},delete,Admin,Implement DELETE /api/promotions/{id} Endpoint for Admin,"## Overview

This GitHub issue is for implementing the 'Delete Promotion' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint allows admins to delete a promotion by its ID, ensuring proper handling within the promotion category of the catalog domain.

## API Specifications

- **Category:** promotion
- **Title:** Delete Promotion
- **Description:** Delete by id
- **Route:** api/promotions/{id}
- **HTTP Method:** delete
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint successfully deletes a promotion by ID when authenticated as Admin
- [ ] Returns appropriate success response (e.g., 204 No Content) on successful deletion
- [ ] Handles non-existent ID with 404 error (RFC7807 problem+json)
- [ ] Validates that the user has Admin role and necessary permissions for promotion deletion
- [ ] Implements soft delete if applicable, per Deshio's archival policy
- [ ] Logs audit_event for the deletion action
- [ ] Ensures no active orders or related entities block deletion, or handles gracefully with business logic
- [ ] Includes unit and integration tests covering success, error cases, and edge scenarios
- [ ] Complies with middleware stack: auth, RBAC, domain guards for promo
- [ ] Response includes proper cache headers and request-id

## Technical Requirements

- Implement in Laravel: Add route to api.php, create or update PromotionController with destroy method
- Use Eloquent model for promotions, ensuring referential integrity with related entities (e.g., orders, pricing)
- Input validation: Ensure {id} is a valid UUID/integer; no body expected for DELETE
- Error handling: Use RFC7807 problem+json for failures (e.g., unauthorized, not found, conflicts)
- Integrate with state machines if promotion has lifecycle states
- Support idempotency and throttling per middleware plan
- Add observability: Log deletion in audit_event, track metrics
- Ensure UTC handling and soft deletes for compliance
- Write comprehensive tests: Feature tests for endpoint, unit tests for controller logic

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT/session/API key
- Enforce RBAC: User must have role with permission to delete promotions (ability: role↔perm)
- Apply middleware: auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope
- Optional: Tenancy if promotions are scoped

## Expected Request/Response Format Considerations

- **Request:** DELETE /api/promotions/{id} (path param {id} as string/integer; no body)
- **Headers:** Authorization (Bearer/JWT), Accept: application/json, Content-Type: application/json
- **Success Response:** 204 No Content (empty body)
- **Error Responses:** 401 Unauthorized, 403 Forbidden, 404 Not Found, 409 Conflict (e.g., if promotion in use); all in problem+json format with title, detail, type
- Versioned via content-negotiation; support locale/tz from headers
- Idempotency: Handle via key if provided

## Relevant Business Logic

- Deletion should check for dependencies (e.g., active promotions in orders, pricing overrides) and prevent hard delete if conflicting; use soft delete for archival
- Trigger ledger_entry if deletion impacts financials (e.g., promo reversals)
- Ensure transactional consistency: Rollback if related stock/financial events fail
- Integrate with reporting: Update promo impact analytics post-deletion
- Comply with domain guards for promo to prevent invalid states
- If promotion is part of EAV attributes or polymorphic relations, cascade or nullify appropriately
- Align with overall Deshio design for safe operations and auditability"
251,promotion,Apply Promotion,Apply promo to order,api/orders/{id}/apply-promo,post,Employee,Implement Apply Promotion API Endpoint for Orders,"## Overview

This GitHub issue is for implementing the 'Apply Promotion' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs built over a normalized ERD. The core entities include products/categories/vendors with attributes (fields/features), media (product images), barcodes, pricing (price overrides), and promotions. Other domains cover stores/branches, customers with tags/blacklists, batch-centric inventory supporting reservations/adjustments/cycle counts/valuation/ledgers, order/order_item states (pending→confirmed→fulfilled|cancelled) with assignment to stores, notes/attachments, promotions, taxes, and fraud flags. Fulfillment involves shipments/shipment_items and inter-store dispatches with tracking/scan events/POD and transactional stock movements. Returns handle RMAs (return/return_items), restocking/scrap/refunds/exchanges. Payments include intent→capture/void, refunds, and order payment status sync. Accounting uses transaction headers + ledger entries for movements, reversals, and reconciliation/export. Services cover service/service_orders with lifecycle/profitability. Integrations include carriers/accounts, waybills/rates/tracking, webhooks, and notification templates (email/SMS). Security features user/role/permission with abilities (role↔perm) and user_roles (multi-role), sessions, email verification, password reset, TOTP MFA + backup codes, and API keys. Observability includes audit_events, logs, request-ids, PII masking, health/metrics, queues, caching/etag. Middleware encompasses TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC/permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, and cache headers. Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, and activity. State machines ensure legal transitions for orders/order items/dispatch/shipments/returns/payments/cycle counts, with conflicts returning RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential links. Design supports deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on stock/financial events.

The endpoint allows applying a promotion to an existing order, integrating with the promotion and order domains to handle pricing adjustments, eligibility checks, and state transitions.

## API Specifications

- **Category:** promotion
- **Title:** Apply Promotion
- **Description:** Apply promo to order
- **Route:** api/orders/{id}/apply-promo
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST /api/orders/{id}/apply-promo endpoint in Laravel controller
- [ ] Validate request input including order ID existence, promotion eligibility, and business rules (e.g., order state, promo applicability)
- [ ] Handle promotion application logic: update order total, apply discounts/taxes, create audit events, and post ledger entries if financial impact
- [ ] Ensure state machine validates transition legality for order/order_items; return RFC7807 problem+json on conflicts
- [ ] Add RBAC checks for Employee authentication and permissions (e.g., ability to modify orders/promos)
- [ ] Implement proper error handling for invalid orders, expired promos, or application failures
- [ ] Write unit/integration tests covering success/failure scenarios, validation, and edge cases (e.g., already applied promos, insufficient stock reservations)
- [ ] Document request/response formats in API specs
- [ ] Verify integration with middleware (auth, throttles, idempotency, domain guards for promo/override)
- [ ] Ensure soft deletes and UTC handling; mask PII in logs/audits
- [ ] Test bulk/related features if promo affects multiple items or triggers notifications/webhooks

## Technical Requirements

- Use Laravel framework: Define route in api.php, create dedicated controller method (e.g., OrdersController@applyPromo)
- Input validation: Use Form Requests or Validator for {id} (order UUID/int), request body (e.g., { ""promo_code"": ""string"", ""promo_id"": ""uuid"" } inferred from context; validate promo existence/eligibility via promotion rules)
- Business logic: Check order state (e.g., pending/confirmed), verify promo conditions (date, min order value, exclusions), apply to order_items, recalculate pricing/taxes/promos, reserve/consume stock if needed, sync payment status, post accounting ledger entries for price overrides
- Authentication/Authorization: Require Employee auth (JWT/session/API key), verify active/email-verified/2FA, RBAC permission check (e.g., 'orders.apply-promo' ability scoped to branch/store), branch scope enforcement
- Expected Request Format: JSON body with promo identifier; example: {""promo_id"": ""uuid"", ""apply_to_items"": [array of item IDs if partial]}
- Expected Response Format: 200 OK with updated order JSON (include applied promos, new total, status); 4xx/5xx with RFC7807 problem+json (e.g., {""type"": ""https://example.com/probs/invalid-promo"", ""title"": ""Promo ineligible"", ""status"": 422})
- Error Handling: Domain guards for promo/override/fraud; idempotency via key in request; transactional (rollback on failure for stock/ledger consistency)
- Integrations: Trigger state machine for order transitions; audit_event logging; possible notifications (email/SMS templates); webhook if promo changes trigger external sync
- Testing: PHPUnit tests for controller/service layers; cover promotions integration with orders/inventory/pricing; mock RBAC/state machine
- Observability: Add request-id tracing, metrics for promo application success rate, logs with PII masking
- Additional: Support EAV attributes for promo rules; polymorphic attachments if promo includes notes; ensure referential integrity with strict junctions"
252,promotion,Remove Promotion,Remove promo from order,api/orders/{id}/remove-promo,post,Employee,Implement API: Remove Promotion from Order (POST /api/orders/{id}/remove-promo),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD, implement the 'Remove Promotion' endpoint. This endpoint allows removing a promotion (promo) from an existing order, ensuring compliance with order domain logic including states (pending→confirmed→fulfilled|cancelled), promos, taxes, and ledger postings. Core entities involved include orders, order_items, promotions, and accounting ledgers. The system supports deterministic admin assignment, safe reservation/consumption, and consistent ledger posting on every financial event. Data is stored in UTC, with soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential links. State machines drive legality of transitions, returning RFC7807 problem+json for conflicts.

Deshio covers catalog (product/category/vendor with attributes, media, barcodes, pricing, promotions), stores/branches, customers + tags/blacklist, batch-centric inventory (reservations, adjustments, cycle counts, valuation, ledgers), order domain (assignment to store, notes/attachments, fraud flag), fulfillment (shipments, inter-store dispatch with tracking), returns (RMA, refunds, exchanges), payments (intent→capture/void, refunds), accounting (transaction headers + ledger_entry lines, reversals, reconciliation), services, integrations (carriers, webhooks, notifications), security (RBAC, JWT/session/API key, 2FA, API keys), observability (audit_event, logs, PII masking, metrics), middleware (TLS/HSTS, CORS, auth, RBAC checks, branch scope, throttles, idempotency, sanitizers), and reporting/analytics (revenue, LTV/AOV, inventory aging, promo impact).

## API Specifications

- **Category:** promotion
- **Title:** Remove Promotion
- **Description:** Remove promo from order
- **Route:** api/orders/{id}/remove-promo
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint handles POST requests to remove a promotion from a specified order
- [ ] Validates order existence, ownership, and current state (e.g., not fulfilled/cancelled if promo removal affects legality)
- [ ] Updates order totals, taxes, and removes promo application, triggering state machine transition if needed
- [ ] Posts reversals to accounting ledger for promo-related financial adjustments
- [ ] Handles errors with RFC7807 problem+json (e.g., invalid state, unauthorized)
- [ ] Includes audit_event logging for the removal action
- [ ] Supports middleware: auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, throttles, idempotency, input sanitizer
- [ ] Returns appropriate HTTP status codes (e.g., 200 OK on success, 404 for order not found, 403 unauthorized)
- [ ] Add unit/integration tests covering success, validation failures, unauthorized access, and edge cases (e.g., no promo applied)
- [ ] Document endpoint in API specs with request/response examples

## Technical Requirements

- Implement in Laravel: Define route in api.php, create controller method in OrdersController or PromotionsController
- Use request validation (FormRequest) for order ID and any promo-specific params (e.g., promo_id if multiple)
- Integrate with Eloquent models: Order, Promotion, OrderItem; handle soft deletes and referential integrity
- Apply state machine for order transitions; ensure removal doesn't violate legality (e.g., post-confirmation removal rules)
- Trigger ledger_entry postings for financial reversals; synchronize with payments if promo affected totals
- Use middleware stack: RequestId, JSON limits, versioned content-negotiation, locale/tz, auth, RBAC (employee role/permission for order modification), branch scope
- Handle bulk operations if extensible, but focus on single order
- Ensure idempotency for repeated requests
- Add caching/etag considerations if order data is cached
- Include PII masking in logs; generate audit_event with request-id

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- RBAC check: User must have role/permission allowing order modifications (e.g., 'edit-orders' ability)
- Verify active user, email-verified, and optional 2FA/TOTP
- Branch scope: Employee must be scoped to the order's assigned store/branch
- Optional tenancy if multi-tenant setup

## Expected Request/Response Format Considerations

- **Request:** JSON body optional (e.g., {""promo_id"": ""uuid""} if specifying which promo to remove; assume auto-detect if single); path param {id} as order UUID
- **Response:** On success, 200 OK with updated order JSON (including recalculated totals, removed promo); include ETag for caching
- **Errors:** 4xx/5xx with problem+json (type, title, detail, instance); e.g., {""type"": ""https://example.com/probs/invalid-state"", ""title"": ""Cannot remove promo"", ""detail"": ""Order is already fulfilled""}
- Content negotiation: JSON only; versioned (e.g., /v1/); UTF-8 encoding
- Use 
 for line breaks in descriptions; ensure no PII in responses

## Relevant Business Logic

- Promo removal recalculates order totals, taxes, and discounts; may trigger payment re-authorization if totals change significantly
- Validate against order state: Allow only if pending/confirmed; block if fulfilled/cancelled to prevent inconsistencies
- If promo involved reservations/stock, ensure reversals (e.g., release reserved inventory)
- Sync with promotions domain: Log promo usage impact for reporting (promo impact analytics)
- Handle attachments/notes: Optionally add note about removal
- Fraud flag: Check if removal triggers fraud review
- Ledger: Post reversal transaction header + lines for promo value
- Integrations: If promo tied to external (e.g., webhook), notify on removal
- Compliance: Audit all changes; support reversals for accounting reconciliation"
253,catalog,Rebuild Search Index,Re-index products,api/catalog/reindex,post,Admin,Implement POST /api/catalog/reindex for Rebuilding Product Search Index,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the 'Rebuild Search Index' API endpoint in the catalog category. This endpoint allows admins to re-index products, ensuring the search functionality remains up-to-date and performant. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This reindex operation should trigger a full rebuild of the product search index, incorporating all relevant product data such as attributes, media, barcodes, and pricing, while respecting the system's middleware stack including RBAC, throttling, and idempotency.

## API Specifications

- **Category:** catalog
- **Title:** Rebuild Search Index
- **Description:** Re-index products
- **Route:** api/catalog/reindex
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint responds to POST requests on /api/catalog/reindex
- [ ] Requires admin authentication and authorization
- [ ] Triggers a full re-index of all products in the catalog, including attributes, media, barcodes, pricing, and promotions
- [ ] Handles large datasets efficiently, potentially using queues for background processing
- [ ] Returns success response upon completion or initiates async process with status
- [ ] Implements proper error handling for failures, returning RFC7807 problem+json
- [ ] Includes audit logging for the reindex operation
- [ ] Validates that the search index is updated and searchable post-reindex
- [ ] Ensures data consistency with UTC storage and soft deletes
- [ ] Integrates with middleware: auth, RBAC, throttles, idempotency, and caching/etag
- [ ] Unit and integration tests cover happy path, auth failures, and error scenarios
- [ ] Documentation updated for API usage

## Technical Requirements

- Develop in Laravel: Create a dedicated controller (e.g., CatalogController) with a reindex method
- Define route in api.php with POST /catalog/reindex
- Use Laravel's queue system if reindex is resource-intensive to avoid blocking
- Integrate with search provider (e.g., Elasticsearch or Scout) to rebuild the index
- Handle input validation: No request body expected, but validate auth and permissions
- Implement error handling: Catch exceptions, log via audit_event, respond with standardized errors
- Ensure transactional integrity for any related data updates
- Follow design patterns: State machines for any transitional logic, EAV for attributes, polymorphic relations

## Authentication/Authorization Requirements

- Requires JWT/session/API key authentication
- Admin role with specific permissions for catalog management and reindex operations
- Enforce RBAC checks via middleware
- Additional guards: active user, email-verified, 2FA if enabled, branch scope
- Reject unauthorized requests with 403 Forbidden

## Expected Request/Response Format Considerations

- **Request:** No body required (empty POST). Headers: Authorization, Accept: application/json, Content-Type: application/json
- **Response (Success):** 202 Accepted or 200 OK with JSON body, e.g., {""message"": ""Reindex initiated"", ""job_id"": ""uuid""} if async
- **Response (Error):** 4xx/5xx with RFC7807 problem+json, e.g., {""title"": ""Forbidden"", ""detail"": ""Admin access required"", ""status"": 403}
- Versioned via content-negotiation, locale/tz aware, request-id for tracing
- Idempotency: Support key in header to allow safe retries

## Relevant Business Logic

- Reindex all active products, respecting soft deletes and archival
- Include related entities: categories, vendors, attributes (EAV), media, barcodes, pricing overrides, promotions
- Ensure index rebuild accounts for inventory batches, reservations, and stock movements if tied to products
- Trigger post-reindex: Update caches, etags, and potentially notify via webhooks if search impacts orders/promos
- Comply with observability: Log events, metrics on index size/time, PII masking if applicable
- Align with reporting: Ensure indexed data supports analytics like product search trends or low stock alerts
- Use state machines if reindex involves transitional states; prevent concurrent reindexes via locks"
254,catalog,Suggest Keywords,Autosuggest terms,api/catalog/suggest,get,Employee,Implement Catalog Suggest Keywords API (GET /api/catalog/suggest),"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint provides autosuggest terms for the catalog domain, enabling search and discovery of products, categories, and related entities in the Deshio ERP system.

## API Specifications

- **Category:** catalog
- **Title:** Suggest Keywords
- **Description:** Autosuggest terms
- **Route:** api/catalog/suggest
- **HTTP Method:** GET
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the endpoint to handle GET requests for autosuggesting catalog-related terms (e.g., products, categories, vendors)
- [ ] Validate input parameters, such as query string for search term, limit, and optional filters
- [ ] Ensure responses are returned in JSON format with relevant suggestions
- [ ] Apply proper authentication and authorization for Employee users
- [ ] Handle edge cases like empty queries, no results, and rate limiting
- [ ] Write unit and integration tests covering success, error, and validation scenarios
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger)
- [ ] Verify integration with search/autosuggest features in the catalog module
- [ ] Ensure compliance with middleware stack, including RBAC checks and caching/etag

## Technical Requirements

- Develop in Laravel: Create a dedicated controller (e.g., CatalogSuggestController) and register the route in api.php with prefix 'api/catalog/suggest'
- Use Eloquent models for querying catalog entities (product, category, vendor) with EAV attributes
- Implement search logic using Laravel Scout or database full-text search for efficient autosuggestions
- Add request validation using FormRequest classes for query parameters (e.g., 'q' for term, 'limit' default 10, 'type' for entity filters)
- Incorporate proper error handling with RFC7807 problem+json for validation errors, unauthorized access, or server issues
- Leverage state machines if needed for entity states, though primarily read-only for suggestions
- Ensure UTC handling and soft deletes are respected in queries
- Integrate with observability: Log requests with request-id, audit events for searches if applicable
- Optimize for performance: Use caching (e.g., Redis) for frequent suggestions and etag for conditional responses

## Authentication/Authorization Requirements

- Require Employee authentication via JWT, session, or API key
- Enforce RBAC: Users must have permissions for catalog read access (e.g., 'catalog.view')
- Apply middleware chain: auth, active user, email-verified, 2FA (if enabled), RBAC & permission checks, branch scope
- For Employee role, ensure multi-role support via user_role junction and ability mappings
- Reject unauthenticated or unauthorized requests with 401/403 status and appropriate error details

## Expected Request/Response Format Considerations

- **Request:** GET /api/catalog/suggest?q={search_term}&limit={integer}&type={entity_type} (e.g., product, category)
  - All params optional; 'q' required for meaningful results
  - Use content-negotiation for JSON; support versioning (e.g., /v1/api/catalog/suggest)
  - Sanitize inputs to prevent injection; apply throttles and idempotency if extended

- **Response:** 200 OK with JSON array of suggestions, e.g., {""suggestions"": [{""id"": 1, ""term"": ""laptop"", ""type"": ""product"", ""score"": 0.95}, ...]}
  - Include metadata like total count, took time for analytics
  - Empty results: {""suggestions"": [], ""message"": ""No suggestions found""}
  - Errors: RFC7807 format, e.g., {""type"": ""validation_error"", ""title"": ""Invalid query"", ""detail"": ""Query too short""}
  - Set cache headers and etag for client-side optimization
  - PII masking if suggestions include customer-related terms (unlikely for catalog)

## Relevant Business Logic

- Autosuggest should prioritize popular/recently searched terms in catalog (products, categories, vendors) using relevance scoring
- Respect inventory visibility: Suggest only active, in-stock items if branch-scoped
- Integrate with promotions/pricing: Optionally highlight suggested terms with active promos or overrides
- Support polymorphic relations if suggestions extend to related entities (e.g., barcodes, attributes)
- Ensure determinism: Use consistent sorting (e.g., by score, name) for reproducible results
- Align with reporting: Track suggestion usage for analytics like search trends and promo impact
- Handle conflicts gracefully: If search fails due to domain guards, return problem+json without exposing internals
- Enable bulk/search features: This endpoint supports autosuggest as part of broader catalog search APIs"
255,monitoring,Health,Service health,api/health,get,nan,Implement Health Check API Endpoint for Monitoring,"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint provides service health monitoring for the Deshio ERP system, allowing checks on system status, database connectivity, queue health, and other critical components to ensure operational reliability.

## API Specifications

- **Category:** monitoring
- **Title:** Health
- **Description:** Service health
- **Route:** api/health
- **HTTP Method:** get
- **Authentication:** nan

## Acceptance Criteria

- [ ] Implement the GET /api/health endpoint in Laravel
- [ ] Ensure the endpoint returns a JSON response indicating overall system health (e.g., status: 'ok', components: {db: 'healthy', queue: 'healthy', etc.})
- [ ] Handle cases where components are unhealthy by returning appropriate status codes (e.g., 503 for service unavailable)
- [ ] Add unit and integration tests for the endpoint, covering healthy and unhealthy scenarios
- [ ] Verify no authentication is required, making it publicly accessible
- [ ] Include observability: log requests with request-id, add metrics for health checks
- [ ] Ensure response complies with content-negotiation and caching/etag as per middleware plan
- [ ] Test for proper error handling using RFC7807 problem+json for any conflicts
- [ ] Confirm data in UTC and no PII exposure

## Technical Requirements

- Use Laravel controller (e.g., HealthController) and define route in api.php
- Integrate with Laravel's built-in health checks or custom logic for database, cache, queue, and service status
- Apply relevant middleware: RequestId, JSON limits, versioned content-negotiation, locale/tz, throttles, cache headers; skip auth, RBAC, etc., since authentication is 'nan'
- Input validation: None required as it's a GET with no parameters, but add idempotency if needed
- Proper error handling: Use try-catch for component checks, return 200 for healthy, 5xx for issues
- Observability: Emit metrics for health check invocations, log events in audit_event if applicable
- Security: Ensure TLS/HSTS, CORS if needed, no input sanitizer required
- Testing: Include tests for state machines if health affects transitions, but primarily focus on endpoint isolation
- Integration: Align with queues, caching/etag, health/metrics from observability features

## Authentication/Authorization Requirements

- No authentication required ('nan'), endpoint should be accessible without JWT, session, or API key
- Skip middleware like auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope
- However, apply general security middleware: TLS/HSTS, CORS, domain guards if applicable

## Expected Request/Response Format Considerations

- **Request:** GET /api/health (no body, optional query params for specific checks if extended)
- **Response:** JSON object, e.g., {""status"": ""ok"", ""components"": {""database"": ""healthy"", ""queue"": ""healthy"", ""timestamp"": ""UTC ISO""}}; use problem+json for errors
- Ensure versioned responses, ETag for caching if static
- No soft deletes or EAV involved; keep response lightweight

## Relevant Business Logic

- Health check should verify core services: database connectivity, queue processing, cache availability, external integrations (e.g., carriers if critical)
- Align with observability & compliance: Include request-id in logs, mask any PII (none expected)
- Support system maintenance: Endpoint should work during backups/restore, reindex
- If unhealthy, prevent state transitions in orders, payments, etc., via domain guards
- Deterministic: Always return consistent status based on current system state
- No impact on ledger posting or stock movements; purely monitoring"
256,monitoring,Metrics,Operational metrics,api/metrics,get,Admin,Implement GET /api/metrics for Operational Metrics (Monitoring),"## Overview

This GitHub issue is for implementing the Metrics API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring approximately 290 REST APIs built over a normalized ERD. The ERD covers key domains including catalog (products/categories/vendors with attributes, media, barcodes, pricing, promotions), stores/branches, customers (with tags/blacklist), inventory (batch-centric with reservations, adjustments, cycle counts, valuation, ledgers), orders (order/order_item states: pending→confirmed→fulfilled|cancelled, assignment to store, notes/attachments, promos, taxes, fraud flag), fulfillment (shipments/shipment_item, inter-store dispatch with tracking/scan events/POD, transactional stock movements), returns (RMA/return_item, receive/restock/scrap, refunds, exchanges), payments (intent→payment capture/void, refund lifecycle, order.payment_status sync), accounting (transaction headers + ledger_entry lines, reversals, reconciliation/export), services (service/service_order lifecycle/profitability), integrations (carriers/accounts, waybills/rates/tracking, webhooks, notification templates), security/identity (user/role/permission with abilities, multi-role, sessions, email verification, password reset, TOTP MFA + backup codes, API keys), observability/compliance (audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag), reporting/analytics (revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity).

Inventory supports optional per-unit items; order domain includes state machines for transitions (conflicts return RFC7807 problem+json); fulfillment involves safe reservation/consumption and ledger posting; data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, strict referential integrity. Middleware stack includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC/permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures/replay defense, cache headers. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Design ensures deterministic admin assignment, consistent ledger posting on stock/financial events.

The Metrics endpoint provides operational metrics, aligning with observability features like health/metrics, queues, and caching/etag, to support monitoring system performance, compliance, and analytics (e.g., revenue, inventory aging, SLA).

## API Specifications

- **Category:** monitoring
- **Title:** Metrics
- **Description:** Operational metrics
- **Route:** api/metrics
- **HTTP Method:** GET
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET /api/metrics endpoint in Laravel controller and routes
- [ ] Ensure endpoint requires Admin authentication and RBAC permission checks
- [ ] Return comprehensive operational metrics in JSON format (e.g., health status, queue stats, cache hits, performance metrics, analytics aggregates like revenue/orders by store/product)
- [ ] Handle errors per RFC7807 problem+json for unauthorized access, server errors, or metric computation failures
- [ ] Include middleware for RequestId, throttling, cache headers, and observability (audit_event, log)
- [ ] Support versioned content-negotiation and locale/tz if applicable
- [ ] Write unit/integration tests covering successful responses, auth failures, error cases, and metric accuracy
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger) including response schema
- [ ] Verify integration with existing observability (health/metrics, queues, etag) and reporting features
- [ ] Ensure PII masking in any customer-related metrics and soft-delete compliance
- [ ] Test for performance under load, aligning with throttles and idempotency

## Technical Requirements

- Use Laravel framework: Define route in api.php, create dedicated MetricsController with index() method
- Integrate with Laravel's built-in metrics (e.g., Telescope, Horizon for queues) or custom collectors for health (uptime, DB connections), metrics (audit events, log volume), queues (job counts, failures), caching (hit/miss ratios, etag usage)
- Aggregate data from ERD entities (e.g., orders for revenue/AOV, inventory for aging/low stock, dispatches for SLA/performance, cycles for accuracy, promos for impact) using Eloquent queries or raw SQL for efficiency
- Apply state machines if metrics involve order/dispatch/return/payment states; ensure deterministic computations
- Handle bulk data efficiently (e.g., pagination or summaries for large datasets like activity logs)
- Implement input sanitizer and domain guards if query params are added (e.g., date ranges for metrics)
- Use UTC timestamps; support soft deletes in queries (e.g., exclude deleted records)
- Add observability: Log requests with request-id, emit audit_event for endpoint access, apply PII masking
- Follow middleware plan: Auth (JWT/API key), RBAC, active user, email-verified, 2FA if session-based, branch scope, throttles
- For response: Use JSON API format, include etag for caching, version header
- Error handling: Return 401/403 for auth issues, 500 for internal errors with problem+json
- Testing: PHPUnit for controller logic, feature tests for full flow, mock metrics sources
- Deployment considerations: Ensure compatibility with queues, caching, and feature flags

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have 'admin' role or specific permission (e.g., 'view:metrics') via user_role and ability (role↔perm) checks
- Middleware: active user, email-verified, optional 2FA; branch scope if metrics are store-specific
- On failure: Return 401 Unauthorized or 403 Forbidden with problem+json details
- Audit access: Log audit_event for endpoint calls, including user_id and request-id

## Expected Request/Response Format Considerations

- **Request:** GET /api/metrics (no body; optional query params e.g., ?from=2023-01-01&to=2023-12-31&scope=store_id for filtering, with validation)
- **Response:** 200 OK with JSON object containing operational metrics, e.g.:
  {
    ""health"": { ""status"": ""healthy"", ""uptime"": ""99.9%"", ""db_connections"": 1 },
    ""queues"": { ""pending_jobs"": 5, ""failed_jobs"": 0 },
    ""caching"": { ""hits"": 1000, ""misses"": 50, ""etag_responses"": 200 },
    ""analytics"": {
      ""revenue_by_store"": { ""store1"": 10000 },
      ""inventory_aging"": { ""days_30"": 100 },
      ""sla_dispatch"": { ""on_time"": 95% }
    },
    ""meta"": { ""timestamp"": ""2023-10-01T00:00:00Z"", ""etag"": ""abc123"" }
  }
- Headers: Content-Type: application/json, ETag, Cache-Control
- Errors: RFC7807 problem+json, e.g. { ""type"": ""https://example.com/errors/unauthorized"", ""title"": ""Unauthorized"", ""status"": 401 }
- Consider bulk export format if metrics are large; support search/autosuggest if params allow

## Relevant Business Logic

- Metrics should reflect real-time or recent operational state, pulling from ledgers (stock/financial movements), audit_events, logs, queues, and analytics aggregates
- Ensure consistency: Post ledger_entry on events; use reservations for inventory metrics; sync payment_status for financials
- Compliance: Mask PII in customer metrics (e.g., anonymize in LTV/AOV); apply fraud flags in order metrics
- Performance: Use caching/etag for frequent calls; avoid heavy computations (e.g., pre-aggregate in jobs)
- Integrations: Include carrier tracking stats if applicable; webhook delivery metrics
- State-driven: Only include valid states (e.g., fulfilled orders in revenue); handle transitions via state machines
- Reporting alignment: Metrics should support views like return rates, promo impact, cycle accuracy, activity by user/store
- Edge cases: Handle zero-data (empty metrics), soft-deleted entities, timezone conversions, multi-branch scoping"
257,monitoring,Queue Stats,Background queue status,api/queues,get,Admin,Implement Queue Stats API Endpoint for Monitoring,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue covers the implementation of the Queue Stats API endpoint. Deshio handles core entities like product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment involves shipments, inter-store dispatch with tracking and scan events. Returns cover RMA with receive/restock/scrap, refunds, exchanges. Payments include intent→payment capture/void and refund lifecycle. Accounting features transaction headers + ledger_entry lines, reversals, reconciliation/export. Services include service/service_order with lifecycle and profitability. Integrations handle carriers, waybills/rates/tracking, webhooks, notification templates. Security & identity: user/role/permission with abilities, sessions, email verification, password reset, TOTP MFA + backup codes, API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive transitions for orders, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data in UTC; soft deletes; EAV for attributes; polymorphic notes/attachments; strict referential links. Design enables deterministic admin assignment, safe reservation/consumption, consistent ledger posting.

This endpoint provides background queue status, falling under the monitoring category to support observability features like health/metrics and queues.

## API Specifications

- **Category:** monitoring
- **Title:** Queue Stats
- **Description:** Background queue status
- **Route:** api/queues
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET /api/queues endpoint in a Laravel controller
- [ ] Ensure the endpoint returns comprehensive queue statistics, including job counts, failed jobs, processing times, and queue lengths
- [ ] Restrict access to admin users only, enforcing RBAC permissions
- [ ] Handle errors according to RFC7807 problem+json format for conflicts or invalid states
- [ ] Include proper middleware: auth (JWT/session/API key), RBAC checks, RequestId, throttles, cache headers
- [ ] Add unit and integration tests covering successful responses, authentication failures, and error scenarios
- [ ] Document the endpoint in API specs with request/response examples
- [ ] Verify integration with Laravel's queue system (e.g., using Horizon or built-in queue monitoring)
- [ ] Ensure response data is in UTC and respects soft deletes if applicable
- [ ] Test for idempotency and proper caching/etag support

## Technical Requirements

- Use Laravel framework: Create a dedicated controller (e.g., QueueController) and register the route in api.php
- Leverage Laravel's queue facade or Horizon for retrieving stats (e.g., Queue::size(), failed jobs table)
- Implement input validation: None required for GET, but validate any query parameters if added (e.g., ?queue=name)
- Proper error handling: Use try-catch for queue operations, return 4xx/5xx with problem+json
- Response formatting: JSON with fields like total_jobs, pending_jobs, failed_jobs, processing_time_avg, queue_names[]
- Integrate with observability: Log requests with request-id, audit events for access

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have admin role/permission for queue monitoring
- Apply middleware stack: auth, active user, email-verified, 2FA, RBAC & permission checks
- Optional: Branch scope if queues are scoped to branches

## Expected Request/Response Format Considerations

- **Request:** GET /api/queues (no body; optional query params like ?queue=high-priority for specific queue stats)
- **Response:** 200 OK with JSON body, e.g., {
  ""total_jobs"": 150,
  ""pending_jobs"": 50,
  ""failed_jobs"": 5,
  ""average_processing_time"": ""00:05:30"",
  ""queues"": [
    {""name"": ""default"", ""size"": 30, ""failed"": 2}
  ]
}
- Error Response: 401 Unauthorized or 403 Forbidden with problem+json, e.g., {
  ""type"": ""https://tools.ietf.org/html/rfc7231#section-6.5.1"",
  ""title"": ""Unauthorized"",
  ""status"": 401
}
- Headers: Include ETag for caching, X-Request-Id, Content-Type: application/json

## Relevant Business Logic

- Fetch real-time queue status to monitor background jobs for orders, inventory adjustments, payments, dispatches, etc.
- Support for multiple queues (e.g., default, high-priority for urgent orders)
- Align with state machines: Ensure queue stats do not expose sensitive transition states
- Integrate with reporting: Queue metrics can feed into SLA and performance analytics
- Compliance: Mask any PII in failed job details; use soft deletes for failed job records if applicable
- Idempotency: GET is inherently idempotent; ensure no side effects"
258,order,Generate Invoice,Create/Regenerate invoice PDF,api/orders/{id}/invoice,post,Employee,Implement Generate Invoice API for Orders,"## Overview

This GitHub issue is for implementing the 'Generate Invoice' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs built over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits.

Core entities include: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.

Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.

Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.

Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).

Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.

Services: service/service_order with lifecycle and profitability.

Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.

Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint creates or regenerates an invoice PDF for a given order, ensuring compliance with order states and accounting ledger postings.

## API Specifications

- **Category:** order
- **Title:** Generate Invoice
- **Description:** Create/Regenerate invoice PDF
- **Route:** api/orders/{id}/invoice
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint responds to POST requests on /api/orders/{id}/invoice
- [ ] Validates that the order exists and is in a valid state (e.g., confirmed) for invoice generation using state machines
- [ ] Generates invoice PDF including order details, items, pricing, taxes, promotions, and payments
- [ ] Handles regeneration for existing invoices
- [ ] Returns the PDF as a downloadable response or URL
- [ ] Applies RBAC permissions for employee authentication
- [ ] Includes audit logging for the generation event
- [ ] Handles errors with RFC7807 problem+json format for invalid states or permissions
- [ ] Tests cover successful generation, invalid order ID, unauthorized access, and state conflicts
- [ ] Integrates with middleware stack (auth, RBAC, branch scope, etc.)
- [ ] Ensures data in UTC and respects soft deletes

## Technical Requirements

- Implement in Laravel: Define route in api.php, create controller method in OrdersController
- Use Laravel's PDF generation library (e.g., DomPDF or similar) to render invoice from a Blade template
- Input validation: Ensure {id} is a valid order ID; optional body for customization (e.g., format options if needed)
- Authorization: Require 'employee' role with permissions for order invoice generation; use branch scope if order assigned to specific store
- Business logic: Check order state machine for eligibility (e.g., post-confirmation); post to accounting ledger if new invoice affects financials; include polymorphic attachments if notes present
- Request format: POST with optional JSON body (e.g., {""regenerate"": true}); path param {id}
- Response format: 200 OK with application/pdf content-type and binary PDF data; or 201 Created with download URL; errors as JSON problem details
- Error handling: 404 for non-existent order, 403 for unauthorized, 422 for validation, 409 for state conflicts
- Testing: Unit tests for controller logic, feature tests for full endpoint, integration with state machines and RBAC
- Observability: Log request-id, audit_event for generation, cache headers if applicable
- Security: Sanitize inputs, apply domain guards for order/fraud/payment; ensure PII masking in PDF if needed"
259,order,Get Invoice,Download invoice PDF,api/orders/{id}/invoice,get,Employee,Implement Get Invoice API Endpoint for Orders,"## Overview

This GitHub issue tracks the implementation of the 'Get Invoice' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain involves order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, and fraud flags. Fulfillment includes shipments and inter-store dispatches with tracking and stock movements. Returns handle RMAs, restocking, refunds, and exchanges. Payments manage intents, captures, voids, refunds, and order synchronization. Accounting uses transaction headers and ledger entries for movements, reversals, and reconciliation. Services cover service orders with lifecycle and profitability. Integrations include carriers, waybills, tracking, webhooks, and notifications. Security features user/role/permission with multi-role support, sessions, email verification, password reset, TOTP MFA, API keys. Observability includes audit events, logs, PII masking, health/metrics, queues, caching. Middleware encompasses TLS/HSTS, CORS, auth (JWT/session/API key), RBAC, branch scope, throttles, idempotency, sanitizers, guards for domains like order/payment/dispatch, and webhook defenses. Reporting/analytics cover revenue, LTV/AOV, return rates, SLA, inventory aging, promo impact. State machines ensure legal transitions for orders, shipments, returns, payments, cycle counts, with RFC7807 problem+json for conflicts. APIs support bulk import/export, search, attachments, reindex, backups, feature flags, maintenance. Data is in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, strict referential links. Design supports deterministic admin assignment, safe reservations, consistent ledger posting.

The endpoint allows downloading the invoice PDF for a specific order, integrating with order domain logic for state validation and access control.

## API Specifications

- **Category:** order
- **Title:** Get Invoice
- **Description:** Download invoice PDF
- **Route:** api/orders/{id}/invoice
- **HTTP Method:** GET
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint returns a downloadable PDF invoice for valid order IDs
- [ ] Validates that the order exists and is in a state allowing invoice generation (e.g., confirmed or fulfilled)
- [ ] Applies RBAC to ensure only authenticated employees with appropriate permissions can access
- [ ] Handles errors with RFC7807 problem+json format for invalid IDs, unauthorized access, or order state issues
- [ ] Generates invoice PDF including order details, items, pricing, taxes, payments, and store/branch info
- [ ] Supports branch scope to restrict access based on employee's assigned branches
- [ ] Includes audit logging for invoice downloads
- [ ] Tests cover successful downloads, error cases, authentication failures, and permission denials
- [ ] Integrates with state machine to check order state legality
- [ ] Ensures idempotency and proper caching/ETag headers
- [ ] Validates input (order ID) with sanitization and domain guards

## Technical Requirements

- Implement in Laravel: Define route in api.php, create controller method in OrderController or InvoiceController
- Use path parameter {id} for order ID, validate as UUID or integer via FormRequest
- Generate PDF using a library like DomPDF or Laravel Snappy, pulling data from order, order_items, pricing, taxes, payments, customer, store entities
- Handle soft deletes: Ensure query includes withTrashed() if needed, but typically only active orders
- Integrate with EAV attributes for custom fields in invoice (e.g., product features)
- Post to accounting ledger if invoice generation triggers any financial events (e.g., finalization)
- Use middleware stack: Auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks (e.g., 'view-order-invoice'), branch scope
- Add request ID, JSON limits, versioned content-negotiation, locale/tz awareness (format dates in user TZ)
- For PDF response: Set Content-Type: application/pdf, Content-Disposition: attachment; filename=""invoice-{id}.pdf""
- Error handling: 404 for non-existent order, 403 for unauthorized, 422 for invalid state, with problem+json
- Observability: Log request with request-id, audit_event for download action, PII masking for customer data in logs
- Testing: Unit tests for controller logic, feature tests for full endpoint, integration with state machine and RBAC
- Documentation: Update API docs with OpenAPI spec, examples
- Edge cases: Handle polymorphic attachments/notes on order, promotions/taxes in PDF, multi-store orders

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- RBAC: User must have role with permission like 'order:view-invoice' or similar ability
- Multi-role support: Check all user roles for permission
- Branch scope: Employee can only access orders assigned to their branches/stores
- Optional: Tenancy if multi-tenant setup, email verification, 2FA enforcement
- Guards against fraud-flagged orders if policy restricts invoice access

## Expected Request/Response Format Considerations

- **Request:** GET /api/orders/{id}/invoice
  - Path param: id (order ID, e.g., UUID)
  - Headers: Authorization (Bearer/JWT), Accept: application/pdf, X-Branch-Id (for scope if needed)
  - No body

- **Response (Success - 200):** Binary PDF stream
  - Content-Type: application/pdf
  - Content-Disposition: attachment; filename=""invoice-{order_number}.pdf""
  - Body: PDF bytes containing invoice details (order summary, items with barcodes/pricing/promos, totals, payments, timestamps in UTC but displayed in locale TZ)

- **Response (Error - e.g., 404/403/422):** JSON with RFC7807 format
  - Example: {""type"":""https://example.com/probs/order-not-found"",""title"":""Order not found"",""status"":404,""detail"":""The specified order does not exist""}

- Considerations: Use ETag for caching if PDF is static post-generation; support range requests for large PDFs; ensure no PII exposure in errors

## Relevant Business Logic

- Invoice generation only for orders in confirmed/fulfilled states (use state machine to validate transition legality)
- Include all order elements: items with attributes/media (e.g., product images if applicable), pricing overrides, promotions, taxes, shipment details if fulfilled, payment status
- Sync with payments: Show captured payments, refunds if any; flag if payment_status is not synchronized
- Handle returns/exchanges: If RMA linked, note adjustments in invoice
- Stock movements: Reference any dispatch/shipment tracking or POD events
- Compliance: Include audit trail references, ensure ledger entries are reflected (e.g., revenue recognition)
- Customizations: Use EAV for product/category attributes in PDF; polymorphic notes/attachments if relevant
- International: Format currencies, dates per locale/tz; support multi-store branding
- Security: Mask PII in PDF if configured (e.g., partial customer info); prevent replay via idempotency if re-download
- Integrations: Optionally trigger webhook for invoice generation if subscribed; use notification templates for related emails"
260,order,Apply Tax,Apply tax profile,api/orders/{id}/apply-tax,post,Employee,Implement POST /api/orders/{id}/apply-tax Endpoint,"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.
Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This issue is for implementing the 'Apply Tax' API endpoint in the order category, which applies a tax profile to a specific order.

## API Specifications

- **Category:** order
- **Title:** Apply Tax
- **Description:** Apply tax profile
- **Route:** api/orders/{id}/apply-tax
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint handles POST requests to apply a tax profile to the specified order
- [ ] Validates that the order exists and is in a valid state for tax application (e.g., pending or confirmed)
- [ ] Applies the tax profile, recalculates taxes on order items, and updates order totals
- [ ] Returns the updated order with applied taxes or an error if application fails
- [ ] Integrates with state machine to ensure legal transition for tax application
- [ ] Includes proper audit logging for the tax application event
- [ ] Handles edge cases like invalid tax profiles or orders with existing taxes
- [ ] Unit and integration tests cover success, failure, and validation scenarios
- [ ] Endpoint respects middleware stack including auth, RBAC, and branch scope

## Technical Requirements

- Implement in Laravel: Define route in api.php, create or update OrdersController with applyTax method
- Use Eloquent models for Order and related entities (e.g., OrderItem, TaxProfile)
- Input validation using FormRequest or Validator: Require order ID in path, optional tax profile ID in body
- Error handling: Return RFC7807 problem+json for conflicts, validation errors, or unauthorized access
- Business logic: Fetch order, verify state via state machine, apply tax profile to items, recalculate totals (including promos/taxes), post to accounting ledger if needed, save changes transactionally
- Ensure data consistency: Use database transactions for updates, handle soft deletes if applicable
- Observability: Generate audit_event, log with request-id, apply PII masking
- Performance: Use caching/etag if order data is cached, respect throttles and idempotency

## Authentication/Authorization Requirements

- Requires Employee authentication (JWT/session/API key)
- RBAC check: User must have permission to modify orders (e.g., 'order.update' ability via role/permission)
- Active user, email-verified, 2FA if enabled
- Branch scope: Employee must be scoped to the order's assigned store/branch
- Optional tenancy if multi-tenant setup is active

## Expected Request/Response Format Considerations

- **Request:** JSON body with tax_profile_id (required, integer), optional fields like effective_date
  Example: {""tax_profile_id"": 1}
- **Response:** 200 OK with updated order JSON (including recalculated taxes and totals), or 4xx/5xx with problem+json
  Example success: {""data"": {order object with taxes applied}}
- Use versioned content-negotiation, locale/tz handling, JSON limits
- Idempotency: Support idempotency keys to prevent duplicate tax applications

## Relevant Business Logic

- Tax application integrates with order domain: Updates taxes on order_items based on tax profile rules (e.g., rates by category/location)
- Sync with payments if order is paid (may require recalculation or refund adjustments)
- State machine: Only allow if order state permits (e.g., before fulfillment, not cancelled)
- Accounting: Post ledger_entry for tax changes as transaction lines
- Conflicts: If promo or pricing overrides exist, resolve or error per business rules
- Ensure UTC storage, polymorphic attachments if notes added during tax apply"
261,order,Remove Tax,Remove tax profile,api/orders/{id}/remove-tax,post,Employee,Implement API: Remove Tax from Order (POST /api/orders/{id}/remove-tax),"## Overview

This GitHub issue is for implementing the 'Remove Tax' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD that covers catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing (including price overrides), promotions; stores/branches; customers with tags/blacklists. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers.

In the order domain, orders and order_items have states (pending→confirmed→fulfilled|cancelled), assignment to stores, notes/attachments, promotions, taxes, and fraud flags. This endpoint allows removing the tax profile from a specific order, which may involve recalculating totals, updating order states via state machines, ensuring transactional consistency, and posting to accounting ledgers if applicable. Fulfillment involves shipments and inter-store dispatches with stock movements; returns handle RMAs with restocking/refunds/exchanges; payments sync with order.payment_status. Accounting uses transaction headers and ledger entries for all movements, including reversals and reconciliation.

Services include service orders with lifecycle and profitability. Integrations cover carriers, webhooks, and notifications. Security features user/role/permission RBAC, sessions, email verification, password reset, TOTP MFA, API keys. Observability includes audit events, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware encompasses TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC/permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards (for order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures, cache headers.

Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines enforce legal transitions for orders, items, dispatches, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, strict referential links. Design ensures deterministic admin assignment, safe reservation/consumption, consistent ledger posting on stock/financial events.

The endpoint removes the tax profile from an order, integrating with order state machines, tax calculations, and potentially triggering ledger updates or notifications.

## API Specifications

- **Category:** order
- **Title:** Remove Tax
- **Description:** Remove tax profile
- **Route:** api/orders/{id}/remove-tax
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST endpoint at api/orders/{id}/remove-tax to remove the tax profile from the specified order
- [ ] Ensure the endpoint authenticates as an Employee user with appropriate RBAC permissions (e.g., permission to modify orders and taxes)
- [ ] Validate that the order exists and is in a state allowing tax removal (e.g., pending or confirmed, per state machine rules)
- [ ] Handle tax removal by nullifying the tax profile, recalculating order totals (subtotal, taxes, grand total), and updating related fields like promos or payments if impacted
- [ ] Integrate with state machines to validate and transition order state if necessary; return RFC7807 problem+json for invalid transitions
- [ ] Post accounting ledger entries for the tax removal event, ensuring transactional consistency with soft deletes and UTC timestamps
- [ ] Apply middleware: auth (Employee via JWT/session/API key), RBAC/permission checks, branch scope (if order assigned to a branch), throttles, idempotency, input sanitizer, domain guards for order/tax/promo
- [ ] Log audit_event for the action, mask any PII, and include request-id
- [ ] Return success response with updated order details; handle errors (e.g., 404 for non-existent order, 403 for unauthorized, 422 for validation failures)
- [ ] Write unit/integration tests covering happy path, edge cases (e.g., order in fulfilled state, no tax profile), error scenarios, and RBAC enforcement
- [ ] Ensure compatibility with bulk operations, search/autosuggest, and reporting (e.g., update price change history if taxes affect totals)
- [ ] Document the endpoint in API specs, including any webhooks triggered (e.g., for payment sync)

## Technical Requirements

- Use Laravel framework: Define route in api.php, create dedicated controller method (e.g., OrderController@removeTax) with dependency injection for Order model, Tax service, StateMachine, and LedgerPoster
- Implement input validation: {id} as UUID/integer (order ID), no request body expected (or optional params like reason for audit); use FormRequest for validation, sanitize inputs
- Business logic: Fetch order with relations (order_items, taxes, payments); check state via state machine; remove tax_profile_id or set to null; recalculate taxes/totals using Pricing/Promo services; consume/reserve stock if impacted; post to accounting (transaction header + ledger_entry for tax reversal); handle conflicts with optimistic locking/etag
- Error handling: Use try-catch for exceptions, return standardized JSON errors per RFC7807; soft delete any related tax records if applicable; ensure referential integrity
- Authentication/authorization: Require Employee auth; check user_role for permissions (e.g., 'orders.edit', 'taxes.manage'); enforce branch scope if order.store_id restricts access; optional 2FA for sensitive actions
- Expected request/response formats: Request - POST with JSON body if needed (e.g., {""reason"": ""string""}), headers for auth/locale/tz/idempotency-key; Response - 200 OK with JSON { ""order"": {updated order object with taxes removed, totals recalculated} }, or error JSON; use content-negotiation for versioned API (e.g., v1)
- Integrations: Trigger webhooks for order updates (e.g., to payments for status sync); notify via templates (email/SMS) if configured; update caches with etag; queue heavy tasks like ledger posting or reporting indexes
- Testing: PHPUnit tests for controller, services, state transitions; feature tests for full endpoint flow; cover RBAC (authorized/unauthorized users), middleware (throttles, guards), and observability (audit logs)
- Deployment considerations: Ensure idempotency for retries; add feature flag if experimental; monitor via health/metrics for performance"
262,order,Set Payment Method,Set payment method,api/orders/{id}/payment-method,post,Employee,Implement API: Set Payment Method for Orders (POST /api/orders/{id}/payment-method),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, implement the 'Set Payment Method' endpoint in the order category. This endpoint allows setting the payment method for a specific order, integrating with the payments domain which handles intent→payment capture/void, refund lifecycle, and order.payment_status synchronization. Core entities include orders with states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, and fraud flags. Inventory is batch-centric with reservations, adjustments, and ledgers. Fulfillment involves shipments and inter-store dispatches with transactional stock movements. Returns use RMA with receive/restock/scrap, refunds, and exchanges. Accounting features transaction headers + ledger_entry lines for all movements, reversals, and reconciliation/export. Services include service/service_order lifecycle and profitability. Integrations cover carriers, waybills/rates/tracking, webhooks, and notification templates. Security & identity: user/role/permission with abilities, multi-role support, sessions, email verification, password reset, TOTP MFA + backup codes, API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, payments, etc.; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data in UTC; soft deletes; EAV for attributes; polymorphic notes/attachments; strict referential links. Design enables deterministic admin assignment, safe reservation/consumption, consistent ledger posting on stock/financial events.

This endpoint sets the payment method for an order, ensuring synchronization with payment status and adhering to business rules like order state transitions and RBAC.

## API Specifications

- **Category:** order
- **Title:** Set Payment Method
- **Description:** Set payment method
- **Route:** api/orders/{id}/payment-method
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint handles POST requests to set payment method for a valid order ID
- [ ] Validates that the order exists and is in an allowable state (e.g., pending) for payment method setting
- [ ] Authenticates and authorizes only Employee roles via RBAC
- [ ] Updates order's payment method and synchronizes payment_status if needed
- [ ] Integrates with state machines to ensure legal transitions; returns RFC7807 problem+json on conflicts
- [ ] Logs audit events for the change
- [ ] Handles errors like invalid order ID, unauthorized access, or invalid payment method with appropriate HTTP status codes
- [ ] Includes unit and integration tests covering success, validation failures, auth failures, and edge cases
- [ ] Endpoint is protected by middleware: auth, RBAC, branch scope, idempotency, input sanitizer, domain guards for order/payment
- [ ] Supports soft deletes and referential integrity

## Technical Requirements

- Implement in Laravel: Define route in api.php, create controller method in OrdersController or PaymentController
- Use Eloquent models for Order and related PaymentMethod entity; ensure UTC handling
- Input validation: Use FormRequest for request body (e.g., payment_method_id, type); sanitize inputs
- Business logic: Check order state via state machine; update payment intent if applicable; post ledger entries if financial impact; handle reservations/promos/taxes synchronization
- Error handling: Return JSON errors with problem+json for conflicts; use HTTP 4xx/5xx appropriately (e.g., 404 for order not found, 403 for unauthorized, 422 for validation)
- Observability: Generate request-id, audit_event, log changes; apply PII masking if needed
- Testing: PHPUnit tests for controller, validation, auth; feature tests for full flow; mock state machines and RBAC
- Documentation: Add OpenAPI spec entry; include in API versioned content-negotiation
- Integrations: Ensure compatibility with payments domain (intent capture/void), webhooks for notifications

## Authentication/Authorization Requirements

- Requires Employee authentication (JWT/session/API key)
- RBAC check: User must have role with permission for order payment management (e.g., 'orders.update.payment')
- Middleware: active user, email-verified, 2FA if enabled, branch scope (order assigned to user's branch)
- Optional: Tenancy if multi-tenant setup

## Expected Request/Response Format Considerations

- **Request:** JSON body, e.g., {""payment_method_id"": 1, ""type"": ""credit_card"", ""details"": {...}} – Validate required fields, types; support idempotency key in header
- **Response:** On success, 200 OK with updated order JSON (include payment_method, payment_status); minimal fields per etag/caching
- **Errors:** 4xx/5xx with RFC7807 problem+json, e.g., {""type"": ""https://example.com/probs/order-invalid-state"", ""title"": ""Invalid State"", ""status"": 422, ""detail"": ""Payment method can only be set on pending orders""}
- Content negotiation: JSON only; versioned (e.g., /v1/); locale/tz from headers
- Headers: Cache-Control, ETag for responses; X-Request-Id

## Relevant Business Logic

- Order must be in pending/confirmed state; use state machine to validate/enforce transition
- Payment method links to available providers (e.g., credit_card, cash, wallet); may trigger intent creation
- Synchronize order.payment_status (e.g., to 'method_set' or 'pending_payment')
- If promo/tax affected, recalculate; flag fraud if suspicious
- Transactional: Use DB transactions for consistency; post to accounting ledger for any financial setup
- Audit: Record change in audit_event with user_id, timestamp, diff
- Conflicts: e.g., if already paid, prevent change; return problem+json"
263,order,Mark Paid,Mark order as paid (offline),api/orders/{id}/mark-paid,post,Employee,Implement Mark Paid Endpoint for Orders API (Offline Payments),"## Overview

This GitHub issue is for implementing the 'Mark Paid' API endpoint in the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD. The endpoint allows marking an order as paid for offline payment scenarios, updating the order's payment status while ensuring compliance with state machines for order and payment transitions. Core entities involved include orders, order_items, and payments, with features like states (pending→confirmed→fulfilled|cancelled), promos, taxes, and synchronization of order.payment_status. Inventory, fulfillment (shipments, dispatches), returns (RMA), accounting (ledger entries), and security (RBAC, audits) are interconnected. Data is stored in UTC, uses soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential links. Design supports deterministic admin assignment, safe reservation/consumption, and consistent ledger posting on financial events. Middleware includes auth (JWT/session/API key), RBAC, branch scope, idempotency, input sanitizer, and domain guards for order/payment events. State machines enforce legal transitions, with conflicts returning RFC7807 problem+json. APIs support bulk operations, search, attachments, and system maintenance.

## API Specifications

- **Category:** order
- **Title:** Mark Paid
- **Description:** Mark order as paid (offline)
- **Route:** api/orders/{id}/mark-paid
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint successfully marks a valid order as paid for offline payments, updating payment_status to 'paid'
- [ ] Validates order ID exists and is in a state allowing payment (e.g., confirmed, not already paid/cancelled)
- [ ] Integrates with state machine to enforce legal transitions for order and payment states
- [ ] Posts ledger entries for the payment transaction and synchronizes order.payment_status
- [ ] Handles authorization: Only authenticated employees with appropriate RBAC permissions (e.g., order payment management) can access
- [ ] Returns RFC7807 problem+json for invalid states, unauthorized access, or conflicts
- [ ] Includes audit_event logging for the action with request-id and PII masking
- [ ] Supports idempotency to prevent duplicate markings
- [ ] Writes unit/integration tests covering success, validation errors, auth failures, and edge cases (e.g., already paid order)
- [ ] Documents the endpoint in API specs with examples
- [ ] Ensures compatibility with middleware: TLS/HSTS, CORS, versioned content-negotiation, locale/tz, active user, email-verified, 2FA, branch scope, throttles, cache headers

## Technical Requirements

- Implement in Laravel: Define route in api.php, create controller method in OrdersController (or PaymentsController if applicable)
- Use Request validation: Require order ID as path param; optional body for notes/attachments; sanitize inputs
- Business Logic: Check order state via state machine; if valid, transition payment to 'paid', create transaction header + ledger_entry for the payment (capture equivalent for offline); reverse any pending reservations if needed; flag fraud if applicable; sync with fulfillment/returns if order is partially fulfilled
- Authentication/Authorization: Use Employee auth (JWT/session/API key); enforce RBAC via user/role/permission (ability checks for 'mark-order-paid'); scope to branch/store if multi-tenant; optional TOTP MFA
- Expected Request Format: POST api/orders/{id}/mark-paid with JSON body (e.g., {""notes"": ""Offline cash payment"", ""amount"": 100.00}); support attachments upload with mime guard
- Expected Response Format: 200 OK with updated order JSON (including payment_status, ledger summary); 4xx/5xx with problem+json (e.g., {""type"": ""https://example.com/probs/out-of-state"", ""title"": ""Order cannot be marked paid"", ""detail"": ""Order is already fulfilled""})
- Error Handling: Domain guards for payment events; replay defense if idempotent; queue ledger posting if async; handle soft deletes (exclude archived orders)
- Integrations: Trigger webhooks for payment events; update related entities (e.g., shipments if paid enables fulfillment); ensure transactional stock movements if inventory affected
- Observability: Log audit_event, metrics for SLA; support reporting (e.g., payment history in analytics)
- Testing: Cover state transitions, RBAC denials, input validation, concurrency (idempotency), and integration with accounting/fulfillment"
264,order,Packing List,Generate packing list,api/orders/{id}/packing-list,get,Employee,Implement GET /api/orders/{id}/packing-list for Packing List Generation,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue focuses on implementing the Packing List API endpoint. Deshio handles core entities such as products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, and fraud flags. Fulfillment involves shipments (shipment/shipment_item) and inter-store dispatches with tracking, scan events, and POD, ensuring transactional stock movements. Returns are managed via RMA (return/return_item) with receive/restock/scrap, refunds, and exchanges. Payments follow intent→capture/void lifecycles with refund synchronization. Accounting uses transaction headers and ledger entries for all movements, including reversals and reconciliation. Services include service orders with lifecycle and profitability. Integrations cover carriers, waybills, rates, tracking, webhooks, and notifications (email/SMS). Security features user/role/permission with abilities, multi-role assignments, sessions, email verification, password reset, TOTP MFA, API keys. Observability includes audit events, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware encompasses TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC/permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures, replay defense, cache headers. Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines enforce legal transitions for orders, items, dispatches, shipments, returns, payments, cycle counts, with conflicts returning RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, strict referential links. Design ensures deterministic admin assignment, safe reservation/consumption, consistent ledger posting.

This endpoint generates a packing list for a specific order, aiding in fulfillment and shipment preparation by listing order items, quantities, and relevant details like barcodes, batch info, store assignment, and any notes/attachments.

## API Specifications

- **Category:** order
- **Title:** Packing List
- **Description:** Generate packing list
- **Route:** api/orders/{id}/packing-list
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET endpoint to generate a packing list for the specified order ID
- [ ] Ensure the endpoint only responds to authenticated Employee users with appropriate RBAC permissions
- [ ] Validate that the order exists and is in a fulfillable state (e.g., confirmed, not cancelled)
- [ ] Generate packing list data including order items, quantities, product details (name, barcode, attributes), batch/inventory info, store/branch assignment, shipment details if applicable, notes/attachments, and any promotions/taxes
- [ ] Handle errors appropriately, returning RFC7807 problem+json for invalid states, permissions, or non-existent orders
- [ ] Support content negotiation for response format (e.g., JSON data or PDF generation if applicable)
- [ ] Add unit and integration tests covering success, error cases, authentication, and business logic
- [ ] Ensure integration with state machines for order fulfillment legality
- [ ] Verify transactional consistency for any related stock reservations or ledger postings if triggered
- [ ] Document the endpoint in API specs with examples

## Technical Requirements

- Use Laravel framework: Define route in api.php, create a dedicated controller method (e.g., OrderController@packingList)
- Implement input validation for {id} parameter (must be a valid order ID, exists in database)
- Leverage Eloquent models for Order, OrderItem, Product, InventoryBatch, Shipment, etc., with proper joins/relations
- Integrate with middleware stack: auth (JWT/session/API key), RBAC & permission checks (employee role with order read/fulfill permissions), branch scope, domain guards for order/reservation
- Use state machines to check order state validity for packing (e.g., confirmed and unfulfilled)
- Response should include packing list structure: e.g., JSON with sections for header (order ID, date, store), items (product info, qty to pack, batch), totals, instructions
- Consider generating printable format (e.g., via Laravel's PDF libraries like DomPDF if business requires)
- Handle soft deletes: Exclude deleted orders/items
- Ensure UTC handling and locale/tz awareness for dates
- Add audit_event logging for endpoint access
- Implement caching/etag if packing list data is static post-generation
- Proper error handling: 404 for non-existent order, 403 for unauthorized, 422 for validation, 503 for system issues

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- RBAC: User must have role/permission allowing order fulfillment access (e.g., 'view-packing-list' permission linked to employee role)
- Branch scope: Employee must be scoped to the order's assigned store/branch
- Active user, email-verified, and optional 2FA enforcement
- Idempotency and throttling to prevent abuse

## Expected Request/Response Format Considerations

- **Request:** GET /api/orders/{id}/packing-list
  - No body; {id} as path param (UUID or integer)
  - Headers: Authorization, Accept (application/json or application/pdf), X-Branch-Id if scoped

- **Response (Success - 200):** 
  - JSON: {
    ""order_id"": ""uuid"",
    ""store"": {""id"": ""uuid"", ""name"": ""string""},
    ""items"": [
      {""product"": {""id"": ""uuid"", ""name"": ""string"", ""barcode"": ""string""}, ""quantity"": 5, ""batch"": ""optional"", ""attributes"": {}}
    ],
    ""totals"": {""subtotal"": 100.00, ""tax"": 10.00},
    ""notes"": ""string"",
    ""generated_at"": ""utc-datetime""
  }
  - Or PDF binary if Accept header specifies

- **Error Responses:** RFC7807 problem+json, e.g., {
  ""type"": ""https://example.com/probs/order-not-found"",
  ""title"": ""Order not found"",
  ""status"": 404,
  ""detail"": ""Order with ID {id} does not exist""
}

## Relevant Business Logic

- Packing list generation occurs during fulfillment phase, post-order confirmation
- Include only unshipped/pending shipment items; reference reservations for stock availability
- If inter-store dispatch involved, include dispatch tracking/scan events
- Apply promotions/taxes for accurate item details; flag fraud if order has fraud flag
- Ensure consistency with ledger: No direct posting, but verify no conflicting adjustments/cycle counts
- Support attachments: Embed or link any order notes/images relevant to packing
- If order involves returns/exchanges, differentiate and exclude returned items
- Use EAV for dynamic product attributes in list; polymorphic relations for notes
- Enforce referential integrity: All items must link to valid products/inventory"
265,order,Picking List,Generate picking list,api/orders/{id}/picking-list,get,Employee,Implement Order Picking List API (GET /api/orders/{id}/picking-list),"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this endpoint generates a picking list for a specific order. The picking list aids in fulfillment by listing order items, quantities, locations, and batch details for efficient warehouse picking. Core entities involved include orders, order_items, inventory (batch-centric with reservations), stores/branches, and shipments. State machines ensure order is in a valid state (e.g., confirmed) for picking. Data is stored in UTC, with soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential integrity.

## API Specifications

- **Category:** order
- **Title:** Picking List
- **Description:** Generate picking list
- **Route:** api/orders/{id}/picking-list
- **HTTP Method:** GET
- **Authentication:** Employee

This endpoint is versioned via content-negotiation, uses JSON limits, and follows middleware stack: TLS/HSTS, CORS, RequestId, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, throttles, idempotency, input sanitizer, domain guards (order/reservation), cache headers. Errors return RFC7807 problem+json for conflicts, e.g., invalid order state.

## Acceptance Criteria

- [ ] Endpoint returns picking list for valid order ID when order is in confirmed state and user has picking permissions
- [ ] Validates order exists, is assigned to user's branch/store, and not already picked/shipped
- [ ] Includes order items with quantities, product details (name, SKU, barcode), batch/inventory locations, reservations
- [ ] Handles bulk items, promotions, taxes, notes/attachments if relevant to picking
- [ ] Returns 404 for non-existent order, 403 for unauthorized access or branch mismatch, 422 for invalid state
- [ ] Supports search/autosuggest for products if needed in response
- [ ] Integrates with audit_event for logging picking list generation
- [ ] Tested with soft-deleted orders (should not return), PII masking, and request-id tracing
- [ ] Response uses ETag for caching, with proper headers

## Technical Requirements

- Implement in Laravel: Define route in api.php, create controller method (e.g., OrderController@pickingList)
- Use Eloquent models: Order, OrderItem, Product, InventoryBatch, Store/Branch with relations (e.g., order->items->product->batches)
- Input validation: Ensure {id} is UUID/integer via Route Model Binding, validate order state via state machine
- Proper error handling: Use try-catch for DB queries, return standardized JSON errors with RFC7807
- Business logic integration: Fetch available batches for picking (considering reservations, adjustments, cycle counts); support inter-store dispatch if applicable; post ledger_entry for any movements if picking triggers consumption
- Observability: Log to audit_event/log, include health/metrics for endpoint performance; use queues if generation is heavy
- Testing: Unit tests for controller/logic, feature tests for full flow, integration with RBAC; cover edge cases like low stock, fraud flag, returns/exchanges
- Data consistency: Ensure transactional reads, UTC handling, referential links (e.g., no orphaned items)
- Reporting tie-in: Picking list data can feed into analytics like order fulfillment SLA, inventory aging

## Authentication/Authorization Requirements

- Requires Employee authentication (JWT/session/API key)
- RBAC: User must have role with permissions for 'order.picking' or similar ability (via role↔perm, user_role multi-role)
- Branch scope: Order must be assigned to user's store/branch; enforce via middleware
- Additional checks: Active user, email-verified, 2FA if enabled; optional tenancy
- Security: Input sanitizer for {id}, domain guards for order/reservation; no file uploads, but guard against injection

## Expected Request/Response Format Considerations

- **Request:** GET /api/orders/{id}/picking-list
  - Path param: {id} (order UUID/integer, required)
  - Query params: Optional filters like ?include=batches,locations or ?format=pdf (if export supported)
  - Headers: Authorization (Bearer/JWT), Accept (application/json), X-Request-ID, X-Branch-ID
  - No body

- **Response:** 200 OK, application/json
  - Structure: {
    ""data"": {
      ""order_id"": ""uuid"",
      ""store"": {""id"": ""uuid"", ""name"": ""string""},
      ""items"": [
        {
          ""id"": ""uuid"",
          ""product"": {""id"": ""uuid"", ""name"": ""string"", ""sku"": ""string"", ""barcode"": ""string""},
          ""quantity"": 5,
          ""batches"": [{""id"": ""uuid"", ""location"": ""string"", ""expiry"": ""date""}],
          ""notes"": ""string""
        }
      ],
      ""total_items"": 10,
      ""status"": ""ready_for_picking""
    }
  }
  - Includes: Links for related shipment/dispatch, attachments if any
  - Alternatives: Support bulk export (CSV/PDF) via Accept header
  - Errors: 4xx/5xx as problem+json, e.g., {""type"": ""https://example.com/probs/order-invalid-state"", ""title"": ""Invalid Order State"", ""status"": 422}

## Relevant Business Logic

- Order lifecycle: Only generate if state is confirmed (via state machine: pending→confirmed→picking→fulfilled|cancelled); conflicts block via domain guards
- Inventory: Batch-centric; list available batches per item, prioritize by location/expiry; check reservations to avoid over-picking
- Fulfillment: Prepares for shipment/shipment_item creation; integrates with dispatch for inter-store if needed (tracking, scan events)
- Edge cases: Handle promos (free items), price_overrides, taxes (info only), fraud flag (block picking), returns (exclude RMA items)
- Consistency: Deterministic assignment, safe reservation/consumption; post to accounting ledger on pick confirmation (not generation)
- Integrations: Potential webhook on generation; notification templates for picker alerts (email/SMS)
- Compliance: Audit all accesses; PII masking for customer data if included; support feature flags for picking workflows"
266,order,Timeline,Order event timeline,api/orders/{id}/timeline,get,Employee,Implement GET /api/orders/{id}/timeline for Order Event Timeline,"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint provides the event timeline for a specific order, aggregating relevant events such as state changes, notes, attachments, audit events, and other order-related activities from the order domain.

## API Specifications

- **Category:** order
- **Title:** Timeline
- **Description:** Order event timeline
- **Route:** api/orders/{id}/timeline
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET endpoint to retrieve the order event timeline
- [ ] Validate that the order ID exists and is accessible to the authenticated employee
- [ ] Ensure the response includes a chronological list of events (e.g., state transitions, notes, attachments, audit events)
- [ ] Handle cases where the order is not found (return 404)
- [ ] Apply proper RBAC checks for employee access to the order (e.g., branch scope)
- [ ] Include pagination if the timeline is large (e.g., limit/offset parameters)
- [ ] Write unit and integration tests covering success, error, and edge cases
- [ ] Document the endpoint in the API specs (e.g., OpenAPI/Swagger)
- [ ] Ensure compliance with middleware stack (auth, RBAC, branch scope, etc.)

## Technical Requirements

- Use Laravel controller (e.g., OrderController@timeline) and define the route in api.php
- Leverage Eloquent models for Order, AuditEvent, Note, Attachment, and related entities
- Query events using polymorphic relationships and audit logs, sorted by timestamp (UTC)
- Implement input validation for {id} (UUID or integer) using FormRequest or route model binding
- Use state machines to include only legal transitions and relevant business events
- Handle soft deletes by including archival events if applicable
- Apply caching/etag for performance if timeline is static post-fulfillment
- Error handling: Use RFC7807 problem+json for validation errors, unauthorized access, etc.
- Integrate with observability: Log requests with request-id, mask PII in events

## Authentication/Authorization Requirements

- Requires Employee authentication (JWT/session/API key)
- Enforce RBAC: User must have permissions to view orders (e.g., 'order.view' ability)
- Apply branch scope: Employee can only access orders assigned to their branches/stores
- Include middleware: auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope
- Reject if user lacks multi-role access or is blacklisted

## Expected Request/Response Format Considerations

- **Request:** GET /api/orders/{id}/timeline?limit=50&offset=0 (optional pagination params)
- **Response:** 200 OK with JSON array of timeline events, each with timestamp (UTC), event_type (e.g., 'state_change', 'note_added', 'payment_captured'), actor (user_id), details (e.g., from_state/to_state, note_text), and links to related entities
- Example response structure:
  [
    {
      ""id"": ""uuid"",
      ""timestamp"": ""2023-10-01T12:00:00Z"",
      ""event_type"": ""order_confirmed"",
      ""actor_id"": ""user_uuid"",
      ""details"": {""from"": ""pending"", ""to"": ""confirmed""},
      ""related"": {""order_item_id"": ""uuid""}
    }
  ]
- For errors: 401 Unauthorized, 403 Forbidden, 404 Not Found, 422 Unprocessable Entity
- Use versioned content-negotiation (e.g., Accept: application/vnd.deshio.v1+json)
- Set cache headers and etag based on order last modified

## Relevant Business Logic

- Aggregate events from order states (pending→confirmed→fulfilled|cancelled), notes/attachments (polymorphic), audit_event logs, payment statuses, shipment/dispatch events, returns (RMA), and promotions/taxes/fraud flags
- Ensure timeline reflects transactional stock movements, ledger postings, and state machine transitions
- Include events from fulfillment (shipments, dispatches with scan events, POD), payments (intent→capture/void, refunds), and returns (receive/restock/scrap, exchanges)
- Filter events to order scope; respect soft deletes but include historical events
- Maintain determinism: Events should be immutable and queryable for reporting (e.g., order history for LTV/AOV, SLA)
- Conflicts (e.g., unauthorized view) return RFC7807 problem+json with type/title/detail"
267,order,Duplicate Order,Clone order,api/orders/{id}/duplicate,post,Employee,Implement Duplicate Order API (POST /api/orders/{id}/duplicate),"## Overview

This GitHub issue is for implementing the 'Duplicate Order' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint allows cloning an existing order to create a duplicate, useful for reordering or templating similar orders. It should handle order items, customer details, store assignment, and promotions while resetting the new order to a pending state.

## API Specifications

- **Category:** order
- **Title:** Duplicate Order
- **Description:** Clone order
- **Route:** api/orders/{id}/duplicate
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint responds with 201 Created on successful duplication, returning the new order ID and details
- [ ] Validates that the source order exists and is not soft-deleted
- [ ] Clones order items, customer, store assignment, notes, attachments, and applicable promotions/taxes (excluding payments and fulfillments)
- [ ] Sets the new order to 'pending' state with no reservations or ledger entries initially
- [ ] Handles fraud flags by inheriting or resetting based on business rules
- [ ] Returns RFC7807 problem+json for errors (e.g., order not found, unauthorized)
- [ ] Integrates with state machine for order creation legality
- [ ] Logs audit_event for the duplication action
- [ ] Includes unit and integration tests covering success, failure, and edge cases (e.g., order with RMAs)
- [ ] Documentation updated in API specs with request/response examples

## Technical Requirements

- Implement in Laravel controller (e.g., OrderController@duplicate) with route registration in api.php
- Use Eloquent models for Order, OrderItem, etc., ensuring soft deletes are respected
- Apply middleware stack: auth (JWT/session/API key), RBAC & permission checks, branch scope, input sanitizer, domain guards
- Handle idempotency if applicable via request headers
- Ensure transactional database operations for cloning to maintain consistency
- Use UTC for all timestamps; support caching/etag if read-heavy
- Integrate with queues if post-duplication notifications are needed
- Follow versioned content-negotiation and JSON limits

## Authentication/Authorization Requirements

- Requires 'Employee' authentication via JWT, session, or API key
- RBAC check: User must have permission to duplicate orders (e.g., 'order.duplicate' ability assigned to role)
- Active user, email-verified, and optional 2FA enforcement
- Branch scope: Employee must be scoped to the order's store/branch
- Audit the action in audit_event table with request-id

## Expected Request/Response Format Considerations

- **Request:** POST with optional JSON body for overrides (e.g., {""customer_id"": null} to detach customer); path param {id} for source order
- **Response (Success):** 201 with JSON {""data"": {""id"": new_order_id, ""order"": {full order object}}}
- **Response (Error):** 4xx/5xx with RFC7807 problem+json, e.g., {""type"": ""https://example.com/probs/order-not-found"", ""title"": ""Order not found"", ""status"": 404}
- Validate inputs with Laravel Form Requests; sanitize for security
- Support attachments polymorphism if cloning notes/attachments

## Relevant Business Logic

- Clone order header (customer, store, notes, attachments, tags) but exclude fulfillments (shipments, dispatches), payments, and returns (RMAs)
- Duplicate order items with quantities, prices (apply current pricing/promos if overrides), barcodes, and attributes
- Reset state to 'pending'; do not create reservations or ledger entries until confirmation
- Inherit fraud flag if set, or allow override
- Ensure no conflicts with inventory batches; use state machine for transition validation
- Post-duplication, trigger any relevant webhooks or notifications (e.g., order created)
- Handle promotions: Re-evaluate eligibility for the new order
- For exchanges or services, clone appropriately if linked
- Maintain referential integrity across junctions; use soft deletes for any failures"
268,order,Flag Fraud,Flag as suspected fraud,api/orders/{id}/flag-fraud,post,Admin,Implement Flag Fraud Endpoint for Orders API,"## Overview

This GitHub issue is for implementing the 'Flag Fraud' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs built over a normalized ERD. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain handles order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to stores, notes/attachments, promotions, taxes, and fraud flags. This endpoint specifically allows flagging an order as suspected fraud, integrating with order lifecycle management, state machines for legal transitions, and observability features like audit events and logs. All data is stored in UTC, with soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential integrity. Design ensures deterministic admin actions, safe reservations, and consistent ledger posting.

## API Specifications

- **Category:** order
- **Title:** Flag Fraud
- **Description:** Flag as suspected fraud
- **Route:** api/orders/{id}/flag-fraud
- **HTTP Method:** post
- **Authentication:** Admin

Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards (including fraud), upload mime guard, cache headers. APIs support bulk operations, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. State machines enforce legality of transitions for orders; conflicts return RFC7807 problem+json.

## Acceptance Criteria

- [ ] Implement the POST /api/orders/{id}/flag-fraud endpoint in Laravel
- [ ] Ensure endpoint requires Admin authentication and proper RBAC permissions
- [ ] Validate input: order ID exists, order is in a flaggable state (e.g., pending or confirmed), and fraud flag can be set without violating state machine rules
- [ ] Update order record with fraud flag, trigger audit_event log, and potentially notify via webhooks or notifications (email/SMS templates)
- [ ] Handle errors: return 404 for non-existent order, 403 for unauthorized access, 422 for validation failures, 409 for state conflicts using RFC7807 problem+json format
- [ ] Integrate with order state machine to ensure fraud flagging is a legal transition; prevent actions like fulfillment on flagged orders
- [ ] Add unit/integration tests covering success, validation errors, auth failures, and state conflicts
- [ ] Document endpoint in API specs (e.g., OpenAPI/Swagger) including request/response schemas
- [ ] Ensure idempotency: repeated flags do not create duplicates or alter timestamps
- [ ] Test for observability: generate audit logs, request-id tracing, and PII masking if applicable
- [ ] Verify compatibility with branch scope and tenancy (if enabled)

## Technical Requirements

- **Laravel Implementation:** Create a dedicated controller (e.g., OrderFraudController) with a flagFraud method. Define route in api.php with middleware stack: auth, admin role/permission check, branch scope.
- **Input Validation:** Use FormRequest for validation; require order ID as path param (UUID/integer), optional reason/note as JSON body. Sanitize inputs per middleware.
- **Business Logic:** Fetch order via repository/service; check state machine for flaggable status (e.g., not already fulfilled/cancelled). Set fraud_flag boolean/timestamp on order model. Trigger events for ledger posting (if financial impact), notifications, and webhooks. Use transactions for atomicity. Integrate with fraud domain guard to block conflicting actions (e.g., payment capture).
- **Authentication/Authorization:** Enforce Admin user role via RBAC (user_role junction, ability checks). Support JWT/session/API key auth; require email-verified and 2FA if configured. Permission: 'orders.flag-fraud'.
- **Expected Request/Response Formats:** Request: JSON body { ""reason"": ""string (optional)"" }. Response: 200 OK with updated order summary JSON (include fraud_flag, updated_at); or error in problem+json. Use ETag/caching headers; content-negotiation for JSON.
- **Error Handling:** Centralized exception handler for domain-specific errors (e.g., OrderFraudException). Log via audit_event and request-id.
- **Database/Integrations:** Soft delete awareness; UTC timestamps. Polymorphic attachments/notes if reason includes media. Ensure referential integrity with orders table. Post to accounting ledger if fraud affects payments/refunds.
- **Testing/Security:** PHPUnit tests for controller/service; mock auth/RBAC. Security: rate limiting, idempotency keys, replay defense if webhooks involved. Observability: metrics for endpoint usage, queue integration if async processing needed.
- **Reporting Impact:** Flagged orders should appear in analytics (e.g., fraud rates, revenue impact by store/product)."
269,order,Unflag Fraud,Remove fraud flag,api/orders/{id}/unflag-fraud,post,Admin,Implement Unflag Fraud API Endpoint for Orders,"## Overview

This GitHub issue is for implementing the 'Unflag Fraud' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs built over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain features order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, and fraud flags. This endpoint specifically removes the fraud flag from an order, enabling state machines to drive legal transitions while ensuring compliance with business rules like safe reservation/consumption and consistent ledger posting.

## API Specifications

- **Category:** order
- **Title:** Unflag Fraud
- **Description:** Remove fraud flag
- **Route:** api/orders/{id}/unflag-fraud
- **HTTP Method:** POST
- **Authentication:** Admin

The endpoint is part of the broader middleware plan including TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards (including order/fraud), upload mime guard, cache headers, and state machine enforcement for order transitions. Conflicts return RFC7807 problem+json. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential links.

## Acceptance Criteria

- [ ] Implement the POST endpoint at api/orders/{id}/unflag-fraud to remove the fraud flag from the specified order
- [ ] Ensure the endpoint updates the order's fraud flag and triggers any necessary state machine transitions or ledger postings
- [ ] Add input validation for the order ID (must exist and be unflaggable)
- [ ] Implement proper error handling for cases like order not found, already unflagged, or unauthorized access, returning RFC7807 problem+json
- [ ] Write unit and integration tests covering success, failure (e.g., invalid ID, fraud flag already removed), and edge cases (e.g., concurrent updates)
- [ ] Verify integration with observability features: audit_event logging, request-id tracing, PII masking
- [ ] Ensure the endpoint respects branch scope, RBAC permissions, and admin-only access
- [ ] Test for idempotency to handle duplicate requests safely
- [ ] Confirm compatibility with bulk operations, search/autosuggest, and reporting/analytics (e.g., fraud flag history in activity reports)

## Technical Requirements

- Use Laravel framework: Define the route in api.php, create a dedicated controller method (e.g., OrderController@unflagFraud)
- Implement input validation using Laravel's Form Requests or Validator, ensuring {id} is a valid UUID/integer referencing an existing order
- Integrate with order state machine to validate and apply the unflag transition legally
- Handle database transactions for atomic updates to order fraud flag, potentially triggering ledger entries or notifications
- Apply middleware stack: auth (Admin), RBAC permission checks (e.g., 'orders.unflag-fraud'), branch scope, idempotency key if applicable, input sanitizer, domain guard for fraud
- Support EAV attributes if fraud flag is extended; use soft deletes for archival
- For observability: Log audit_event on successful unflag, include request-id, and ensure compliance with health/metrics, queues, caching/etag
- Enable feature flags for toggling the endpoint if needed; consider backups/restore and system maintenance impacts

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have 'orders.unflag-fraud' permission via role/permission abilities and user_role assignments
- Additional checks: Active user, email-verified, TOTP MFA if enabled, branch scope alignment
- Security: TLS/HSTS, CORS, throttles, replay defense; sessions with password reset and backup codes support

## Expected Request/Response Format Considerations

- **Request:** POST with JSON body (empty or optional idempotency key); path param {id} for order ID. Content-Type: application/json; versioned via Accept header
- **Success Response:** 200 OK with JSON { ""message"": ""Fraud flag removed"", ""order"": { id, fraud_flag: false, updated_at } } or minimal confirmation
- **Error Responses:** 4xx/5xx with RFC7807 problem+json, e.g., 404 { ""type"": ""order_not_found"", ""title"": ""Order not found"" }; 403 for unauthorized; 422 for validation errors
- Use UTC timestamps; include ETag for caching; support locale/tz via headers

## Relevant Business Logic

- Orders include a fraud flag for risk management; unflagging allows progression from pending/held states to confirmed/fulfilled
- On unflag, synchronize with order.payment_status, potentially enabling payments/refunds; trigger notifications (email/SMS via templates) and webhooks
- Ensure transactional stock movements if unflagging affects reservations; post to accounting ledger for any reversals
- Integrate with reporting: Update fraud-related metrics like return/refund rates, activity logs, and promo impact
- State machines enforce legality: Unflag only if current state permits (e.g., not already fulfilled/cancelled); conflicts block and log
- Supports determinism for admin assignments, safe consumption, and compliance with integrations (carriers, waybills, tracking)"
270,dispatch,Manifest,Generate shipment manifest,api/dispatches/{id}/manifest,get,Employee,Implement GET /api/dispatches/{id}/manifest for Shipment Manifest,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue covers the implementation of the 'Manifest' API endpoint in the dispatch category. Deshio handles core entities like product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment involves shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns cover RMA (return/return_item), receive/restock/scrap, refunds, exchanges. Payments include intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting features transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services include service/service_order with lifecycle and profitability. Integrations cover carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint generates a shipment manifest for a specific dispatch, supporting the fulfillment process with inter-store dispatch tracking and transactional stock movements.

## API Specifications

- **Category:** dispatch
- **Title:** Manifest
- **Description:** Generate shipment manifest
- **Route:** api/dispatches/{id}/manifest
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET endpoint to generate a shipment manifest for the specified dispatch ID
- [ ] Ensure the endpoint authenticates and authorizes Employee users with appropriate RBAC permissions for dispatch access
- [ ] Validate the dispatch ID exists and is in a valid state for manifest generation (e.g., confirmed or ready for fulfillment)
- [ ] Return a structured manifest including shipment details, items, tracking info, and any associated POD/scan events
- [ ] Handle errors per RFC7807 problem+json for invalid ID, unauthorized access, or state conflicts
- [ ] Integrate with state machines to ensure legal transitions and transactional stock movements
- [ ] Add unit and integration tests covering success, validation failures, auth errors, and edge cases like soft-deleted dispatches
- [ ] Document the endpoint in API specs with request/response examples
- [ ] Verify middleware application: auth, RBAC, branch scope, throttles, idempotency, input sanitizer, domain guards for dispatch
- [ ] Ensure response includes proper cache headers, ETag, and request-id for observability
- [ ] Test for PII masking and audit_event logging on access

## Technical Requirements

- Use Laravel framework: Create a controller method in DispatchController (or similar) handling the route
- Define the route in api.php with resource naming: Route::get('dispatches/{id}/manifest', [DispatchController::class, 'manifest'])
- Implement input validation: Ensure {id} is a valid UUID or integer for dispatch ID using FormRequest or controller validation
- Fetch dispatch entity with relationships (e.g., shipment/shipment_item, tracking, scan events) using Eloquent, respecting soft deletes and strict referential links
- Generate manifest data: Compile shipment details, items from order/order_item, batch/inventory info, carrier/waybill data; support polymorphic attachments/notes
- Handle business logic: Check dispatch state via state machine; ensure reservations/consumption are safe; post to ledger if needed for movements
- Response format: JSON with manifest structure (e.g., { ""dispatch_id"": ..., ""shipments"": [...], ""items"": [...], ""tracking"": {...} }); use UTC timestamps; consider EAV attributes for items
- Error handling: Return 404 for non-existent dispatch, 403 for unauthorized, 422 for invalid state; use problem+json for details
- Integration: Hook into observability (log, audit_event, request-id); apply middleware stack including auth (JWT/session/API key), RBAC & permission checks (employee role with dispatch perms), branch scope
- Testing: PHPUnit tests for controller, validation, auth; feature tests simulating requests; cover bulk scenarios if applicable
- Security: Enforce TLS/HSTS, CORS, JSON limits; domain guard for dispatch; replay defense if relevant
- Performance: Use caching/etag where possible; queue if manifest generation is heavy

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- RBAC: User must have role/permission allowing dispatch manifest access (e.g., ability: view_dispatch_manifest)
- Additional checks: Active user, email-verified, 2FA if enabled; branch scope to ensure access to the dispatch's store/branch
- Multi-role support via user_role; permission checks via middleware

## Expected Request/Response Format Considerations

- **Request:** GET /api/dispatches/{id}/manifest (no body; {id} path param validated as dispatch identifier)
- **Response (Success - 200):** JSON object with manifest details, e.g., {
  ""data"": {
    ""id"": ""uuid"",
    ""manifest"": {
      ""shipments"": [
        {
          ""id"": ""uuid"",
          ""items"": [...],
          ""tracking"": {...},
          ""events"": [...]  // scan events, POD
        }
      ],
      ""total_items"": 5,
      ""status"": ""ready""
    }
  }
}; Include metadata like etag, timestamps in UTC
- **Response (Error):** problem+json, e.g., {
  ""title"": ""Invalid Dispatch"",
  ""status"": 404,
  ""detail"": ""Dispatch not found"",
  ""type"": ""https://example.com/probs/dispatch-not-found""
}
- Versioned via content-negotiation; locale/tz aware if needed; idempotent

## Relevant Business Logic

- Manifest generation ties into fulfillment: For inter-store dispatch, include dispatch details, shipment/shipment_item, tracking, scan events, POD
- Ensure transactional stock movements: Verify reservations not consumed prematurely; integrate with inventory ledgers
- State machine validation: Dispatch must be in a state allowing manifest (e.g., confirmed); prevent illegal transitions
- Support for promotions, taxes, fraud flags from linked orders; include attachments/media if relevant
- Post-generation: Trigger webhooks/notifications if configured (e.g., email/SMS templates); log audit_event for compliance
- Edge cases: Handle returns/exchanges impacting manifest; low stock/inventory aging alerts; cycle count impacts on items
- Consistency: Deterministic assignment, safe reservation/consumption, ledger posting on events"
271,dispatch,Label,Generate dispatch label,api/dispatches/{id}/label,get,Employee,Implement Dispatch Label Generation API Endpoint,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue covers the implementation of the 'Label' API endpoint in the dispatch category. Deshio manages core entities like products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The order domain handles states (pending→confirmed→fulfilled|cancelled), assignments, notes/attachments, promos, taxes, fraud flags. Fulfillment includes shipments and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns cover RMA, receive/restock/scrap, refunds, exchanges. Payments manage intent→capture/void, refunds, synchronization. Accounting uses transaction headers + ledger entries, reversals, reconciliation/export. Services include service orders with lifecycle and profitability. Integrations handle carriers, waybills/rates/tracking, webhooks, notifications. Security features user/role/permission, sessions, email verification, password reset, TOTP MFA, API keys. Observability includes audit events, logs, request-id, PII masking, health/metrics, queues, caching/etag. Middleware encompasses TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines ensure legal transitions for orders, dispatches, etc., with RFC7807 problem+json for conflicts. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, strict referential links. Design enables deterministic admin assignment, safe reservation/consumption, consistent ledger posting.

This endpoint generates a dispatch label for inter-store dispatch fulfillment, supporting transactional stock movements, tracking, scan events, and POD.

## API Specifications

- **Category:** dispatch
- **Title:** Label
- **Description:** Generate dispatch label
- **Route:** api/dispatches/{id}/label
- **HTTP Method:** GET
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET /api/dispatches/{id}/label endpoint to generate and return a dispatch label
- [ ] Validate that the dispatch ID exists and is in a valid state for label generation (e.g., confirmed, ready for dispatch)
- [ ] Ensure the endpoint requires Employee authentication and appropriate RBAC permissions (e.g., view/edit dispatch)
- [ ] Handle errors with RFC7807 problem+json format for invalid ID, unauthorized access, or state conflicts
- [ ] Generate label in a standard format (e.g., PDF) with dispatch details like tracking number, items, origin/destination stores
- [ ] Integrate with state machine to verify legal transition for label generation
- [ ] Add unit/integration tests covering success, validation failures, auth errors, and edge cases (e.g., soft-deleted dispatch)
- [ ] Document the endpoint in API specs with request/response examples
- [ ] Ensure response includes proper cache headers and request-id tracing
- [ ] Verify transactional stock movement logging if label generation triggers any updates

## Technical Requirements

- Use Laravel controller (e.g., DispatchController@label) and define route in api.php with {id} parameter binding to Dispatch model
- Implement input validation for {id} as UUID/integer, ensuring dispatch exists and belongs to the authenticated employee's branch scope
- Apply middleware stack: auth (JWT/session/API key), active user, RBAC & permission checks (e.g., 'dispatch.view' permission), branch scope
- Handle response as binary download (e.g., PDF label) or JSON with label URL/data, using Content-Type application/pdf or image/png
- Integrate with observability: log audit_event for label generation, include request-id, mask PII if applicable
- Use Eloquent for Dispatch model queries with soft deletes awareness (withTrashed() if needed, but deny for active operations)
- Ensure idempotency if multiple calls possible, and add rate limiting via throttles
- For label generation, leverage a library like Dompdf or barcode generator for dispatch details (e.g., shipment items, tracking)
- Post to accounting ledger if label generation affects stock reservations
- Support versioning via content-negotiation and locale/tz for any date fields in label

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- Employee must be active, email-verified, and optionally 2FA-enabled
- RBAC: User must have role with permission to view/edit dispatches (e.g., ability 'dispatch.label-generate')
- Branch scope: Employee can only generate labels for dispatches assigned to their store/branch
- Deny access for non-employees, suspended users, or cross-tenant if tenancy enabled
- Use guard middleware for domain-specific checks (e.g., dispatch state legality)

## Expected Request/Response Format Considerations

- **Request:** GET /api/dispatches/{id}/label
  - Path param: {id} - Dispatch ID (required, validated as existing Dispatch record)
  - No query params or body expected, but optional ?format=pdf (default) or image
  - Headers: Authorization (Bearer/JWT), Accept (application/pdf), X-Request-ID

- **Response:** 
  - Success (200): Binary label data (e.g., PDF) with Content-Disposition: attachment; filename=""dispatch-{id}-label.pdf""
    Example: Streamed PDF containing dispatch details, barcode, addresses, items list
  - Error (400/401/403/404/422): RFC7807 problem+json
    e.g., {""title"":""Invalid Dispatch ID"",""status"":404,""detail"":""Dispatch not found""}
  - Include ETag for caching if label content is static post-generation
  - All dates in UTC, responses versioned (e.g., v1), with cache headers

## Relevant Business Logic

- Dispatch is part of inter-store fulfillment: Generate label only if dispatch state allows (e.g., pending→assigned→labelled via state machine)
- Label includes: Dispatch ID, tracking number, origin/destination branches, shipment items (from dispatch_items), barcodes, vendor/customer details if applicable
- Transactional: If label generation updates state or reserves stock, ensure atomicity with DB transactions and ledger posting for movements
- Conflicts (e.g., dispatch already labelled or cancelled) return problem+json with state machine violation details
- Integrate with integrations: If carrier-linked, pull waybill/rates for label; trigger webhook on label generation if configured
- Support attachments: Optionally attach generated label as polymorphic attachment to dispatch
- Ensure determinism: Label content based on current dispatch snapshot, with audit trail for changes
- Handle soft deletes: Prevent label generation on deleted dispatches, but allow archival reference if needed"
272,inventory,FIFO Valuation,FIFO stock valuation,api/inventory/valuation/fifo,get,Admin,Implement FIFO Stock Valuation API Endpoint (GET /api/inventory/valuation/fifo),"## Overview

This issue covers the implementation of the FIFO (First In, First Out) stock valuation API endpoint for the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core inventory features are batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. This endpoint provides FIFO-based stock valuation, enabling deterministic calculation of inventory value based on batch entry order, integrated with accounting ledgers for transactional stock movements. It aligns with state machines for legality of transitions and ensures consistent ledger posting on stock events. Data is stored in UTC with soft deletes, EAV for attributes, and strict referential links.

## API Specifications

- **Category:** inventory
- **Title:** FIFO Valuation
- **Description:** FIFO stock valuation
- **Route:** api/inventory/valuation/fifo
- **HTTP Method:** GET
- **Authentication:** Admin

This endpoint is part of the broader Deshio API ecosystem, including bulk import/export, search/autosuggest, and reporting/analytics like inventory aging/low stock and valuation.

## Acceptance Criteria

- [ ] Implement the GET /api/inventory/valuation/fifo endpoint in a Laravel controller
- [ ] Ensure the endpoint calculates FIFO valuation for inventory batches, considering reservations, adjustments, and ledgers
- [ ] Add input validation for any query parameters (e.g., date range, store/branch filters)
- [ ] Handle errors with RFC7807 problem+json format for conflicts or invalid states
- [ ] Verify integration with accounting transaction headers and ledger_entry lines for valuation postings
- [ ] Write unit and integration tests covering success, edge cases (e.g., empty inventory, partial batches), and error scenarios
- [ ] Ensure compatibility with middleware stack: TLS/HSTS, CORS, RequestId, auth (JWT/session/API key), active user, RBAC & permission checks, branch scope, throttles, idempotency, input sanitizer, and cache headers
- [ ] Confirm observability: audit_event logging, request-id tracing, PII masking, and metrics for endpoint performance
- [ ] Test against state machines for inventory transitions (e.g., adjustments, cycle counts)

## Technical Requirements

- Use Laravel framework: Define route in api.php, create a dedicated controller (e.g., InventoryValuationController@fifo)
- Implement FIFO logic: Query batch-centric inventory data, sort by entry date/time, compute value based on cost per unit/batch, apply overrides (e.g., price_override), and aggregate for total valuation
- Integrate with ERD entities: product/category/vendor attributes, inventory batches, stores/branches, and ledgers
- Support query parameters if needed (e.g., ?store_id=1&as_of_date=YYYY-MM-DD) for filtering; default to current UTC time
- Use Eloquent models for efficient querying; consider caching/etag for performance
- Handle soft deletes and archival data exclusion
- Ensure deterministic admin assignment and safe reservation/consumption ties
- For bulk scenarios, optimize for reporting/analytics like inventory aging and low stock alerts

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have 'admin' role with permissions for inventory valuation access (via role↔perm and user_role multi-role)
- Apply middleware: active user check, email-verified, optional TOTP MFA + backup codes, branch scope (limit to assigned stores/branches)
- Security: TLS/HSTS, CORS, JSON limits, versioned content-negotiation, locale/tz handling, domain guards for inventory/reservation/cycle-count, throttles, and idempotency
- For integrations, support webhook deliveries if extended, but primary is direct API call

## Expected Request/Response Format Considerations

- **Request:** GET request to /api/inventory/valuation/fifo with optional query params (e.g., store_id, branch_id, as_of_date in UTC). No body required. Headers: Accept: application/json, Authorization: Bearer <token>
- **Response (Success - 200):** JSON object with valuation details, e.g., {""total_value"": 15000.00, ""batches"": [{ ""id"": 1, ""entry_date"": ""2023-01-01T00:00:00Z"", ""quantity"": 100, ""unit_cost"": 50.00, ""value"": 5000.00 }], ""summary"": { ""store_id"": 1, ""as_of"": ""2023-10-01T00:00:00Z"" } }. Use consistent JSON structure with snake_case keys.
- **Error Responses:** 401 Unauthorized, 403 Forbidden (RBAC/scope failure), 422 Unprocessable Entity (validation errors), 500 Internal Server Error. All errors in RFC7807 problem+json format, e.g., {""title"": ""Forbidden"", ""status"": 403, ""detail"": ""Insufficient permissions for inventory valuation""}.
- Content negotiation: Versioned (e.g., /v1/), locale/tz aware, cache headers (ETag, max-age)

## Relevant Business Logic

- FIFO Valuation: Calculate stock value by consuming oldest batches first; account for batch attributes, media, barcodes, pricing (including overrides and promotions), reservations, and adjustments
- Integrate with order domain: Reflect impacts from order/order_item states (e.g., confirmed→fulfilled), shipments/dispatch stock movements, returns/RMA restock/scrap/refunds/exchanges
- Accounting Sync: Post valuation to transaction headers + ledger_entry lines; support reversals, reconciliation/export
- Compliance: Audit events for valuation queries; PII masking if customer data indirectly involved; soft deletes for historical batches
- Edge Cases: Handle zero/negative quantities, multi-store/branch scoping, promotions/taxes/fraud flags influencing value, and cycle count accuracy
- Reporting Ties: Enable analytics like revenue/units by product/store, inventory aging, low stock, and promo impact using this valuation data
- State Machines: Ensure transitions (e.g., batch adjustments) are legal; conflicts return problem+json"
273,inventory,LIFO Valuation,LIFO stock valuation,api/inventory/valuation/lifo,get,Admin,Implement LIFO Stock Valuation API Endpoint,"## Overview

Deshio is a Laravel-based ERP system for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD that covers catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes (fields/features), media (product images), barcodes, pricing (price overrides), and promotions. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers.

This API endpoint implements LIFO (Last In, First Out) stock valuation within the inventory domain. It allows admins to retrieve valuation data based on the LIFO method, which assumes the most recently acquired inventory items are the first sold or consumed. This aligns with Deshio's inventory management, where valuation is crucial for accounting, ledgers, and reporting/analytics such as inventory aging, low stock alerts, and profitability calculations. The endpoint ensures deterministic calculations, integrates with state machines for legality, and posts to ledgers for all stock movements. Data is stored in UTC, with soft deletes for archival, EAV for attributes, polymorphic notes/attachments, and strict referential links.

## API Specifications

- **Category:** inventory
- **Title:** LIFO Valuation
- **Description:** LIFO stock valuation
- **Route:** api/inventory/valuation/lifo
- **HTTP Method:** GET
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint returns LIFO valuation data for specified inventory batches or products
- [ ] Supports filtering by store/branch, date range, product/category, or vendor
- [ ] Handles bulk valuation calculations efficiently for large datasets
- [ ] Integrates with inventory ledgers for accurate posting of valuation events
- [ ] Returns RFC7807 problem+json for conflicts or invalid states (e.g., via state machines)
- [ ] Includes search/autosuggest capabilities if applicable for inputs
- [ ] Ensures idempotency and proper caching/etag headers
- [ ] Add unit/integration tests covering happy paths, edge cases (e.g., no batches, zero value), and error scenarios
- [ ] Document endpoint in API specs with examples
- [ ] Verify compliance with middleware (e.g., auth, RBAC, branch scope, input sanitizer)

## Technical Requirements

- Implement in Laravel: Define route in api.php, create dedicated controller (e.g., InventoryValuationController@lifo), and use Eloquent models for inventory batches, products, and ledgers.
- Input validation: Use Laravel's Form Requests or Validator for query parameters (e.g., store_id, product_id, from_date, to_date); enforce domain guards for inventory/reservation/override.
- Business logic: Calculate LIFO by sorting batches by acquisition date descending, applying costs to outflows (sales, adjustments, reservations); handle optional per-unit items; support reversals and reconciliations; ensure transactional stock movements and ledger entries for every event.
- Integration: Leverage existing services for inventory adjustments, cycle counts, and reporting (e.g., revenue/units by store/product); use queues for heavy computations if needed; enable feature flags for LIFO toggling.
- Observability: Log audit_events, mask PII, include request-id; support health/metrics and backups/restore.
- Error handling: Use state machines to validate transitions; return 4xx/5xx with problem+json; implement throttles and idempotency keys.
- Design considerations: Enable deterministic admin assignment, safe reservation/consumption; polymorphic attachments for valuation notes; EAV for custom valuation attributes.

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key.
- Enforce RBAC: User must have role/permission for inventory valuation (e.g., ability role↔perm mapping).
- Additional checks: Active user, email-verified, 2FA (TOTP + backup codes); branch scope to limit data access; optional tenancy.
- Middleware stack: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth, active user, email-verified, 2FA, RBAC/permission checks, branch scope, throttles, idempotency, input sanitizer, domain guards (inventory/reservation/cycle-count), cache headers.

## Expected Request/Response Format Considerations

- **Request:** GET with query params, e.g., ?store_id=1&product_id=123&from_date=2023-01-01&to_date=2023-12-31&batch_ids[]=1&batch_ids[]=2. Use JSON limits and sanitizer; support bulk via arrays.
- **Response:** JSON object with valuation summary, e.g., {""total_value"": 15000.00, ""batches"": [{ ""id"": 1, ""acquired_at"": ""2023-10-01"", ""cost"": 100.00, ""quantity"": 100, ""valued_amount"": 10000.00 }], ""ledgers"": [/* posted entries */], ""metrics"": {""ending_inventory"": 500, ""cogs"": 10000.00}}. Include etag for caching; paginate large results; timestamps in UTC.
- Formats: Strict JSON; error responses as RFC7807 problem+json (e.g., {""type"": ""https://example.com/probs/invalid-batch"", ""title"": ""Invalid batch state"", ""status"": 422}).

## Relevant Business Logic

- LIFO valuation prioritizes newest batches for cost allocation in outflows (orders, shipments, dispatches, returns, adjustments).
- Integrate with order domain (states: pending→confirmed→fulfilled|cancelled), fulfillment (shipments/dispatches with tracking/POD), returns (RMA with restock/scrap/refunds/exchanges), and payments (intent→capture, refunds syncing to order.payment_status).
- Accounting: Post to transaction headers + ledger_entry lines for all movements; support reversals, reconciliation/export.
- Reporting: Feed into analytics like inventory aging, low stock, cycle count accuracy, promo impact.
- State machines ensure legal transitions; conflicts (e.g., reserved stock) return errors.
- Services: Align with service/service_order lifecycle for profitability; integrations for carriers/webhooks if valuation affects logistics.
- Security: PII masking in logs; webhook signatures for external triggers (e.g., inventory updates)."
274,inventory,Avg Cost Valuation,Average cost valuation,api/inventory/valuation/avg,get,Admin,Implement GET /api/inventory/valuation/avg for Avg Cost Valuation,"## Overview

This GitHub issue is for implementing the Average Cost Valuation API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.

Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.

Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.

Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.

Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).

Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.

Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.

Services: service/service_order with lifecycle and profitability.

Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.

Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.

Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.

Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint specifically handles average cost valuation in the inventory category, computing the average cost for inventory items based on batch-centric data, supporting reservations, adjustments, and ledgers.

## API Specifications

- **Category:** inventory
- **Title:** Avg Cost Valuation
- **Description:** Average cost valuation
- **Route:** api/inventory/valuation/avg
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET endpoint at /api/inventory/valuation/avg
- [ ] Ensure the endpoint computes and returns average cost valuation for inventory items
- [ ] Add input validation for any query parameters (e.g., filters by product, store, date range)
- [ ] Implement proper error handling with RFC7807 problem+json for conflicts or invalid states
- [ ] Write unit and integration tests covering success, error cases, and business logic
- [ ] Verify integration with inventory ledgers and batch data
- [ ] Ensure response includes relevant fields like average cost, total value, and item details
- [ ] Test for performance with large datasets, using caching/etag if applicable
- [ ] Confirm audit logging for valuation queries
- [ ] Validate against state machines for inventory states

## Technical Requirements

- Use Laravel framework: Create a controller (e.g., InventoryValuationController) and define the route in api.php
- Implement query logic to calculate average cost from batch-centric inventory data, considering reservations, adjustments, and ledgers
- Support query parameters for filtering (e.g., ?product_id=123&store_id=456&from_date=2023-01-01) to allow targeted valuations
- Integrate with EAV attributes for product-specific cost factors
- Use soft deletes and UTC handling for data consistency
- Apply middleware: auth (JWT/API key), RBAC permission checks, branch scope, throttles, input sanitizer, RequestId, caching/etag
- Handle polymorphic relations if valuations link to notes/attachments
- Ensure transactional consistency for any ledger postings triggered by valuation
- Follow Deshio's observability: log requests, mask PII, track metrics

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have admin role with permissions for inventory valuation access
- Include active user check, email verification, and optional 2FA
- Apply branch scope to limit data to authorized stores/branches
- Use permission checks in middleware for 'inventory.valuation.read' or similar ability

## Expected Request/Response Format Considerations

- **Request:** GET /api/inventory/valuation/avg with optional query params (e.g., product_id, store_id, date_range). No body required.
- **Response:** JSON object with 200 OK on success, e.g., {""data"": [{""item_id"": 123, ""average_cost"": 10.50, ""total_value"": 1050.00, ""batch_count"": 100}], ""meta"": {""count"": 1, ""valuation_method"": ""avg""}}. Use versioned content-negotiation.
- Errors: RFC7807 problem+json, e.g., 403 for unauthorized, 422 for invalid params, 500 for server errors.
- Support bulk/paginated responses if querying multiple items; include ETag for caching.

## Relevant Business Logic

- Compute average cost as total cost of batches divided by total quantity, excluding reserved or adjusted items per state machine rules
- Integrate with inventory ledgers for accurate valuation, supporting cycle counts and adjustments
- Handle per-unit items optionally; use strict referential links to products/categories/vendors
- Ensure deterministic calculations for reporting/analytics like inventory aging and low stock
- Trigger ledger entries if valuation affects financial postings; support reversals
- Align with overall ERP design for safe reservation/consumption and consistent accounting on stock events
- Use state machines to validate inventory states before valuation; return problems for illegal transitions"
275,batch,Set Availability,Toggle availability,api/batches/{id}/availability,post,Admin,Implement Batch Availability Toggle API Endpoint,"## Overview

This GitHub issue covers the implementation of the 'Set Availability' API endpoint for the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD that spans catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes (fields/features), media (product_images), barcodes, pricing (price_overrides), and promotions; stores/branches; customers with tags/blacklists.

Inventory management is batch-centric, supporting optional per-unit items, reservations, adjustments, cycle counts, valuation, and ledgers. This endpoint specifically handles toggling the availability of a batch, which controls whether the batch can be used in sales, reservations, or other inventory operations. It ensures deterministic stock management and integrates with state machines for legal transitions, returning RFC7807 problem+json for conflicts.

Data is stored in UTC, with soft deletes for archival, EAV for attributes, polymorphic notes/attachments, and strict referential links across junctions. The design supports safe reservation/consumption and consistent ledger posting for every stock/financial event.

## API Specifications

- **Category:** batch
- **Title:** Set Availability
- **Description:** Toggle availability of a specific batch
- **Route:** api/batches/{id}/availability
- **HTTP Method:** POST
- **Authentication:** Admin

This endpoint is part of the broader inventory domain, enabling admins to toggle batch availability, which impacts order fulfillment, reservations, and stock movements.

## Acceptance Criteria

- [ ] Endpoint responds to POST requests on the specified route
- [ ] Successfully toggles batch availability (e.g., from available to unavailable or vice versa)
- [ ] Requires Admin authentication; unauthorized requests return 401/403
- [ ] Validates the batch ID exists and belongs to the scoped branch/store
- [ ] Handles errors with RFC7807 problem+json format for conflicts (e.g., batch in use, invalid state transition)
- [ ] Updates related ledgers and audit events on successful toggle
- [ ] Includes unit/integration tests covering happy path, validation failures, auth failures, and edge cases (e.g., soft-deleted batch)
- [ ] Integrates with middleware stack: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, JWT/session/API key auth, active user, email-verified, 2FA, RBAC/permission checks, branch scope, throttles, idempotency, input sanitizer, domain guards (reservation/promo/override/cycle-count/fraud), cache headers
- [ ] Ensures PII masking, request-id tracing, and audit logging for observability/compliance

## Technical Requirements

- Implement in Laravel: Define route in api.php, create/update BatchController with availability method
- Use Eloquent models for Batch entity, ensuring soft deletes and UTC handling
- Integrate with state machines to validate legality of availability toggle (e.g., prevent toggle if batch is reserved or in transit)
- Add transactional stock movements if toggle affects reservations/ledgers; post to accounting transaction headers + ledger_entry lines
- Support bulk operations if extensible, but focus on single batch for this endpoint
- Use Laravel validation for request input; handle polymorphic relations if attachments/notes are involved
- Error handling: Return 404 for non-existent batch, 422 for validation errors, 409 for state conflicts
- Observability: Log audit_event, integrate with queues/caching/etag, health/metrics
- Reporting tie-in: Update inventory aging/low stock analytics post-toggle

## Authentication/Authorization Requirements

- Requires Admin role with RBAC permissions for batch management (e.g., ability: batch:toggle-availability)
- Enforce branch scope: User must have access to the batch's assigned store/branch
- Support multi-role users via user_role junctions
- Include email verification, TOTP MFA + backup codes for sessions; API keys for integrations
- Middleware: auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope

## Expected Request/Response Format Considerations

- **Request:** JSON body with { ""available"": boolean } to set availability (true/false); or empty body for pure toggle if business logic dictates. Use idempotency keys for retries.
- **Response:** On success, 200 OK with updated batch JSON (including id, available status, updated_at, branch_id). Include ETag for caching.
- **Errors:** RFC7807 problem+json, e.g., { ""type"": ""https://example.com/probs/batch-unavailable"", ""title"": ""Batch toggle failed"", ""status"": 409, ""detail"": ""Batch is reserved"" }
- Content negotiation: Versioned API (e.g., /v1/), JSON only; sanitize inputs, guard uploads if media involved
- Search/autosuggest integration: Post-toggle, ensure reindex if batch visibility changes

## Relevant Business Logic

- Batch availability toggle affects inventory reservations, order confirmations, and fulfillment (e.g., unavailable batches skip in picking/shipping)
- Trigger ledger postings for valuation adjustments if availability impacts stock value
- Integrate with promotions/pricing: Unavailable batches ignore price_overrides/promos
- State machine enforcement: Only allow toggle from valid states (e.g., not during cycle count or dispatch)
- Compliance: Soft-delete instead of hard removal; audit all changes; support reversals if needed
- Integrations: Notify via webhooks (e.g., inventory updates); sync with carriers for dispatch if batch unavailability cancels shipments
- Analytics: Track toggle events for inventory aging, low stock alerts, cycle count accuracy
- Edge cases: Handle per-unit items within batch; blacklist/tag propagation if customer-facing; fraud flags if suspicious toggles"
276,batch,Audit Ledger,Batch movement ledger,api/batches/{id}/ledger,get,Admin,Implement GET /api/batches/{id}/ledger for Batch Audit Ledger,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue covers the implementation of the Audit Ledger API endpoint. Deshio manages core entities like product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment handles shipments and inter-store dispatch with transactional stock movements. Returns manage RMA with receive/restock/scrap, refunds, exchanges. Payments track intent→payment lifecycle and synchronization. Accounting uses transaction headers + ledger_entry lines for all movements, reversals, reconciliation/export. Services include service/service_order with lifecycle and profitability. Integrations cover carriers, webhooks, notifications. Security features user/role/permission with abilities, sessions, email verification, password reset, TOTP MFA, API keys. Observability includes audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware enforces TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines ensure legality of transitions for orders, dispatches, etc., with RFC7807 problem+json for conflicts. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, strict referential links. Design enables deterministic admin assignment, safe reservation/consumption, consistent ledger posting on stock/financial events.

This endpoint provides access to the batch movement ledger, enabling audit and tracking of inventory movements for a specific batch in the batch-centric inventory system.

## API Specifications

- **Category:** batch
- **Title:** Audit Ledger
- **Description:** Batch movement ledger
- **Route:** api/batches/{id}/ledger
- **HTTP Method:** get
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the GET endpoint to retrieve ledger entries for a specific batch ID
- [ ] Ensure the endpoint returns paginated ledger entries including transaction headers and ledger_entry lines for batch movements
- [ ] Validate that the batch ID exists and is accessible to the admin user
- [ ] Handle cases where the batch does not exist with appropriate RFC7807 error response
- [ ] Support query parameters for pagination (e.g., page, per_page), filtering (e.g., by date, type), and sorting
- [ ] Include relevant fields from accounting ledger: transaction details, movement types (reservations, adjustments, shipments, etc.), timestamps in UTC, soft delete awareness
- [ ] Ensure response includes audit_event linkages for compliance and observability
- [ ] Add unit and integration tests covering success, error cases, pagination, and authorization
- [ ] Verify integration with state machines for legal transitions in inventory movements
- [ ] Document the endpoint in API specs with examples
- [ ] Confirm compatibility with middleware: auth, RBAC, branch scope, throttles, idempotency, input sanitizer

## Technical Requirements

- Use Laravel controller (e.g., BatchLedgerController) and define route in api.php with {id} parameter binding
- Implement query builder or Eloquent for fetching ledger entries joined with batch, transaction headers, and ledger_entry lines
- Apply soft deletes filter and UTC timezone handling
- Use Laravel's pagination for responses
- Integrate with Deshio's normalized ERD for referential integrity across inventory, orders, fulfillment, and accounting entities
- Ensure deterministic posting of ledger entries on stock events (e.g., reservations, adjustments, cycle counts, shipments, returns)
- Handle polymorphic relations for notes/attachments if applicable to ledger entries
- Support EAV attributes if ledger entries include custom fields
- Use RequestId middleware for traceability and audit_event logging
- Implement caching/etag if applicable for performance, with cache headers
- Add input validation for {id} (UUID/integer) and query params using FormRequest
- Proper error handling: 404 for missing batch, 403 for unauthorized access, 422 for invalid params, using problem+json format
- Response should be JSON with consistent structure: data array of ledger entries, meta for pagination

## Authentication/Authorization Requirements

- Require Admin authentication via JWT, session, or API key
- Enforce RBAC: User must have admin role with permissions for batch ledger access (e.g., 'batch.view-ledger')
- Apply branch scope if batch is store-specific
- Include active user check, email-verified, and optional 2FA/MFA enforcement
- Use middleware stack: auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope

## Expected Request/Response Format Considerations

- **Request:** GET /api/batches/{id}/ledger? page=1&per_page=20&filter[date_from]=2023-01-01&filter[type]=adjustment&sort=created_at,desc
  - {id}: Required, validated as existing batch ID
  - Query params: Optional for pagination, filtering (date range, movement type), sorting
- **Response (200 OK):** JSON object with:
  {
    ""data"": [
      {
        ""id"": ""uuid"",
        ""transaction_id"": ""uuid"",
        ""batch_id"": ""uuid"",
        ""movement_type"": ""reservation|adjustment|shipment|etc."",
        ""quantity"": 10,
        ""value"": 100.00,
        ""store_id"": ""uuid"",
        ""created_at"": ""2023-01-01T00:00:00Z"",
        ""updated_at"": ""2023-01-01T00:00:00Z"",
        ""audit_notes"": ""string""
      }
    ],
    ""meta"": {
      ""current_page"": 1,
      ""last_page"": 5,
      ""per_page"": 20,
      ""total"": 100
    }
  }
- **Error Responses:** Use RFC7807 problem+json, e.g., 404: {""type"": ""https://example.com/errors/not-found"", ""title"": ""Batch not found"", ""detail"": ""Batch with ID {id} does not exist""}
- Ensure PII masking if ledger includes customer data; versioned content-negotiation for API versions

## Relevant Business Logic

- Ledger captures all batch movements: reservations (hold stock for orders), adjustments (manual changes), cycle counts (inventory verification), valuation updates, stock transfers via shipments/dispatch, returns/restock/scrap
- Ensure transactional consistency: Ledger postings occur on every stock/financial event, with reversals for cancellations/refunds
- Integrate with order states (e.g., confirmed→fulfilled triggers consumption), fulfillment (shipment_item movements), returns (RMA restock), payments (synchronization), and accounting (reconciliation)
- Support batch-centric inventory: Optional per-unit tracking, barcodes linkage
- Conflicts in state transitions (e.g., invalid movement) return problem+json via state machines
- Enable reporting: This endpoint supports analytics like inventory aging, low stock, cycle count accuracy, activity by batch
- Comply with observability: Log access, generate audit_event, use request-id for tracing
- Data integrity: Strict referential links to related entities (orders, shipments, etc.); soft deletes for archival without removing ledger history"
277,customer,Blacklist Customer,Blacklist for fraud/abuse,api/customers/{id}/blacklist,post,Admin,Implement Blacklist Customer API Endpoint,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue covers implementing the 'Blacklist Customer' API endpoint. Deshio handles core entities like product/category/vendor with attributes, media, barcodes, pricing, promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. Order domain includes states (pending→confirmed→fulfilled|cancelled), assignment, notes, promos, taxes, fraud flag. Fulfillment covers shipments, inter-store dispatch with tracking. Returns handle RMA, refunds, exchanges. Payments include intent→capture/void, refunds. Accounting uses transaction headers + ledger_entries, reversals, reconciliation. Services cover service_orders with lifecycle. Integrations include carriers, webhooks, notifications. Security & identity: user/role/permission, sessions, email verification, password reset, TOTP MFA, API keys. Observability: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures, cache headers. Reporting: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging, price history, cycle count accuracy, promo impact, activity. State machines ensure legal transitions for orders, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data in UTC; soft deletes; EAV for attributes; polymorphic notes/attachments; strict referential links. Design enables deterministic admin assignment, safe reservation/consumption, consistent ledger posting.

This endpoint blacklists a customer for fraud/abuse, integrating with customer tags/blacklist and fraud flags in orders.

## API Specifications

- **Category:** customer
- **Title:** Blacklist Customer
- **Description:** Blacklist for fraud/abuse
- **Route:** api/customers/{id}/blacklist
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST /api/customers/{id}/blacklist endpoint in Laravel controller
- [ ] Add input validation for customer ID and blacklist reason (if applicable)
- [ ] Ensure blacklisting updates customer record with blacklist tag and triggers any related audit events
- [ ] Handle fraud/abuse business logic, such as preventing future orders or flagging existing ones
- [ ] Write unit and integration tests for success, invalid ID, unauthorized access, and error scenarios
- [ ] Verify response follows Deshio API standards (JSON, RFC7807 for errors)
- [ ] Integrate with RBAC for Admin-only access and audit logging
- [ ] Test idempotency and throttling if applicable

## Technical Requirements

- Use Laravel controller and define route in api.php with {id} parameter binding to Customer model
- Implement input validation using Form Requests or Validator, ensuring {id} exists and is not already blacklisted
- Apply middleware stack: auth (JWT/API key), RBAC permission checks for admin, branch scope if relevant, input sanitizer, domain guards for fraud
- Use state machine if blacklisting affects customer lifecycle; soft delete or flag without hard removal
- Handle EAV attributes if blacklist reason is custom; polymorphic attachments for blacklist notes
- Ensure UTC timestamps and referential integrity with customer entity
- Add audit_event logging for blacklist action
- Follow content-negotiation for versioned API responses

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- Enforce RBAC: user must have role/permission for customer management and fraud handling
- Check active user, email-verified, 2FA if enabled
- Branch scope: ensure admin has access to the customer's associated branch/store
- Optional tenancy isolation
- Reject unauthorized requests with 403 Forbidden (RFC7807 problem+json)

## Expected Request/Response Format Considerations

- **Request:** POST with JSON body, e.g., {""reason"": ""fraudulent activity""} (optional reason field); path param {id} as UUID/int
- **Response:** 200 OK with updated customer JSON (masked PII), e.g., {""id"": ""uuid"", ""blacklisted"": true, ""blacklist_reason"": ""fraud""}
- Errors: 400 Bad Request for invalid input, 404 Not Found for non-existent customer, 409 Conflict if already blacklisted
- Use problem+json for errors per RFC7807
- Include ETag/caching headers if applicable; respect JSON limits and sanitizer

## Relevant Business Logic

- Blacklisting tags customer for fraud/abuse, preventing new orders, flagging existing ones with fraud flag
- Integrate with order domain: auto-cancel pending orders or block fulfillment
- Trigger notifications (email/SMS) via templates if configured
- Post ledger_entry if blacklisting affects financials (e.g., reverse pending payments)
- Ensure transactional consistency: atomic update to customer blacklist status
- Support reversals: allow unblacklisting via separate endpoint if needed
- Comply with observability: log request-id, audit_event for compliance; PII masking in logs
- Align with reporting: track blacklist rates in fraud analytics"
278,customer,Unblacklist Customer,Remove from blacklist,api/customers/{id}/unblacklist,post,Admin,Implement Unblacklist Customer API Endpoint,"## Overview

This GitHub issue is for implementing the 'Unblacklist Customer' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations with approximately 290 REST APIs built over a normalized ERD. It covers domains including catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags and blacklist functionality.

Inventory is batch-centric with support for reservations, adjustments, cycle counts, valuation, and ledgers. The order domain handles states from pending to confirmed/fulfilled/cancelled, with assignments, notes, attachments, promos, taxes, and fraud flags. Fulfillment involves shipments, inter-store dispatches with tracking and POD, and transactional stock movements. Returns are managed via RMA with receive/restock/scrap, refunds, and exchanges. Payments follow intent-to-capture/void lifecycles with refund synchronization. Accounting uses transaction headers and ledger entries for all movements, including reversals and reconciliation.

Services include service orders with lifecycle and profitability tracking. Integrations cover carriers, waybills, rates, tracking, webhooks, and notification templates (email/SMS). Security and identity features encompass users/roles/permissions with multi-role support, sessions, email verification, password reset, TOTP MFA, backup codes, and API keys. Observability includes audit events, logs, request IDs, PII masking, health/metrics, queues, caching/ETag.

Middleware stack includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC/permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards, upload mime guard, provider webhook signatures, replay defense, and cache headers.

Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, and activity. State machines enforce legal transitions for orders, shipments, returns, payments, etc., with RFC7807 problem+json for conflicts. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and maintenance. Data is stored in UTC with soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential integrity.

Design ensures deterministic admin assignment, safe reservations, and consistent ledger posting. This endpoint specifically handles removing a customer from the blacklist, tying into customer management with tags and security features.

## API Specifications

- **Category:** customer
- **Title:** Unblacklist Customer
- **Description:** Remove from blacklist
- **Route:** api/customers/{id}/unblacklist
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST /api/customers/{id}/unblacklist endpoint in Laravel
- [ ] Ensure the endpoint requires Admin authentication and RBAC permission checks
- [ ] Validate that the customer ID exists and is currently blacklisted
- [ ] Successfully remove the customer from the blacklist upon valid request
- [ ] Return 204 No Content or 200 OK with updated customer status on success
- [ ] Handle errors: 404 if customer not found, 403 if not authorized, 400 if not blacklisted, using RFC7807 problem+json format
- [ ] Log an audit event for the unblacklist action
- [ ] Add unit tests for controller logic, validation, and error cases
- [ ] Add integration tests for full request/response flow, including middleware (auth, RBAC, throttles)
- [ ] Ensure compatibility with soft deletes and UTC timestamps
- [ ] Document the endpoint in API specs with request/response examples
- [ ] Verify no impact on related entities like orders or tags

## Technical Requirements

- Use Laravel framework: Define route in api.php, implement in a dedicated controller (e.g., CustomerController or BlacklistController)
- Apply middleware: auth (JWT/API key), active user, RBAC (admin role/permission for customer unblacklist), branch scope if applicable
- Input validation: Use FormRequest or validator for {id} as UUID/integer, ensure customer is blacklisted (query customer table's blacklist flag or related table)
- Business logic: Update customer record to remove blacklist status/tag; trigger audit_event log; optionally notify via email/SMS if templates exist; ensure transactional update to prevent partial states
- No request body expected; path param {id} only
- Response: Prefer 204 No Content for success; include ETag/cache headers; error responses with problem+json detailing type, title, status, detail
- Integration: Link to customer entity in ERD; respect referential integrity; if polymorphic, handle attachments/notes if relevant
- Testing: Cover happy path, edge cases (non-existent ID, already unblacklisted, unauthorized), state machine legality if blacklist has transitions
- Observability: Include request-id, log unblacklist events, mask PII in logs
- Security: Sanitize inputs, guard against injection; use idempotency if retries possible
- Documentation: Add to OpenAPI/Swagger specs; note admin-only access and potential webhooks for customer status changes"
279,customer,Add Tag,Tag customer,api/customers/{id}/tags,post,Employee,Implement Add Tag API for Customers (POST /api/customers/{id}/tags),"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This issue is for implementing the 'Add Tag' API endpoint in the customer category, which allows tagging a customer. Tags are part of customer management, enabling categorization, such as for marketing or blacklist purposes.

## API Specifications

- **Category:** customer
- **Title:** Add Tag
- **Description:** Tag customer
- **Route:** api/customers/{id}/tags
- **HTTP Method:** post
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the POST /api/customers/{id}/tags endpoint to add a tag to a specified customer
- [ ] Validate that the customer ID exists and is accessible to the authenticated employee
- [ ] Ensure tags are added without duplicates if business logic requires uniqueness
- [ ] Handle successful tagging with appropriate response (e.g., 201 Created)
- [ ] Return RFC7807 problem+json for errors, such as invalid customer ID or unauthorized access
- [ ] Add unit and integration tests covering happy path, validation errors, and authorization failures
- [ ] Document the endpoint in API specs (e.g., OpenAPI/Swagger)
- [ ] Ensure compliance with middleware stack, including RBAC checks for employee permissions
- [ ] Verify audit logging for the tag addition event
- [ ] Test for soft deletes and UTC handling

## Technical Requirements

- Use Laravel framework: Create or update a CustomerController with a method for adding tags (e.g., addTag)
- Define route in api.php: Route::post('customers/{id}/tags', [CustomerController::class, 'addTag'])->middleware(['auth:employee', 'rbac:customer.tag.add']);
- Implement input validation using Form Requests or Validator: Require 'tag' as a string in request body, validate length/format per business rules
- Use Eloquent models: Associate tag via customer_tags pivot table or similar junction for many-to-many relationship
- Handle business logic: Check for existing tag to avoid duplicates; support tags/blacklist as per core entities; ensure transactional integrity if needed
- Error handling: Use Laravel exceptions for 404 (customer not found), 403 (unauthorized), 422 (validation)
- Response format: JSON with created tag details or success message; consider ETag for caching if applicable
- Integration: Ensure compatibility with search/autosuggest APIs for tagged customers

## Authentication/Authorization Requirements

- Authentication: Requires Employee JWT/session/API key
- Authorization: RBAC check - Employee must have permission to tag customers (e.g., role with 'customer.tag.add' ability)
- Additional checks: Active user, email-verified, 2FA if enabled; branch scope if customer is branch-specific
- Middleware: Apply auth, RBAC & permission checks, throttles, idempotency

## Expected Request/Response Format Considerations

- **Request:**
  POST /api/customers/{id}/tags
  Headers: Authorization: Bearer {token}, Content-Type: application/json, Accept: application/json
  Body: {""tag"": ""marketing_campaign""} (string, required; validate against allowed tags if predefined)

- **Success Response (201 Created):**
  {
    ""data"": {
      ""customer_id"": 123,
      ""tag"": ""marketing_campaign"",
      ""added_at"": ""2023-01-01T00:00:00Z""
    }
  }

- **Error Response (e.g., 422 Unprocessable Entity):**
  {
    ""type"": ""https://tools.ietf.org/html/rfc7231#section-6.5.1"",
    ""title"": ""Validation Error"",
    ""detail"": ""The tag field is required."",
    ""status"": 422,
    ""errors"": {""tag"": [""The tag field is required.""]}
  }

- Consider PII masking for customer data in logs; use request-id for tracing

## Relevant Business Logic

- Tags enable customer segmentation (e.g., tags for promotions, blacklist for restrictions)
- Addition should trigger any event listeners for notifications or analytics (e.g., update customer profiles)
- Ensure consistency with state machines if tags affect order processing or fraud flags
- Support polymorphic relationships if tags are extended to other entities
- Data in UTC; soft delete customers should prevent new tags but allow viewing existing"
280,customer,Remove Tag,Remove customer tag,api/customers/{id}/tags/{tag},delete,Employee,Implement API: Remove Customer Tag (DELETE /api/customers/{id}/tags/{tag}),"## Overview

Implement the 'Remove Tag' API endpoint for the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD. This endpoint allows removing a specific tag from a customer, supporting customer management features including tags and blacklist. Core entities include customers + tags/blacklist, with broader coverage of catalog, orders, inventory, logistics, payments, RBAC, and audits.

Deshio ERP Context:
Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.
Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint falls under the customer category and handles tag removal as part of customer profile management.

## API Specifications

- **Category:** customer
- **Title:** Remove Tag
- **Description:** Remove customer tag
- **Route:** api/customers/{id}/tags/{tag}
- **HTTP Method:** delete
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the DELETE endpoint to remove a specified tag from the customer with the given ID
- [ ] Ensure the endpoint requires Employee authentication and appropriate RBAC permissions
- [ ] Validate that the customer ID and tag exist; return 404 if not found
- [ ] Handle successful removal with a 204 No Content response
- [ ] Include proper error handling using RFC7807 problem+json for conflicts or invalid states
- [ ] Add unit and integration tests covering success, failure (e.g., non-existent customer/tag, unauthorized access), and edge cases (e.g., soft-deleted customers)
- [ ] Ensure audit logging for the tag removal event
- [ ] Verify middleware application: auth, RBAC checks, input sanitization, request ID, etc.
- [ ] Confirm data integrity: tag removal should update customer tags without affecting other entities
- [ ] Test for idempotency and throttling compliance

## Technical Requirements

- Use Laravel framework: Define route in api.php, create or update CustomerController with removeTag method
- Implement in a dedicated controller method handling the DELETE request
- Use Eloquent models for Customer and related Tag associations (many-to-many likely via pivot table)
- Apply input validation: Ensure {id} is a valid UUID/integer, {tag} is a valid tag identifier
- Integrate with state machines if applicable for customer tag transitions (though likely straightforward removal)
- Handle soft deletes: Check if customer is soft-deleted and prevent operations if archived
- Ensure UTC storage and timezone handling via middleware
- Add caching/ETag support if tags are frequently accessed
- Include PII masking in logs for customer data

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- RBAC: Employee role with permission to manage customer tags (e.g., 'customer.tags.delete')
- Apply middleware stack: auth, active user, email-verified, 2FA (if enabled), RBAC & permission checks, branch scope (if customer tied to branch)
- Unauthorized requests return 401/403 with problem+json details
- Support multi-role user_role assignments

## Expected Request/Response Format Considerations

- **Request:** No body required; path parameters {id} (customer ID, e.g., UUID) and {tag} (tag identifier, e.g., slug or ID)
- **Headers:** Standard API headers: Authorization, Accept: application/json, Content-Type if needed; support versioned content-negotiation
- **Success Response:** 204 No Content (empty body)
- **Error Responses:** 
  - 400 Bad Request: Invalid parameters (validation errors in problem+json)
  - 401 Unauthorized: Auth failure
  - 403 Forbidden: Insufficient permissions
  - 404 Not Found: Customer or tag not found
  - 429 Too Many Requests: Throttling
- All responses in JSON format with RFC7807 for errors; include request-id header
- No caching for DELETE operations; set appropriate cache headers

## Relevant Business Logic

- Tag removal detaches the specified tag from the customer without deleting the tag itself (assuming many-to-many relation)
- If tag is a blacklist, ensure removal logic aligns with compliance (e.g., audit trail)
- Trigger audit_event for the removal action, logging user, timestamp, customer ID, and tag
- Prevent removal if it would violate business rules (e.g., active orders referencing tags, though unlikely)
- Ensure transactional consistency: Use DB transactions to avoid partial updates
- Integrate with reporting: Tag changes may impact analytics like customer segmentation or LTV calculations
- Support polymorphic relations if tags have attachments/notes
- Align with overall design: Safe operations, referential integrity, and ledger posting if financial implications (none direct here)"
281,product,Add Image,Upload product image,api/products/{id}/images,post,Admin,Implement Add Product Image API (POST /api/products/{id}/images),"## Overview

Deshio is a Laravel-based ERP system for retail/omni-channel operations, featuring approximately 290 REST APIs built over a normalized ERD. It covers key domains including catalog (products/categories/vendors with attributes, media like product_images, barcodes, pricing with overrides), promotions; stores/branches; customers with tags/blacklist; batch-centric inventory supporting reservations, adjustments, cycle counts, valuation, and ledgers; order management (order/order_item states from pending to confirmed/fulfilled/cancelled, assignment to stores, notes/attachments, promos, taxes, fraud flags); fulfillment via shipments (shipment/shipment_item) and inter-store dispatches (with tracking, scan events, POD, transactional stock movements); returns handling (RMA with return/return_item, receive/restock/scrap, refunds, exchanges); payments (intent to capture/void, refund lifecycle, order payment status sync); accounting (transaction headers + ledger_entry lines for movements, reversals, reconciliation/export); services (service/service_order with lifecycle and profitability); integrations (carriers/accounts, waybills/rates/tracking, webhooks, notification templates for email/SMS); security/identity (user/role/permission with abilities, multi-role support, sessions, email verification, password reset, TOTP MFA + backup codes, API keys); observability/compliance (audit_event, logs, request-id, PII masking, health/metrics, queues, caching/etag).

Middleware includes TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user checks, email-verified, 2FA, RBAC/permission checks, branch scope, optional tenancy, throttles, idempotency, input sanitizer, domain guards (for order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics cover revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.

State machines enforce legal transitions for orders, items, dispatches, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs support bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, system maintenance. Data uses UTC storage, soft deletes, EAV for attributes, polymorphic notes/attachments, strict referential integrity. Design ensures deterministic admin assignment for online orders, safe reservation/consumption, consistent ledger posting on stock/financial events.

This API endpoint enables uploading and associating an image with a specific product, supporting the media (product_image) entity in the catalog domain.

## API Specifications

- **Category:** product
- **Title:** Add Image
- **Description:** Upload product image
- **Route:** api/products/{id}/images
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint accepts POST requests to /api/products/{id}/images with admin authentication
- [ ] Validates that the product {id} exists and is accessible to the authenticated admin
- [ ] Handles file upload (e.g., multipart/form-data) for product images with appropriate MIME type validation (e.g., JPEG, PNG)
- [ ] Stores the image in the media (product_image) relation for the product
- [ ] Returns a successful response with the uploaded image details (e.g., ID, URL)
- [ ] Implements proper error handling for invalid files, non-existent products, or authorization failures using RFC7807 problem+json
- [ ] Includes audit logging for the upload event
- [ ] Adds unit/integration tests covering success, validation errors, auth failures, and edge cases
- [ ] Ensures compatibility with middleware stack (e.g., upload mime guard, RBAC checks)
- [ ] Documents the endpoint in API specs with request/response examples

## Technical Requirements

- Implement in Laravel: Define route in api.php, create/update ProductController or dedicated ImageController with store method
- Use Laravel's file upload handling (e.g., Request::file('image')) and store in appropriate storage (e.g., public disk or S3)
- Associate uploaded image with Product model via product_image relationship (polymorphic if needed)
- Apply input validation rules (e.g., 'image' => 'required|image|mimes:jpeg,png,jpg|max:2048')
- Handle soft deletes and referential integrity when linking to product
- Integrate with state machines if any transitions are involved (though not primary for images)
- Ensure idempotency if re-uploads are possible
- Use ETag/caching headers for media responses
- Follow Deshio's observability: Add request-id tracing, audit_event for image addition

## Authentication/Authorization Requirements

- Requires Admin authentication (JWT/session/API key)
- Enforce RBAC: Admin role with permission for product media management (e.g., 'products.images.create')
- Apply branch scope if product is store-specific
- Include active user, email-verified, and 2FA checks via middleware
- Reject unauthorized access with 403 Forbidden (RFC7807 format)

## Expected Request/Response Format Considerations

- **Request:** multipart/form-data with file field 'image' (optional fields: 'alt_text', 'is_primary'); {id} as URL parameter (product ID)
- **Success Response (201 Created):** JSON with { ""data"": { ""id"": image_id, ""url"": image_url, ""product_id"": id, ""alt_text"": ""..."", ""is_primary"": true }, ""message"": ""Image added successfully"" }
- **Error Responses:** 400 Bad Request for validation errors (e.g., invalid file); 404 Not Found for non-existent product; 401 Unauthorized; 403 Forbidden; all in problem+json format per RFC7807
- Content negotiation: Accept application/json; versioned API (e.g., /v1/...)
- Use UTC for any timestamps in image metadata

## Relevant Business Logic

- Image upload supports product catalog enhancement, allowing multiple images per product with optional primary designation
- Ensure transactional consistency: If upload fails post-validation, rollback and don't create partial product_image record
- Integrate with media handling: Generate thumbnails if configured, handle polymorphic attachments if notes are added
- Comply with PII masking if image metadata includes sensitive data (unlikely for images)
- Trigger any webhooks/notifications if image addition affects product visibility (e.g., catalog sync)
- Support bulk operations indirectly via API patterns, but this is single-image upload
- Align with inventory/orders if image is used in fulfillment (e.g., product visuals for shipments)"
282,product,List Images,List product images,api/products/{id}/images,get,Employee,Implement API: List Product Images (GET /api/products/{id}/images),"## Overview

This GitHub issue is for implementing the 'List Images' API endpoint in the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations. Deshio features ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

The endpoint lists product images (media) associated with a specific product, supporting the catalog management in the product category.

## API Specifications

- **Category:** product
- **Title:** List Images
- **Description:** List product images
- **Route:** api/products/{id}/images
- **HTTP Method:** GET
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Implement the GET endpoint to retrieve a list of images for the specified product ID
- [ ] Ensure the endpoint requires Employee authentication and appropriate RBAC permissions
- [ ] Validate that the product ID exists; return 404 if not found
- [ ] Handle soft deletes appropriately (exclude deleted images if applicable)
- [ ] Support pagination or filtering if images are numerous (e.g., query params for limit/offset)
- [ ] Return images with relevant details like URL, alt text, order, and association to product
- [ ] Implement proper error handling using RFC7807 problem+json for conflicts or invalid states
- [ ] Add unit and integration tests covering happy path, authentication failures, invalid IDs, and edge cases
- [ ] Ensure middleware chain includes auth, RBAC checks, branch scope, input sanitizer, and cache headers
- [ ] Log audit events for access to product images if required by compliance
- [ ] Verify response uses UTC timestamps and ETag for caching

## Technical Requirements

- Use Laravel framework: Define the route in api.php, create or extend a ProductController with an images() method
- Implement Eloquent query to fetch product_image records polymorphic to the product entity
- Apply soft delete scoping if images support deletion
- Integrate with media handling (e.g., via Laravel's media library or custom storage for product_image)
- Use Request validation for {id} (must be valid UUID or integer) and any query params
- Response format: JSON array of image objects with fields like id, url, thumbnail_url, alt, position, created_at, updated_at
- Business logic: Images are part of product media; ensure list respects product visibility (e.g., active products only); no state machine needed for listing, but check product state if applicable
- Authentication/Authorization: JWT/session/API key via middleware; Employee role with permission to view products/images (RBAC via user_role and ability tables); enforce active user, email-verified, 2FA if enabled; branch scope if product assigned to specific stores
- Expected Request Format: GET /api/products/{id}/images with optional query params (?limit=10&order=position)
- Expected Response Format: 200 OK with JSON { ""data"": [ { ""id"": 1, ""url"": ""https://..."", ... } ], ""meta"": { ""total"": 5 } } or 401/403/404/422 with problem+json
- Error Handling: Use try-catch for database errors; return standardized errors for auth failures, not found, etc.
- Observability: Include request-id in logs; optional metrics for endpoint usage; audit_event if accessing sensitive media
- Integrations: Ensure image URLs are CDN-aware or use storage links; support attachments if images have polymorphic notes"
283,product,Delete Image,Delete product image,api/products/{id}/images/{image_id},delete,Admin,Implement DELETE /api/products/{id}/images/{image_id} for Product Image Deletion,"## Overview

As part of the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits, this issue covers the implementation of the 'Delete Image' API endpoint in the product category. Deshio manages core entities like product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain includes order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment handles shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns cover RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments manage intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting includes transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services handle service/service_order with lifecycle and profitability. Integrations include carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint allows admins to delete a specific product image, ensuring proper media management and audit logging.

## API Specifications

- **Category:** product
- **Title:** Delete Image
- **Description:** Delete product image
- **Route:** api/products/{id}/images/{image_id}
- **HTTP Method:** DELETE
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the DELETE endpoint to remove the specified product image
- [ ] Ensure the product ID ({id}) exists and the image ID ({image_id}) is associated with it
- [ ] Validate admin authentication and RBAC permissions for product management
- [ ] Handle successful deletion with appropriate response (e.g., 204 No Content)
- [ ] Return 404 if product or image not found
- [ ] Return 403 if unauthorized
- [ ] Log audit_event for the deletion
- [ ] Delete associated media file if applicable (e.g., from storage)
- [ ] Support soft deletes for archival if configured
- [ ] Add unit and integration tests covering happy path, errors, and edge cases
- [ ] Ensure idempotency and proper middleware application (e.g., auth, RBAC, throttles)
- [ ] Verify no impact on related entities like product attributes or inventory

## Technical Requirements

- Use Laravel controller (e.g., ProductImageController) with route definition in api.php
- Implement input validation for {id} and {image_id} (e.g., numeric, exists in products and product_images tables)
- Integrate with Eloquent models for Product and ProductImage (media polymorphic)
- Handle file deletion via Laravel Storage facade if image has physical file
- Apply soft deletes if enabled for product_images
- Use state machines if any transitions apply (though unlikely for images); otherwise, direct delete
- Include proper error handling with RFC7807 problem+json for conflicts
- Ensure UTC handling and request-id middleware
- Add caching/etag considerations if images are cached
- Write comprehensive tests using PHPUnit, including authentication mocks

## Authentication/Authorization Requirements

- Require Admin authentication via JWT/session/API key
- Enforce RBAC: User must have role/permission for product image management (e.g., 'delete-product-image' permission)
- Apply active user, email-verified, and 2FA checks via middleware
- Branch scope if applicable; optional tenancy
- Use ability (role↔perm) and user_role for multi-role checks

## Expected Request/Response Format Considerations

- **Request:** No body required; path parameters {id} (product ID) and {image_id} (image ID)
- **Response:** 
  - Success: 204 No Content
  - Error: 4xx/5xx with JSON body following RFC7807 (e.g., {""type"": ""https://example.com/probs/out-of-credit"", ""title"": ""Insufficient funds"", ""status"": 403})
- Versioned content-negotiation; JSON limits; input sanitizer
- No PII in responses; audit_event logging with request-id

## Relevant Business Logic

- Verify image belongs to the specified product to prevent cross-product deletions
- Trigger any necessary ledger_entry if deletion impacts pricing/promotions (unlikely for images)
- Ensure transactional integrity: delete image record and file atomically
- Support polymorphic attachments if image has notes/attachments
- Comply with strict referential links; prevent deletion if image is in use (e.g., active promotion media)
- Post-deletion, invalidate any caches for product media
- Align with Deshio's design for safe media management in catalog domain"
284,product,Set Primary Image,Set primary display image,api/products/{id}/images/{image_id}/primary,post,Admin,Implement POST /api/products/{id}/images/{image_id}/primary,"## Overview

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This API endpoint allows setting the primary display image for a product. Category: product. Title: Set Primary Image. Description: Set primary display image.

## API Specifications

- **Route:** api/products/{id}/images/{image_id}/primary
- **Method:** post
- **Authentication:** Admin
- **Category:** product

## Acceptance Criteria

- [ ] Implement the endpoint to set the specified image as primary for the product
- [ ] Ensure only one primary image per product; unset any existing primary if applicable
- [ ] Validate that the product and image exist and are associated
- [ ] Add input validation for {id} and {image_id} (UUIDs or integers as per ERD)
- [ ] Handle soft deletes: do not allow operations on deleted products/images
- [ ] Integrate with audit_event for logging the change
- [ ] Return RFC7807 problem+json for validation errors or unauthorized access
- [ ] Write unit tests for success and failure scenarios
- [ ] Write integration tests for the full request/response cycle
- [ ] Ensure compatibility with middleware stack (auth, RBAC, etc.)
- [ ] Update any relevant caches or etags after the change

## Technical Requirements

- Use Laravel controller (e.g., ProductImageController) and define route in api.php
- Implement in a service class for business logic (e.g., ProductImageService::setPrimary)
- Use Eloquent models for product and product_image with proper relations
- Apply input validation using Form Requests or Validator facade
- Handle transactions to ensure atomicity if multiple DB operations
- Integrate with state machines if image status affects product visibility
- Support polymorphic attachments if images have notes
- Follow Deshio conventions: UTC timestamps, soft deletes, referential integrity

## Authentication/Authorization Requirements

- Require Admin authentication via JWT/session/API key
- Enforce RBAC: user must have permission to manage product media (e.g., 'product.update')
- Apply branch scope if product is store-specific
- Include active user, email-verified, and 2FA checks via middleware
- Log audit_event with request-id and user details

## Expected Request/Response Format Considerations

- **Request:** No body required (POST to toggle/set primary). Path params: {id} (product ID), {image_id} (image ID). Headers: Authorization, Accept: application/json, Content-Type: application/json.
- **Success Response (200 OK):** JSON with updated product or image details, e.g., {""product"": {""id"": ""uuid"", ""primary_image_id"": ""image_uuid""}}, plus cache headers and etag.
- **Error Responses:** 401 Unauthorized, 403 Forbidden (RBAC/scope), 404 Not Found (product/image), 422 Unprocessable Entity (validation) with RFC7807 problem+json, e.g., {""title"": ""Validation Error"", ""detail"": ""Image not associated with product"", ""status"": 422}.
- Versioned via content-negotiation; support idempotency if retries possible.

## Relevant Business Logic

- Product media uses product_image entity; primary flag ensures one active display image per product.
- On set, update is_primary field in product_image table; cascade unset others linked to the product.
- Trigger any dependent events: e.g., reindex product for search/autosuggest, invalidate caches for catalog views.
- Ensure no impact on inventory/pricing; focus on catalog domain.
- Comply with PII masking if user-generated images; add log entry in audit_event."
285,product,Add Barcode,Add barcode to product,api/products/{id}/barcodes,post,Admin,Implement Add Barcode API for Products (POST /api/products/{id}/barcodes),"## Overview

This issue covers the implementation of the 'Add Barcode' API endpoint in the Deshio ERP system, a Laravel-based ERP for retail/omni-channel operations. The endpoint allows administrators to add a barcode to an existing product, supporting the inventory management features where inventory is batch-centric with optional per-unit items, barcodes, reservations, adjustments, cycle counts, valuation, and ledgers. Core entities include products with attributes, media, barcodes, and pricing. The system uses a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Data is stored in UTC, with soft deletes, EAV for attributes, polymorphic notes/attachments, and strict referential links. State machines ensure legality of transitions, with conflicts returning RFC7807 problem+json. Middleware includes auth (JWT/session/API key), RBAC checks, branch scope, input sanitizer, and more.

## API Specifications

- **Category:** product
- **Title:** Add Barcode
- **Description:** Add barcode to product
- **Route:** api/products/{id}/barcodes
- **HTTP Method:** POST
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint successfully adds a barcode to the specified product
- [ ] Validates product ID exists and user has admin permissions
- [ ] Handles duplicate barcodes appropriately (e.g., prevent or allow based on business rules)
- [ ] Returns appropriate success response with created barcode details
- [ ] Implements error handling for invalid inputs, non-existent product, or unauthorized access
- [ ] Includes unit and integration tests covering happy path, edge cases, and errors
- [ ] Endpoint is secured with middleware: auth, active user, RBAC (admin role/permission), branch scope
- [ ] Supports idempotency if applicable (e.g., via request ID)
- [ ] Logs audit events for the barcode addition
- [ ] Ensures transactional integrity with stock/financial ledgers if impacted

## Technical Requirements

- Use Laravel controller (e.g., ProductBarcodeController) and define route in api.php with {id} as product ID
- Implement input validation using Laravel's Form Requests or Validator: require barcode string (e.g., unique or validated format), optional fields like type or batch association
- Handle product retrieval via Eloquent model (Product::findOrFail($id)), ensuring soft deletes are respected
- Create barcode record linked to product (e.g., via hasMany relationship in Product model)
- Integrate with state machines if barcode addition affects product state (e.g., inventory readiness)
- Use RequestId middleware for tracing, and return JSON responses with proper status codes (201 for success, 4xx/5xx for errors in problem+json format)
- Consider caching/etag for product data, and PII masking if barcodes link to sensitive info
- Enable bulk operations if extensible, but focus on single addition for this endpoint
- Ensure compatibility with reporting/analytics (e.g., barcode in price change history or inventory aging)

## Authentication/Authorization Requirements

- Requires Admin authentication via JWT, session, or API key
- RBAC check: User must have 'admin' role with permission to manage products/barcodes (via ability/role/permission tables)
- Additional checks: Active user, email-verified, optional 2FA/TOTP, branch scope (if product is branch-specific)
- Middleware stack: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope, throttles, idempotency, input sanitizer, domain guards

## Expected Request/Response Format Considerations

- **Request:** JSON body with at least { ""barcode"": ""string"" }, optional { ""type"": ""string"", ""batch_id"": ""uuid"" } for batch-centric inventory
- **Headers:** Authorization (Bearer/JWT), Content-Type: application/json, X-Request-Id for idempotency
- **Response (Success 201):** { ""data"": { ""id"": ""uuid"", ""product_id"": ""uuid"", ""barcode"": ""string"", ""type"": ""string"", ""created_at"": ""utc-timestamp"" }, ""message"": ""Barcode added successfully"" }
- **Response (Error 4xx/5xx):** RFC7807 problem+json, e.g., { ""type"": ""validation_error"", ""title"": ""Invalid barcode"", ""detail"": ""Barcode already exists"", ""status"": 422 }
- Validate MIME types if attachments involved, but not primary here
- Use ETag for conditional requests if product caching enabled

## Relevant Business Logic

- Barcodes are core to product entity, enabling inventory tracking, reservations, adjustments, and ledgers
- Addition should trigger audit_event logging and potentially update product state (e.g., via state machine for inventory readiness)
- Ensure referential integrity: Link barcode to product without orphans; support polymorphic relations if needed
- Handle conflicts: If barcode exists, return error or update based on rules (e.g., unique per product or global)
- Integrate with fulfillment/logistics: New barcode may affect shipments, dispatches, or cycle counts
- Accounting: If barcode ties to valuation, post ledger_entry on addition
- Compliance: Mask PII if barcode encodes customer data; support feature flags for barcode formats
- Deterministic behavior: Safe reservation/consumption post-addition; consistent ledger posting on events"
286,product,List Barcodes,List product barcodes,api/products/{id}/barcodes,get,Employee,Implement API: List Product Barcodes (GET /api/products/{id}/barcodes),"## Context about Deshio ERP

Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits.
Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.
Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers.
Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag.
Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements.
Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order).
Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization.
Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export.
Services: service/service_order with lifecycle and profitability.
Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS).
Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys.
Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.
Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.
Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity.
State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.
APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance.
Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions.
Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

## Overview

Implement the 'List Barcodes' API endpoint in the Deshio ERP system. This endpoint allows authenticated employees to retrieve a list of barcodes associated with a specific product. It falls under the product category and supports the catalog management features, including barcodes as core product entities.

## API Specifications

- **Category:** product
- **Title:** List Barcodes
- **Description:** List product barcodes
- **Route:** api/products/{id}/barcodes
- **HTTP Method:** get
- **Authentication:** Employee

## Acceptance Criteria

- [ ] Endpoint returns a list of barcodes for the specified product ID
- [ ] Handles invalid product ID with appropriate error response (e.g., 404 Not Found)
- [ ] Supports pagination for large barcode lists if applicable
- [ ] Includes soft-deleted barcodes only if explicitly requested (default: exclude)
- [ ] Returns RFC7807 problem+json for conflicts or validation errors
- [ ] Integrates with RBAC to ensure only authorized employees can access
- [ ] Logs audit events for endpoint access
- [ ] Unit and integration tests cover success, error, and edge cases
- [ ] Documentation updated with request/response examples

## Technical Requirements

- Implement in Laravel: Create or update a controller (e.g., ProductBarcodeController) with a method to handle the GET request
- Define route in api.php or relevant routes file: Route::get('api/products/{id}/barcodes', [ProductBarcodeController::class, 'list'])
- Use Eloquent models for product and barcode entities, leveraging normalized ERD relationships (e.g., product hasMany barcodes)
- Apply middleware stack: auth (JWT/session/API key), RBAC & permission checks, branch scope, throttles, input sanitizer, cache headers
- Handle soft deletes: Query withProductBarcodes() or similar scope excluding soft-deleted by default
- Support UTC timestamps and EAV attributes if barcodes have extensible fields
- Ensure transactional consistency if barcodes relate to inventory batches
- Add request validation: Ensure {id} is a valid UUID/integer for product
- Implement proper error handling: 400 for invalid input, 403 for unauthorized, 500 for server errors

## Authentication/Authorization Requirements

- Requires Employee authentication via JWT, session, or API key
- RBAC check: User must have role/permission allowing access to product catalog and barcode listing (e.g., 'view_product_barcodes')
- Enforce active user, email-verified, and 2FA if enabled
- Branch scope: Limit to barcodes visible in user's assigned branches/stores
- Audit event logging for access attempts

## Expected Request/Response Format Considerations

- **Request:** GET /api/products/{id}/barcodes?include=deleted&page=1&per_page=50 (optional query params for pagination and includes)
  - No request body
  - {id}: Product identifier (e.g., UUID or integer)
- **Response:** 200 OK with JSON array of barcode objects
  - Example: {""data"": [{""id"": ""uuid"", ""code"": ""123456789"", ""type"": ""EAN13"", ""product_id"": ""uuid"", ""created_at"": ""2023-01-01T00:00:00Z"", ...}], ""meta"": {""current_page"": 1, ""last_page"": 1}}
  - Include relevant fields: id, code, type, status, batch relation if applicable
  - Use resource classes for serialization (e.g., BarcodeResource)
  - Error responses: RFC7807 format, e.g., {""title"": ""Not Found"", ""status"": 404, ""detail"": ""Product not found""}

## Relevant Business Logic

- Barcodes are core to product entities in the catalog domain, supporting inventory tracking (batch-centric) and sales
- Ensure listing respects product existence and ownership (e.g., via strict referential links)
- If barcodes link to inventory batches or per-unit items, include optional relations but avoid over-fetching
- Align with state machines if barcode status affects visibility (e.g., active/inactive)
- Support search/autosuggest if extended, but focus on basic list for this endpoint
- Consistent ledger posting not directly applicable, but ensure any related stock events are handled transactionally elsewhere
- PII masking if barcodes contain sensitive data (unlikely, but per compliance)"
287,product,Delete Barcode,Delete product barcode,api/products/{id}/barcodes/{code},delete,Admin,Implement Delete Product Barcode API Endpoint,"## Overview

This GitHub issue covers the implementation of the 'Delete Barcode' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD that covers catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes (fields/features), media (product_images), barcodes, pricing (price_overrides), and promotions. Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. This endpoint allows admins to delete a specific barcode associated with a product, ensuring proper validation, authorization, and auditing as per Deshio's design principles, which include state machines for legality, soft deletes for archival, strict referential integrity, and ledger posting for events.

The endpoint handles deletion of product barcodes, which are critical for inventory tracking in the batch-centric system. It must integrate with middleware for security (TLS/HSTS, CORS, auth via JWT/session/API key, RBAC & permission checks), observability (audit_events, logs, request-id, PII masking), and error handling (RFC7807 problem+json for conflicts).

## API Specifications

- **Category:** product
- **Title:** Delete Barcode
- **Description:** Delete product barcode
- **Route:** api/products/{id}/barcodes/{code}
- **HTTP Method:** DELETE
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint successfully deletes an existing barcode for the specified product ID and returns 204 No Content
- [ ] Returns 404 Not Found if the product or barcode does not exist
- [ ] Returns 403 Forbidden if the user lacks admin permissions
- [ ] Validates path parameters (product ID as UUID/integer, code as string)
- [ ] Implements soft delete if applicable, or permanent delete with archival via audits
- [ ] Logs audit_event for the deletion action
- [ ] Handles concurrent requests with idempotency and proper locking for inventory references
- [ ] Includes unit/integration tests covering success, error cases, and edge scenarios (e.g., barcode in use by inventory batches)
- [ ] Endpoint is versioned and follows content-negotiation (JSON responses)
- [ ] Integrates with middleware stack: auth, RBAC, branch scope, throttles, input sanitizer

## Technical Requirements

- Implement in Laravel: Define route in api.php, create controller method in ProductController or BarcodeController
- Use Eloquent models for Product and Barcode (assuming relationships: product hasMany barcodes)
- Input validation: Use FormRequest or validate() for path params {id} (product_id) and {code} (barcode_code)
- Business logic: Check if barcode belongs to product; if in use (e.g., linked to batches/inventory), prevent deletion or queue for archival; trigger ledger_entry if financial impact; use state machine if barcode has lifecycle states
- Error handling: Throw ValidationException, ModelNotFoundException, or custom exceptions mapping to RFC7807 problem+json (e.g., for referential integrity violations)
- Database: Ensure UTC storage, soft deletes (useSoftDeletes trait), and transactions for atomicity
- Observability: Generate request-id, log deletion event, emit audit_event with polymorphic attachments if needed
- Performance: Use caching/etag if applicable; respect queues for background tasks like reindexing related inventory
- Integrations: If barcode deletion affects promotions/pricing/search, trigger reindex or webhook deliveries

## Authentication/Authorization Requirements

- Requires Admin authentication (JWT/session/API key)
- RBAC check: User must have 'admin' role or specific permission (e.g., 'delete-product-barcode') via ability (role↔perm) and user_role (multi-role support)
- Additional guards: Active user, email-verified, 2FA (TOTP MFA + backup codes), branch scope (if multi-tenant), domain guards for product/inventory overrides
- Middleware sequence: Auth → Active User → Email Verified → 2FA → RBAC/Permission Checks → Branch Scope → (Optional) Tenancy → Throttles → Idempotency

## Expected Request/Response Format Considerations

- **Request:** No body required; path params only (e.g., DELETE /api/products/123/barcodes/ABC123). Headers: Authorization (Bearer token), Accept: application/json, Content-Type: application/json
- **Success Response (204 No Content):** Empty body; no content returned on successful deletion
- **Error Responses:** JSON with RFC7807 format, e.g., 400 Bad Request for invalid code format, 404 for non-existent resource, 409 Conflict if barcode is reserved/in-use, 422 Unprocessable Entity for validation failures
- **Example Error:** {""type"":""https://example.com/probs/validation"",""title"":""Invalid Barcode"",""status"":422,""detail"":""Barcode code must be alphanumeric""}
- Responses in UTC; use ETag for caching if endpoint supports conditional requests

## Relevant Business Logic

- Barcode deletion must verify no active references (e.g., in orders, shipments, inventory batches, reservations, cycle counts) to prevent orphan records; use strict referential links across junctions
- If deletion proceeds, update related entities (e.g., remove from autosuggest/search indexes, adjust pricing/promos if barcode-specific)
- Post-deletion: Trigger ledger_entry for inventory movement if applicable; synchronize with accounting transaction headers; handle reversals if needed
- Conflicts (e.g., barcode in pending order) return problem+json; state machines ensure legal transitions
- Supports bulk operations context but this is single delete; align with EAV attributes if barcodes have custom fields
- Ensure deterministic behavior in omni-channel setup, with safe reservation/consumption and consistent posting on stock events
- Compliance: PII masking if barcode links to customer data; feature flags for enabling/disabling endpoint"
288,store,Business Hours,Set business hours,api/stores/{id}/business-hours,post,Admin,Implement API: Set Business Hours for Store (POST /api/stores/{id}/business-hours),"## Overview

This GitHub issue is for implementing the 'Set business hours' API endpoint in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD that covers catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist.

Inventory is batch-centric with optional per-unit items, supporting reservations, adjustments, cycle counts, valuation, and ledgers. The order domain handles order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, and fraud flags. Fulfillment involves shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns manage RMA (return/return_item), receive/restock/scrap, refunds, and exchanges (exchange_order). Payments cover intent→payment capture/void; refund lifecycle; and order.payment_status synchronization.

Accounting includes transaction headers + ledger_entry lines for all movements; reversals; and reconciliation/export. Services handle service/service_order with lifecycle and profitability. Integrations support carriers & accounts, waybills/rates/tracking; webhooks with deliveries; and notification templates (email/SMS).

Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag.

Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers.

Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json.

APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data is stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint specifically allows admins to set business hours for a store, which is crucial for store/branch operations in the context of orders, inventory, and fulfillment.

## API Specifications

- **Category:** store
- **Title:** Business Hours
- **Description:** Set business hours
- **Route:** api/stores/{id}/business-hours
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST /api/stores/{id}/business-hours endpoint in the Laravel controller
- [ ] Validate that the store {id} exists and is accessible to the authenticated admin
- [ ] Accept and process business hours data (e.g., days of week, open/close times) with proper validation
- [ ] Update the store's business hours in the database, ensuring UTC storage and soft deletes compatibility
- [ ] Handle errors according to RFC7807 problem+json for invalid inputs, unauthorized access, or conflicts
- [ ] Integrate with RBAC: Ensure only admins with appropriate permissions can set business hours
- [ ] Add middleware for auth (JWT/session/API key), RBAC checks, branch scope, throttles, idempotency, and input sanitizer
- [ ] Generate audit_event for the business hours update
- [ ] Write unit and integration tests covering success, validation failures, auth failures, and edge cases (e.g., overlapping hours, invalid times)
- [ ] Ensure response includes updated business hours or success confirmation
- [ ] Verify compatibility with reporting/analytics for store operations (e.g., SLA, dispatch performance)
- [ ] Document the endpoint in API specs, including request/response examples

## Technical Requirements

- Use Laravel framework: Create or update StoreController with the businessHours method
- Define route in api.php: Route::post('stores/{id}/business-hours', [StoreController::class, 'setBusinessHours'])->middleware(['auth:admin', 'rbac:store.update']);
- Implement input validation using Form Requests or Validator: e.g., days (array of weekdays), open_time/close_time (time format), ensuring no overlaps or invalid ranges
- Use Eloquent models for Store entity, updating business_hours field (JSON or related table for hours per day)
- Apply state machine if business hours affect order/fulfillment transitions (e.g., restrict orders outside hours)
- Handle polymorphic attachments/notes if business hours changes require logging
- Ensure transactional integrity for database updates
- Add caching/etag support for store data post-update
- Integrate with queues for any async notifications (e.g., email admins on hours change)
- Follow content-negotiation for versioned API responses
- Use request-id for observability and log the operation

## Authentication/Authorization Requirements

- Authentication: Requires Admin-level JWT, session, or API key
- Authorization: RBAC check via user/role/permission – users must have 'store.update' permission; multi-role support
- Additional checks: Active user, email-verified, 2FA if enabled; branch scope to ensure admin can access the specific store
- Middleware stack: auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope
- On failure, return 401/403 with problem+json

## Expected Request/Response Format Considerations

- **Request:** JSON body, e.g., {""monday"": {""open"": ""09:00"", ""close"": ""18:00""}, ""tuesday"": ...} – validate structure, time formats (HH:MM in UTC), required fields
- **Response:** On success, 200 OK with updated store business hours JSON or 204 No Content; include ETag for caching
- **Errors:** 400 for validation errors (e.g., invalid time), 404 if store not found, 403 unauthorized, 422 unprocessable entity; all in RFC7807 problem+json format
- Support idempotency: Use key in header to prevent duplicate updates
- PII masking if any customer data indirectly affected; strict referential links to store entity

## Relevant Business Logic

- Business hours impact store availability for orders, inventory reservations, dispatch, and fulfillment – e.g., prevent order confirmation outside hours via domain guards
- Ensure hours align with locale/tz middleware for display, but store in UTC
- On update, trigger any related events: e.g., notify via notification templates (email/SMS) if hours change affects promotions or SLAs
- Integrate with analytics: Track changes in price change history equivalent for hours; affect inventory aging/low stock alerts if hours influence cycle counts
- Conflicts: If hours overlap with ongoing dispatches or orders, use state machines to validate transitions; return problem+json on illegality
- Ledger posting: If hours change affects financial events (e.g., extended hours impacting payments), ensure consistent posting
- Feature flags: Allow toggling advanced hour rules (e.g., holidays) if implemented
- Bulk compatibility: While this is single-store, consider extension for bulk updates in future APIs"
289,store,Holidays,Set store holidays,api/stores/{id}/holidays,post,Admin,Implement POST /api/stores/{id}/holidays for Setting Store Holidays,"## Overview

This GitHub issue is for implementing the API endpoint to set holidays for a specific store in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni with ~290 REST APIs over a normalized ERD covering catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities: product/category/vendor with attributes (field/feature), media (product_image), barcodes, pricing (price_override), promotions; stores/branches; customers + tags/blacklist. Inventory is batch-centric with optional per-unit items; supports reservations, adjustments, cycle counts, valuation, and ledgers. Order domain: order/order_item states (pending→confirmed→fulfilled|cancelled), assignment to store, notes/attachments, promos, taxes, fraud flag. Fulfillment: shipments (shipment/shipment_item) and inter-store dispatch (dispatch + tracking, scan events, POD) with transactional stock movements. Returns: RMA (return/return_item), receive/restock/scrap, refunds, exchanges (exchange_order). Payments: intent→payment capture/void; refund lifecycle; order.payment_status synchronization. Accounting: transaction headers + ledger_entry lines for all movements; reversals; reconciliation/export. Services: service/service_order with lifecycle and profitability. Integrations: carriers & accounts, waybills/rates/tracking; webhooks with deliveries; notification templates (email/SMS). Security & identity: user/role/permission with ability (role↔perm) and user_role (multi-role); sessions; email verification; password reset; TOTP MFA + backup codes; API keys. Observability & compliance: audit_event, log, request-id, PII masking, health/metrics, queues, caching/etag. Middleware plan: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, auth (JWT/session/API key), active user, email-verified, 2FA, RBAC & permission checks, branch scope, (optional) tenancy, throttles, idempotency, input sanitizer, domain guards (order/payment/dispatch/reservation/promo/override/cycle-count/fraud), upload mime guard, provider webhook signatures + replay defense, cache headers. Reporting/analytics: revenue/orders/units by store/product/user, LTV/AOV, return/refund rates, SLA, dispatch performance, inventory aging/low stock, price change history, cycle count accuracy, promo impact, activity. State machines drive legality of transitions for orders, order items, dispatch, shipments, returns, payments, cycle counts; conflicts return RFC7807 problem+json. APIs include bulk import/export, search/autosuggest, attachments, reindex, backups/restore, feature flags, and system maintenance. Data stored in UTC; soft deletes for archival; EAV for attributes; polymorphic notes/attachments; strict referential links across all junctions. Design enables deterministic admin assignment for online orders, safe reservation/consumption, and consistent ledger posting on every stock/financial event.

This endpoint allows administrators to configure holidays for a store, which may impact operations like order fulfillment, inventory adjustments, and store availability in the broader ERP ecosystem.

## API Specifications

- **Category:** store
- **Title:** Holidays
- **Description:** Set store holidays
- **Route:** api/stores/{id}/holidays
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Implement the POST endpoint to set holidays for a given store ID
- [ ] Validate that the store exists and the user has admin privileges
- [ ] Handle request body with holiday dates or configurations
- [ ] Return appropriate success response with updated holidays
- [ ] Implement error handling for invalid inputs, non-existent stores, or unauthorized access using RFC7807 problem+json
- [ ] Ensure integration with state machines if holidays affect order/dispatch transitions
- [ ] Add unit and integration tests covering happy path, validation errors, and authorization failures
- [ ] Document the endpoint in API specs (e.g., OpenAPI)
- [ ] Verify compatibility with middleware stack (auth, RBAC, branch scope, etc.)
- [ ] Test for idempotency and throttling

## Technical Requirements

- Use Laravel framework: Create a controller method in StoresController or dedicated HolidaysController
- Define route in api.php with {id} parameter binding to Store model
- Implement input validation using Form Requests (e.g., dates in YYYY-MM-DD format, array of holidays)
- Store holidays in a related model/table (e.g., store_holidays junction or JSON field on Store model)
- Apply soft deletes and UTC storage
- Integrate with audit_event for logging changes
- Use EAV if holidays have attributes; polymorphic attachments if needed
- Ensure referential integrity with stores/branches
- Handle business logic: Holidays may block reservations, order confirmations, or dispatch on those dates; trigger notifications or updates to reporting/analytics (e.g., store availability in revenue reports)
- Middleware: Enforce Admin role via RBAC & permission checks; branch scope if multi-store
- Observability: Add request-id, logging, and metrics for endpoint usage

## Authentication/Authorization Requirements

- Requires Admin authentication (JWT/session/API key)
- Enforce active user, email-verified, 2FA if enabled
- RBAC: User must have 'admin' role or specific permission (e.g., 'stores.manage-holidays')
- Branch scope: Ensure user can access the targeted store/branch

## Expected Request/Response Format Considerations

- **Request:** JSON body, e.g., {""holidays"": [""2024-12-25"", ""2024-01-01""]} or with details like {""holidays"": [{""date"": ""2024-12-25"", ""reason"": ""Christmas""}]}
- Validate against store ID existence and prevent duplicates
- **Response:** 201 Created with {""message"": ""Holidays set successfully"", ""holidays"": [...] } or 200 OK if updating
- Errors: 401 Unauthorized, 403 Forbidden, 404 Store not found, 422 Validation failed (RFC7807 format)
- Content negotiation: Versioned API, JSON only
- Caching: ETag for subsequent GET requests to holidays

## Relevant Business Logic

- Holidays configuration impacts store operations: Prevent order fulfillment, reservations, or cycle counts on holiday dates
- Integrate with order state machines to block transitions (e.g., pending→confirmed) if store is on holiday
- Update inventory ledgers or dispatch tracking if holidays affect inter-store movements
- Sync with reporting: Exclude holiday periods from SLA, dispatch performance, or revenue calculations
- Support bulk operations if extending to multiple stores; consider idempotency for repeated sets
- Ensure compliance: Audit changes, PII masking if reasons include sensitive info"
290,store,Sales Targets,Set sales targets,api/stores/{id}/targets,post,Admin,Implement POST api/stores/{id}/targets for Setting Sales Targets,"## Overview

This issue covers the implementation of the API endpoint for setting sales targets in the Deshio ERP system. Deshio is a Laravel-based ERP for retail/omni-channel operations, featuring ~290 REST APIs over a normalized ERD that covers catalog, orders, inventory, logistics, payments, RBAC, and audits. Core entities include products/categories/vendors with attributes, media, barcodes, pricing, promotions; stores/branches; customers with tags/blacklist. Inventory is batch-centric with reservations, adjustments, cycle counts, valuation, and ledgers. The sales targets endpoint allows admins to set targets for specific stores, integrating with reporting/analytics for revenue/orders/units by store, LTV/AOV, and promo impact.

## API Specifications

- **Category:** store
- **Title:** Sales Targets
- **Description:** Set sales targets
- **Route:** api/stores/{id}/targets
- **HTTP Method:** post
- **Authentication:** Admin

## Acceptance Criteria

- [ ] Endpoint responds to POST requests on api/stores/{id}/targets
- [ ] Requires Admin authentication and authorization
- [ ] Validates store ID exists and user has permission
- [ ] Accepts JSON payload for sales target data (e.g., target_amount, period, etc.)
- [ ] Persists sales targets to the database with proper relations to store entity
- [ ] Returns 201 Created on success with target details
- [ ] Handles errors per RFC7807 problem+json (e.g., 404 for invalid store, 403 unauthorized)
- [ ] Integrates with audit_event for logging the target setting action
- [ ] Supports soft deletes and UTC storage
- [ ] Includes unit and integration tests covering happy path, validation failures, and auth errors
- [ ] Endpoint is covered by middleware: TLS/HSTS, CORS, RequestId, JSON limits, versioned content-negotiation, locale/tz, JWT/session/API key auth, active user, email-verified, 2FA, RBAC & permission checks, branch scope, throttles, idempotency, input sanitizer

## Technical Requirements

- Use Laravel framework: Define route in api.php, create dedicated controller (e.g., StoreTargetController) with store method
- Model relations: Extend store entity with sales_targets table (e.g., polymorphic or direct relation); use EAV for flexible target attributes if needed
- Input validation: Use FormRequest for request body validation (e.g., target_amount as numeric, period as date range); sanitize inputs
- Database: Ensure referential integrity with store_id; use transactions for atomicity; post to accounting ledger if targets impact financial projections
- Error handling: Return standardized errors; log via audit_event and request-id tracing; handle conflicts with state machines if targets affect order/reservation legality
- Observability: Add metrics for endpoint usage; support caching/etag; queue if async processing needed for notifications
- Integrations: Tie into reporting/analytics for revenue by store; enable bulk import/export if targets support it; use feature flags for rollout
- Security: Enforce RBAC (admin role/permission for store targets); PII masking if targets include sensitive data; domain guards for store scope

## Authentication/Authorization Requirements

- Authentication: JWT/session/API key
- Authorization: Admin user only, verified via user/role/permission with ability (role↔perm) and user_role (multi-role); check active user, email-verified, TOTP MFA + backup codes
- Scope: Branch/store-specific; optional tenancy; RBAC checks via middleware
- Sessions: Support password reset and email verification

## Expected Request/Response Format Considerations

- **Request:** JSON body, e.g., {""target_amount"": 10000, ""period_start"": ""2024-01-01"", ""period_end"": ""2024-12-31"", ""notes"": ""Annual target""}; Use content-negotiation for versioned API
- **Response:** 201 Created with JSON, e.g., {""id"": 1, ""store_id"": 123, ""target_amount"": 10000, ""period_start"": ""2024-01-01T00:00:00Z"", ""period_end"": ""2024-12-31T23:59:59Z"", ""created_at"": ""2024-01-01T00:00:00Z""}; Include etag for caching
- **Errors:** RFC7807 problem+json, e.g., {""type"": ""https://example.com/probs/validation"", ""title"": ""Invalid Input"", ""status"": 422, ""detail"": ""Target amount must be positive""}
- Data in UTC; support attachments/notes polymorphically if targets include them

## Relevant Business Logic

- Sales targets enable deterministic admin assignment and tie into order fulfillment, promotions, and inventory reservations
- Ensure targets align with store/branch scope; update ledgers for valuation impacts
- Support state machines for target approval/transitions if extended; conflicts return problem+json
- Integrate with services like notifications (email/SMS templates) for target alerts; analytics for tracking achievement (e.g., sales vs. target ratios, low stock impacts)
- Handle reversals/adjustments similar to inventory cycle counts; export for reconciliation
- Polymorphic relations for notes/attachments on targets; strict referential links to stores
- Design for safe consumption in reporting: revenue/orders/units by store, promo impact, activity logs"
